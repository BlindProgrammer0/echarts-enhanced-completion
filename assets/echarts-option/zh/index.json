{
    "title": {
        "desc": " 标题组件，包含主标题和副标题。 在 ECharts 2.x 中单个 ECharts 实例最多只能拥有一个标题组件。但是在 ECharts 3 中可以存在任意多个标题组件，这在需要标题进行排版，或者单个实例中的多个图表都需要标题时会比较有用。 **例如下面不同缓动函数效果的示例，每一个缓动效果图都带有一个标题组件：**",
        "uiControl": {
            "type": "Object",
            "detailFileName": "title"
        }
    },
    "legend": {
        "desc": " 图例组件。 图例组件展现了不同系列的标记(symbol)，颜色和名字。可以通过点击图例控制哪些系列不显示。 ECharts 3 中单个 echarts 实例中可以存在多个图例组件，会方便多个图例的布局。 当图例数量过多时，可以使用 [滚动图例（垂直）][0] 或 [滚动图例（水平）][1]，参见：[legend.type][2]\n\n[0]: https://echarts.apache.org/examples/zh/editor.html?c=pie-legend&amp;edit=1&amp;reset=1\n[1]: https://echarts.apache.org/examples/zh/editor.html?c=radar2&amp;edit=1&amp;reset=1\n[2]: #legend.type",
        "uiControl": {
            "type": "Object",
            "detailFileName": "legend"
        }
    },
    "grid": {
        "desc": " 直角坐标系内绘图网格，单个 grid 内最多可以放置上下两个 X 轴，左右两个 Y 轴。可以在网格上绘制[折线图][0]，[柱状图][1]，[散点图（气泡图）][2]。 在 ECharts 2.x 里单个 echarts 实例中最多只能存在一个 grid 组件，在 ECharts 3 中可以存在任意个 grid 组件。 **例如下面这个 Anscombe Quartet 的示例：**\n\n[0]: #series-line\n[1]: #series-bar\n[2]: #series-scatter",
        "uiControl": {
            "type": "Object",
            "detailFileName": "grid"
        }
    },
    "xAxis": {
        "desc": " 直角坐标系 grid 中的 x 轴，一般情况下单个 grid 组件最多只能放上下两个 x 轴，多于两个 x 轴需要通过配置 [offset][0] 属性防止同个位置多个 x 轴的重叠。\n\n[0]: #xAxis.offset",
        "uiControl": {
            "type": "Object",
            "detailFileName": "xAxis"
        }
    },
    "yAxis": {
        "desc": " 直角坐标系 grid 中的 y 轴，一般情况下单个 grid 组件最多只能放左右两个 y 轴，多于两个 y 轴需要通过配置 [offset][0] 属性防止同个位置多个 Y 轴的重叠。\n\n[0]: #yAxis.offset",
        "uiControl": {
            "type": "Object",
            "detailFileName": "yAxis"
        }
    },
    "polar": {
        "desc": " 极坐标系，可以用于散点图和折线图。每个极坐标系拥有一个[角度轴][0]和一个[半径轴][1]。 **示例：**\n\n[0]: #angleAxis\n[1]: #radiusAxis",
        "uiControl": {
            "type": "Object",
            "detailFileName": "polar"
        }
    },
    "radiusAxis": {
        "desc": " 极坐标系的径向轴。 ",
        "uiControl": {
            "type": "Object",
            "detailFileName": "radiusAxis"
        }
    },
    "angleAxis": {
        "desc": " 极坐标系的角度轴。 ",
        "uiControl": {
            "type": "Object",
            "detailFileName": "angleAxis"
        }
    },
    "radar": {
        "desc": " 雷达图坐标系组件，只适用于[雷达图][0]。该组件等同 ECharts 2 中的 polar 组件。因为 3 中的 polar 被重构为标准的极坐标组件，为避免混淆，雷达图使用 radar 组件作为其坐标系。 雷达图坐标系与极坐标系不同的是它的每一个轴（indicator 指示器）都是一个单独的维度，可以通过 [name][1]、[axisLine][2]、[axisTick][3]、[axisLabel][4]、[splitLine][5]、 [splitArea][6] 几个配置项配置指示器坐标轴线的样式。 下面是一个 radar 组件的一个自定义例子。\n\n[0]: #series-radar\n[1]: #radar.name\n[2]: #radar.axisLine\n[3]: #radar.axisTick\n[4]: #radar.axisLabel\n[5]: #radar.splitLine\n[6]: #radar.splitArea",
        "uiControl": {
            "type": "Object",
            "detailFileName": "radar"
        }
    },
    "dataZoom": {
        "desc": "dataZoom 组件 用于区域缩放，从而能自由关注细节的数据信息，或者概览数据整体，或者去除离群点的影响。 现在支持这几种类型的 dataZoom 组件： \n\n* [内置型数据区域缩放组件（dataZoomInside）][0]：内置于坐标系中，使用户可以在坐标系上通过鼠标拖拽、鼠标滚轮、手指滑动（触屏上）来缩放或漫游坐标系。\n* [滑动条型数据区域缩放组件（dataZoomSlider）][1]：有单独的滑动条，用户在滑动条上进行缩放或漫游。\n* [框选型数据区域缩放组件（dataZoomSelect）][2]：提供一个选框进行数据区域缩放。即 [toolbox.feature.dataZoom][2]，配置项在 toolbox 中。\n\n如下例子：   \n- - -\n\n**✦ dataZoom 和 数轴的关系 ✦**dataZoom 主要是对 数轴（axis） 进行操作（控制数轴的显示范围，或称窗口（window））。 \n\n> 可以通过 [> dataZoom.xAxisIndex][3]>  或 [> dataZoom.yAxisIndex][4]>  或 [> dataZoom.radiusAxisIndex][5]>  或 [> dataZoom.angleAxisIndex][6]>  来指定 > dataZoom>  控制哪个或哪些数轴。 dataZoom 组件可 **同时存在多个**，起到共同控制的作用。如果多个 dataZoom 组件共同控制同一个数轴，他们会自动联动。   \n- - -\n\n**✦ dataZoom 组件如何影响轴和数据 ✦**dataZoom 的运行原理是通过 数据过滤 以及在内部设置轴的显示窗口来达到 数据窗口缩放 的效果。 数据过滤模式（[dataZoom.filterMode][7]）的设置不同，效果也不同。 可选值为： \n\n* 'filter'：当前数据窗口外的数据，被 **过滤掉**。即 **会** 影响其他轴的数据范围。每个数据项，只要有一个维度在数据窗口外，整个数据项就会被过滤掉。\n* 'weakFilter'：当前数据窗口外的数据，被 **过滤掉**。即 **会** 影响其他轴的数据范围。每个数据项，只有当全部维度都在数据窗口同侧外部，整个数据项才会被过滤掉。\n* 'empty'：当前数据窗口外的数据，被 **设置为空**。即 **不会** 影响其他轴的数据范围。\n* 'none': 不过滤数据，只改变数轴范围。\n\n如何设置，由用户根据场景和需求自己决定。经验来说： \n\n* 当『只有 X 轴 或 只有 Y 轴受 dataZoom 组件控制』时，常使用 filterMode: 'filter'，这样能使另一个轴自适应过滤后的数值范围。\n* 当『X 轴 Y 轴分别受 dataZoom 组件控制』时： \n  * 如果 X 轴和 Y 轴是『同等地位的、不应互相影响的』，比如在『双数值轴散点图』中，那么两个轴可都设为 fiterMode: 'empty'。\n  * 如果 X 轴为主，Y 轴为辅，比如在『柱状图』中，需要『拖动 dataZoomX 改变 X 轴过滤柱子时，Y 轴的范围也自适应剩余柱子的高度』，『拖动 dataZoomY 改变 Y 轴过滤柱子时，X 轴范围不受影响』，那么就 X轴设为 fiterMode: 'filter'，Y 轴设为 fiterMode: 'empty'，即主轴 'filter'，辅轴 'empty'。\n\n下面是个具体例子： \n\n    option = {\n        dataZoom: [\n            {\n                id: 'dataZoomX',\n                type: 'slider',\n                xAxisIndex: [0],\n                filterMode: 'filter'\n            },\n            {\n                id: 'dataZoomY',\n                type: 'slider',\n                yAxisIndex: [0],\n                filterMode: 'empty'\n            }\n        ],\n        xAxis: {type: 'value'},\n        yAxis: {type: 'value'},\n        series{\n            type: 'bar',\n            data: [\n                // 第一列对应 X 轴，第二列对应 Y 轴。\n                [12, 24, 36],\n                [90, 80, 70],\n                [3, 9, 27],\n                [1, 11, 111]\n            ]\n        }\n    }\n    \n\n上例中，dataZoomX 的 filterMode 设置为 'filter'。于是，假设当用户拖拽 dataZoomX（不去动 dataZoomY）导致其 valueWindow 变为 [2, 50] 时，dataZoomX 对 series.data 的第一列进行遍历，窗口外的整项去掉，最终得到的 series.data 为： \n\n    [\n        // 第一列对应 X 轴，第二列对应 Y 轴。\n        [12, 24, 36],\n        // [90, 80, 70] 整项被过滤掉，因为 90 在 dataWindow 之外。\n        [3, 9, 27]\n        // [1, 11, 111] 整项被过滤掉，因为 1 在 dataWindow 之外。\n    ]\n    \n\n过滤前，series.data 中对应 Y 轴的值有 24、80、9、11，过滤后，只剩下 24 和 9，那么 Y 轴的显示范围就会自动改变以适应剩下的这两个值的显示（如果 Y 轴没有被设置 min、max 固定其显示范围的话）。 所以，filterMode: 'filter' 的效果是：过滤数据后使另外的轴也能自动适应当前数据的范围。 再从头来，上例中 dataZoomY 的 filterMode 设置为 'empty'。于是，假设当用户拖拽 dataZoomY（不去动 dataZoomX）导致其 dataWindow 变为 [10, 60] 时，dataZoomY 对 series.data 的第二列进行遍历，窗口外的值被设置为 empty （即替换为 NaN，这样设置为空的项，其所对应柱形，在 X 轴还有占位，只是不显示出来）。最终得到的 series.data 为： \n\n    [\n        // 第一列对应 X 轴，第二列对应 Y 轴。\n        [12, 24, 36],\n        [90, NaN, 70], // 设置为 empty (NaN)\n        [3, NaN, 27],  // 设置为 empty (NaN)\n        [1, 11, 111]\n    ]\n    \n\n这时，series.data 中对应于 X 轴的值仍然全部保留不受影响，为 12、90、3、1。那么用户对 dataZoomY 的拖拽操作不会影响到 X 轴的范围。这样的效果，对于离群点（outlier）过滤功能，比较清晰。 如下面的例子： 另外，如果在任一个数轴上设置了 min、max（如设置 yAxis: {min: 0, max: 400}），那么这个数轴无论如何也不会被其他数轴的 dataZoom 行为影响了。   \n- - -\n\n**✦ 数据窗口的设置 ✦**dataZoom 的数据窗口范围的设置，目前支持两种形式： \n\n* 百分比形式：即设置 [dataZoom.start][8] 和 [dataZoom.end][9]。\n* 绝对数值形式：即设置 [dataZoom.startValue][10] 和 [dataZoom.endValue][11]。\n\n注意：当使用百分比形式指定 dataZoom 范围时，且处于如下场景（或类似场景）中，dataZoom 的结果是和 dataZoom 组件的定义顺序相关的。 \n\n    option = {\n        dataZoom: [\n            {\n                id: 'dataZoomX',\n                type: 'slider',\n                xAxisIndex: [0],\n                filterMode: 'filter', // 设定为 'filter' 从而 X 的窗口变化会影响 Y 的范围。\n                start: 30,\n                end: 70\n            },\n            {\n                id: 'dataZoomY',\n                type: 'slider',\n                yAxisIndex: [0],\n                filterMode: 'empty',\n                start: 20,\n                end: 80\n            }\n        ],\n        xAxis: {\n            type: 'value'\n        },\n        yAxis: {\n            type: 'value'\n            // yAxis 中并没有使用 min、max 来显示限定轴的显示范围。\n        },\n        series{\n            type: 'bar',\n            data: [\n                // 第一列对应 X 轴，第二列对应 Y 轴。\n                [12, 24, 36],\n                [90, 80, 70],\n                [3, 9, 27],\n                [1, 11, 111]\n            ]\n        }\n    }\n    \n\n在上例中，dataZoomY 的 start: 20, end: 80 到底表示什么意思？ \n\n* 如果 yAxis.min、yAxis.max 进行了直接设置： 那么 dataZoomY 的 start: 20, end: 80 表示 yAxis.min ~ yAxis.max 的 20% 到 80%。\n* 如果 yAxis.min、yAxis.max 没有设置： \n  * 如果 dataZoomX 设置为 filterMode: 'empty'： 那么 dataZoomY 的 start: 20, end: 80 表示 series.data 中 dataMinY ~ dataMaxY（即上例中的 9 ~ 80）的 20% 到 80%。\n  * 如果 dataZoomX 设置为 filterMode: 'filter'： 那么，因为 dataZoomX 定义 dataZoomY 组件之前，所以 dataZoomX 的 start: 30, end: 70 表示全部数据的 30% 到 70%，而 dataZoomY 组件的 start: 20, end: 80 表示经过 dataZoomX 过滤处理后，所得数据集的 20% 到 80%。 如果需要改变这种处理顺序，那么改变 dataZoomX 和 dataZoomY 在 option 中的出现顺序即可。\n\n\n\n[0]: #dataZoom-inside\n[1]: #dataZoom-slider\n[2]: #toolbox.feature.dataZoom\n[3]: #dataZoom.xAxisIndex\n[4]: #dataZoom.yAxisIndex\n[5]: #dataZoom.radiusAxisIndex\n[6]: #dataZoom.angleAxisIndex\n[7]: #dataZoom.filterMode\n[8]: #dataZoom.start\n[9]: #dataZoom.end\n[10]: #dataZoom.startValue\n[11]: #dataZoom.endValue",
        "uiControl": {
            "type": [
                "Array",
                "Object"
            ],
            "detailFileName": "dataZoom"
        }
    },
    "visualMap": {
        "desc": "visualMap 是视觉映射组件，用于进行『视觉编码』，也就是将数据映射到视觉元素（视觉通道）。 视觉元素可以是：  \n* symbol: 图元的图形类别。\n* symbolSize: 图元的大小。\n* color: 图元的颜色。\n* colorAlpha: 图元的颜色的透明度。\n* opacity: 图元以及其附属物（如文字标签）的透明度。\n* colorLightness: 颜色的明暗度，参见 [HSL][0]。\n* colorSaturation: 颜色的饱和度，参见 [HSL][0]。\n* colorHue: 颜色的色调，参见 [HSL][0]。\n\nvisualMap 组件可以定义多个，从而可以同时对数据中的多个维度进行视觉映射。 visualMap 组件可以定义为 [分段型（visualMapPiecewise）][1] 或 [连续型（visualMapContinuous）][2]，通过 type 来区分。例如： \n\n    option = {\n        visualMap: [\n            { // 第一个 visualMap 组件\n                type: 'continuous', // 定义为连续型 visualMap\n                ...\n            },\n            { // 第二个 visualMap 组件\n                type: 'piecewise', // 定义为分段型 visualMap\n                ...\n            }\n        ],\n        ...\n    };\n    \n\n  \n**✦ 视觉映射方式的配置 ✦** 既然是『数据』到『视觉元素』的映射，visualMap 中可以指定数据的『哪个维度』（参见[visualMap.dimension][3]）映射到哪些『视觉元素』（参见[visualMap.inRange][4] 和 [visualMap.outOfRange][5]）中。   \n在 visualMap 组件所控制的 series 中，如果 series 中某个数据项需要避开 visualMap 映射，可以这么配置： \n\n    series: {\n        type: '...',\n        data: [\n            {name: 'Shanghai', value: 251},\n            {name: 'Haikou', value: 21},\n            // 设置 `visualMap: false` 则 visualMap 不对此项进行控制，此时系列\n            // 可使用自身的视觉参数（color/symbol/ ...控制此项的显示。\n            {name: 'Beijing', value: 821, visualMap: false},\n            ...\n        ]\n    }\n    \n\n  \n**✦ 与 ECharts2 中 dataRange 的关系 ✦**visualMap 是由 ECharts2 中的 dataRange 组件改名以及扩展而来。ECharts3里 option 中的 dataRange 配置项仍然被兼容，会自动转换成 visualMap 配置项。在option中推荐写 visualMap 而非 dataRange。\n\n[0]: https://en.wikipedia.org/wiki/HSL_and_HSV\n[1]: #visualMap-piecewise\n[2]: #visualMap-continuous\n[3]: #visualMap.dimension\n[4]: #visualMap.inRange\n[5]: #visualMap.outOfRange",
        "uiControl": {
            "type": [
                "Array",
                "Object"
            ],
            "detailFileName": "visualMap"
        }
    },
    "tooltip": {
        "desc": " 提示框组件。 \n\n- - -\n\n**提示框组件的通用介绍：** 提示框组件可以设置在多种地方： \n\n* 可以设置在全局，即 [tooltip][0]\n* 可以设置在坐标系中，即 [grid.tooltip][1]、[polar.tooltip][2]、[single.tooltip][3]\n* 可以设置在系列中，即 [series.tooltip][4]\n* 可以设置在系列的每个数据项中，即 [series.data.tooltip][5]\n\n- - -\n\n\n\n[0]: #tooltip\n[1]: #grid.tooltip\n[2]: #polar.tooltip\n[3]: #single.tooltip\n[4]: #series.tooltip\n[5]: #series.data.tooltip",
        "uiControl": {
            "type": "Object",
            "detailFileName": "tooltip"
        }
    },
    "axisPointer": {
        "desc": " 这是坐标轴指示器（axisPointer）的全局公用设置。 \n\n- - -\n\n坐标轴指示器是指示坐标轴当前刻度的工具。 如下例，鼠标悬浮到图上，可以出现标线和刻度文本。 上例中，使用了 [axisPointer.link][0] 来关联不同的坐标系中的 axisPointer。 坐标轴指示器也有适合触屏的交互方式，如下： 坐标轴指示器在多轴的场景能起到辅助作用： \n\n- - -\n\n**> 注意：**>  一般来说，axisPointer 的具体配置项会配置在各个轴中（如 [> xAxis.axisPointer][1]> ）或者 > tooltip>  中（如 [> tooltip.axisPointer][2]> ）。 > 但是这几个选项只能配置在全局的 axisPointer 中：[> axisPointer.triggerOn][3]> 、[> axisPointer.link][0]> 。 - - -\n\n**如何显示 axisPointer：** 直角坐标系 [grid][4]、极坐标系 [polar][5]、单轴坐标系 [single][6] 中的每个轴都自己的 axisPointer。 他们的 axisPointer 默认不显示。有两种方法可以让他们显示： \n\n* 设置轴上的 axisPointer.show（例如 [xAxis.axisPointer.show][7]）为 true，则显示此轴的 axisPointer。\n* 设置 [tooltip.trigger][8] 设置为 'axis' 或者 [tooltip.axisPointer.type][9] 设置为 'cross'，则此时坐标系会自动选择显示哪个轴的 axisPointer，也可以使用 [tooltip.axisPointer.axis][10] 改变这种选择。注意，轴上如果设置了 axisPointer，会覆盖此设置。\n\n- - -\n\n**如何显示 axisPointer 的 label：** axisPointer 的 label 默认不显示（也就是默认只显示指示线），除非： \n\n* 设置轴上的 axisPointer.label.show（例如 [xAxis.axisPointer.label.show][7]）为 true，则显示此轴的 axisPointer 的 label。\n* 设置 [tooltip.axisPointer.type][9] 为 'cross' 时会自动显示 axisPointer 的 label。\n\n- - -\n\n**关于触屏的 axisPointer 的设置** 设置轴上的 axisPointer.handle.show（例如 [xAxis.axisPointer.handle.show][11] 为 true 则会显示出此 axisPointer 的拖拽按钮。（polar 坐标系暂不支持此功能）。 **注意：** 如果发现此时 tooltip 效果不良好，可设置 [tooltip.triggerOn][12] 为 'none'（于是效果为：手指按住按钮则显示 tooltip，松开按钮则隐藏 tooltip），或者 [tooltip.alwaysShowContent][13] 为 true（效果为 tooltip 一直显示）。 参见[例子][14]。 \n\n- - -\n\n**自动吸附到数据（snap）** 对于数值轴、时间轴，如果开启了 [snap][15]，则 axisPointer 会自动吸附到最近的点上。 \n\n- - -\n\n- - -\n\n\n\n[0]: #axisPointer.link\n[1]: #xAxis.axisPointer\n[2]: #tooltip.axisPointer\n[3]: #axisPointer.triggerOn\n[4]: #grid\n[5]: #polar\n[6]: #single\n[7]: #xAxis.axisPointer.show\n[8]: #tooltip.trigger\n[9]: #tooltip.axisPointer.type\n[10]: #tooltip.axisPointer.axis\n[11]: #xAxis.axisPointer.handle.show\n[12]: #tooltip.triggerOn\n[13]: #tooltip.alwaysShowContent\n[14]: https://echarts.apache.org/examples/zh/editor.html?c=line-tooltip-touch&amp;edit=1&amp;reset=1\n[15]: #xAxis.axisPointer.snap",
        "uiControl": {
            "type": "Object",
            "detailFileName": "axisPointer"
        }
    },
    "toolbox": {
        "desc": " 工具栏。内置有[导出图片][0]，[数据视图][1]，[动态类型切换][2]，[数据区域缩放][3]，[重置][4]五个工具。 **如下示例：**\n\n[0]: #toolbox.feature.saveAsImage\n[1]: #toolbox.feature.dataView\n[2]: #toolbox.feature.magicType\n[3]: #toolbox.feature.dataZoom\n[4]: #toolbox.feature.reset",
        "uiControl": {
            "type": "Object",
            "detailFileName": "toolbox"
        }
    },
    "brush": {
        "desc": "brush 是区域选择组件，用户可以选择图中一部分数据，从而便于向用户展示被选中数据，或者他们的一些统计计算结果。   \n- - -\n\n**刷子的类型和启动按钮** 目前 brush 组件支持的图表类型：scatter、bar、candlestick（parallel 本身自带刷选功能，但并非由 brush 组件来提供）。 点击 toolbox 中的按钮，能够进行『区域选择』、『清除选择』等操作。   \n横向刷子 的示例如下（点击 toolbox 中的按钮启动刷选）：   \nbar 图中的 brush（点击 toolbox 中的按钮启动刷选）： 启动 brush 的按钮既可以在 toolbox 中指定（参见 [toolbox.feature.brush.type][0]），也可以在 brush 组件的配置中指定（参见 [brush.toolbox][1]）。 支持这几种选框：矩形刷子，任意形状刷子，横向刷子，纵向刷子。参见 [brush.toolbox][1]。 可以使用 保持选择 按钮，切换单选和多选模式。 \n\n* 单选即同时只能存在一个选框，可单击空白区域消除选框。\n* 多选即同时可存在多个选框，单击空白区域不能消除选框，需要点击『清除按钮』消除线框。\n\n  \n- - -\n\n**刷选和坐标系的关系** 可以设置 brush 是『全局的』还是『属于坐标系的』。 **全局 brush** 在 echarts 实例中任意地方刷选。这是默认情况。如果没有指定为『坐标系 brush』，就是『全局 brush』。 **坐标系 brush** 在 指定的坐标系中刷选。选框可以跟随坐标系的缩放和平移（roam 和 dataZoom）而移动。 坐标系 brush 实际更为常用，尤其是在 geo 中。 通过指定 [brush.geoIndex][2] 或 [brush.xAxisIndex][3] 或 [brush.yAxisIndex][4] 来规定可以在哪些坐标系中进行刷选。 这几个配置项的取值可以是： \n\n* 'all'，表示所有\n* number，如 0，表示这个 index 所对应的坐标系。\n* Array，如 [0, 4, 2]，表示指定这些 index 所对应的坐标系。\n* 'none' 或 null 或 undefined，表示不指定。\n\n例如： \n\n    option = {\n        geo: {\n            ...\n        },\n        brush: {\n            geoIndex: 'all', // 只可以在所有 geo 坐标系中刷选，也就是上面定义的 geo 组件中。\n            ...\n        }\n    };\n    \n\n例如： \n\n    option = {\n        grid: [\n            {...}, // grid 0\n            {...}  // grid 1\n        ],\n        xAxis: [\n            {gridIndex: 1, ...}, // xAxis 0，属于 grid 1。\n            {gridIndex: 0, ...}  // xAxis 1，属于 grid 0。\n        ],\n        yAxis: [\n            {gridIndex: 1, ...}, // yAxis 0，属于 grid 1。\n            {gridIndex: 0, ...}  // yAxis 1，属于 grid 0。\n        ],\n        brush: {\n            xAxisIndex: [0, 1], // 只可以在 xAxisIndex 为 `0` 和 `1` 的 xAxis 所在的直角坐标系中刷选。\n            ...\n        }\n    };\n    \n\n  \n- - -\n\n**使用 API 控制选框** 可以通过调用 dispatchAction 来用程序主动渲染选框，例如： \n\n    myChart.dispatchAction({\n        type: 'brush',\n        areas: [\n            {\n                geoIndex: 0,\n                // 指定选框的类型。\n                brushType: 'polygon',\n                // 指定选框的形状。\n                coordRange: [[119.72,34.85],[119.68,34.85],[119.5,34.84],[119.19,34.77]]\n            }\n        ]\n    });\n    \n\n详情参见 [action.brush][5]  \n- - -\n\n**brushLink** 不同系列间，选中的项可以联动。 参见如下效果（刷选一个 scatter，其他 scatter 以及 parallel 图都会有选中效果）： brushLink 配置项是一个数组，内容是 seriesIndex，指定了哪些 series 可以被联动。例如可以是： \n\n* [3, 4, 5] 表示 seriesIndex 为 3, 4, 5 的 series 可以被联动。\n* 'all' 表示所有 series 都进行 brushLink。\n* 'none' 或 null 或 undefined 表示不启用 brushLink 功能。\n\n**注意** brushLink 是通过 dataIndex 进行映射，所以需要保证，**联动的每个系列的 data 都是 index 对应的**。* 例如： \n\n    option = {\n        brush: {\n            brushLink: [0, 1]\n        },\n        series: [\n            {\n                type: 'bar'\n                data: [232,    4434,    545,      654]     // data 有四个项\n            },\n            {\n                type: 'parallel',\n                data: [[4, 5], [3, 5], [66, 33], [99, 66]] // data 同样有四个项，两个系列的 data 是对应的。\n            }\n        ]\n    };\n    \n\n参见 [brush.brushLink][6]。   \n- - -\n\n**throttle / debounce / 事件延迟** 默认情况，刷选或者移动选区的时候，会不断得发 brushSelected 事件，从而告诉外界选中的内容。 但是频繁的事件可能导致性能问题，或者动画效果很差。所以 brush 组件提供了 [brush.throttleType][7]，[brush.throttleDelay][8] 来解决这个问题。 throttleType 取值可以是： \n\n* 'debounce'：表示只有停止动作了（即一段时间没有操作了），才会触发事件。时间阈值由 [brush.throttleDelay][8] 指定。\n* 'fixRate'：表示按照一定的频率触发事件，时间间隔由 [brush.throttleDelay][8] 指定。\n\n  \n- - -\n\n**被选中项和未被选中项的视觉设置** 参见 [brush.inBrush][9] 和 [brush.outOfBrush][10]。   \n- - -\n\n下面是详细配置。\n\n[0]: #toolbox.feature.brush.type\n[1]: #brush.toolbox\n[2]: #brush.geoIndex\n[3]: #brush.xAxisIndex\n[4]: #brush.yAxisIndex\n[5]: api.html#action.brush\n[6]: #brush.brushLink\n[7]: #brush.throttleType\n[8]: #brush.throttleDelay\n[9]: #brush.inBrush\n[10]: #brush.outOfBrush",
        "uiControl": {
            "type": "Object",
            "detailFileName": "brush"
        }
    },
    "geo": {
        "desc": " 地理坐标系组件。 地理坐标系组件用于地图的绘制，支持在地理坐标系上绘制[散点图][0]，[线集][1]。 3.1.10 开始 geo 组件也支持鼠标事件。事件参数为 \n\n    {\n        componentType: 'geo',\n        // Geo 组件在 option 中的 index\n        geoIndex: number,\n        // 点击区域的名称，比如&quot;上海&quot;\n        name: string,\n        // 传入的点击区域的 region 对象，见 geo.regions\n        region: Object\n    }\n    \n\n**Tip:** geo 区域的颜色也可以被 map series 所控制，参见 [series-map.geoIndex][2]。\n\n[0]: #series-scatter\n[1]: #series-lines\n[2]: #series-map.geoIndex",
        "uiControl": {
            "type": "Object",
            "detailFileName": "geo"
        }
    },
    "parallel": {
        "desc": "**平行坐标系介绍**[平行坐标系（Parallel Coordinates）][0] 是一种常用的可视化高维数据的图表。 例如 [series-parallel.data][1] 中有如下数据： \n\n    [\n        [1,  55,  9,   56,  0.46,  18,  6,  '良'],\n        [2,  25,  11,  21,  0.65,  34,  9,  '优'],\n        [3,  56,  7,   63,  0.3,   14,  5,  '良'],\n        [4,  33,  7,   29,  0.33,  16,  6,  '优'],\n        { // 数据项也可以是 Object，从而里面能含有对线条的特殊设置。\n            value: [5,  42,  24,  44,  0.76,  40,  16, '优']\n            lineStyle: {...},\n        }\n        ...\n    ]\n    \n\n数据中，每一行是一个『数据项』，每一列属于一个『维度』。（例如上面数据每一列的含义分别是：『日期』,『AQI指数』, 『PM2.5』, 『PM10』, 『一氧化碳值』, 『二氧化氮值』, 『二氧化硫值』）。 平行坐标系适用于对这种多维数据进行可视化分析。每一个维度（每一列）对应一个坐标轴，每一个『数据项』是一条线，贯穿多个坐标轴。在坐标轴上，可以进行数据选取等操作。如下： **配置方式概要** 『平行坐标系』的 option 基本配置如下例： \n\n    option = {\n        parallelAxis: [                     // 这是一个个『坐标轴』的定义\n            {dim: 0, name: schema[0].text}, // 每个『坐标轴』有个 'dim' 属性，表示坐标轴的维度号。\n            {dim: 1, name: schema[1].text},\n            {dim: 2, name: schema[2].text},\n            {dim: 3, name: schema[3].text},\n            {dim: 4, name: schema[4].text},\n            {dim: 5, name: schema[5].text},\n            {dim: 6, name: schema[6].text},\n            {dim: 7, name: schema[7].text,\n                type: 'category',           // 坐标轴也可以支持类别型数据\n                data: ['优', '良', '轻度污染', '中度污染', '重度污染', '严重污染']\n            }\n        ],\n        parallel: {                         // 这是『坐标系』的定义\n            left: '5%',                     // 平行坐标系的位置设置\n            right: '13%',\n            bottom: '10%',\n            top: '20%',\n            parallelAxisDefault: {          // 『坐标轴』的公有属性可以配置在这里避免重复书写\n                type: 'value',\n                nameLocation: 'end',\n                nameGap: 20\n            }\n        },\n        series: [                           // 这里三个系列共用一个平行坐标系\n            {\n                name: '北京',\n                type: 'parallel',           // 这个系列类型是 'parallel'\n                data: [\n                    [1,  55,  9,   56,  0.46,  18,  6,  '良'],\n                    [2,  25,  11,  21,  0.65,  34,  9,  '优'],\n                    ...\n                ]\n            },\n            {\n                name: '上海',\n                type: 'parallel',\n                data: [\n                    [3,  56,  7,   63,  0.3,   14,  5,  '良'],\n                    [4,  33,  7,   29,  0.33,  16,  6,  '优'],\n                    ...\n                ]\n            },\n            {\n                name: '广州',\n                type: 'parallel',\n                data: [\n                    [4,  33,  7,   29,  0.33,  16,  6,  '优'],\n                    [5,  42,  24,  44,  0.76,  40,  16, '优'],\n                    ...\n                ]\n            }\n        ]\n    };\n    \n\n需要涉及到三个组件：[parallel][2]、[parallelAxis][3]、[series-parallel][4]* [parallel][2] 这个配置项是平行坐标系的『坐标系』本身。一个系列（series）或多个系列（如上图中的『北京』、『上海』、『广州』分别各是一个系列）可以共用这个『坐标系』。 和其他坐标系一样，坐标系也可以创建多个。 位置设置，也是放在这里进行。\n* [parallelAxis][3] 这个是『坐标系』中的坐标轴的配置。自然，需要有多个坐标轴。 其中有 [parallelAxis.parallelIndex][5] 属性，指定这个『坐标轴』在哪个『坐标系』中。默认使用第一个『坐标系』。\n* [series-parallel][4] 这个是『系列』的定义。系列被画到『坐标系』上。 其中有 [series-parallel.parallelIndex][6] 属性，指定使用哪个『坐标系』。默认使用第一个『坐标系』。\n\n**配置注意和最佳实践** 配置多个 [parallelAxis][3] 时，有些值一样的属性，如果书写多遍则比较繁琐，那么可以放置在 [parallel.parallelAxisDefault][7] 里。在坐标轴初始化前，[parallel.parallelAxisDefault][7] 里的配置项，会分别融合进 [parallelAxis][3]，形成最终的坐标轴的配置。 **如果数据量很大并且发生卡顿** 建议把 [series-parallel.lineStyle.width][8] 设为 0.5（或更小）， 可能显著改善性能。 **高维数据的显示** 维度比较多时，比如有 50+ 的维度，那么就会有 50+ 个轴。那么可能会页面显示不下。 可以通过 [parallel.axisExpandable][9] 来改善显示效果。\n\n[0]: https://en.wikipedia.org/wiki/Parallel_coordinates\n[1]: #series-parallel.data\n[2]: #parallel\n[3]: #parallelAxis\n[4]: #series-parallel\n[5]: #parallelAxis.parallelIndex\n[6]: #series-parallel.parallelIndex\n[7]: #parallel.parallelAxisDefault\n[8]: #series-parallel.lineStyle.width\n[9]: #parallel.axisExpandable",
        "uiControl": {
            "type": "Object",
            "detailFileName": "parallel"
        }
    },
    "parallelAxis": {
        "desc": " 这个组件是平行坐标系中的坐标轴。 **平行坐标系介绍**[平行坐标系（Parallel Coordinates）][0] 是一种常用的可视化高维数据的图表。 例如 [series-parallel.data][1] 中有如下数据： \n\n    [\n        [1,  55,  9,   56,  0.46,  18,  6,  '良'],\n        [2,  25,  11,  21,  0.65,  34,  9,  '优'],\n        [3,  56,  7,   63,  0.3,   14,  5,  '良'],\n        [4,  33,  7,   29,  0.33,  16,  6,  '优'],\n        { // 数据项也可以是 Object，从而里面能含有对线条的特殊设置。\n            value: [5,  42,  24,  44,  0.76,  40,  16, '优']\n            lineStyle: {...},\n        }\n        ...\n    ]\n    \n\n数据中，每一行是一个『数据项』，每一列属于一个『维度』。（例如上面数据每一列的含义分别是：『日期』,『AQI指数』, 『PM2.5』, 『PM10』, 『一氧化碳值』, 『二氧化氮值』, 『二氧化硫值』）。 平行坐标系适用于对这种多维数据进行可视化分析。每一个维度（每一列）对应一个坐标轴，每一个『数据项』是一条线，贯穿多个坐标轴。在坐标轴上，可以进行数据选取等操作。如下： **配置方式概要** 『平行坐标系』的 option 基本配置如下例： \n\n    option = {\n        parallelAxis: [                     // 这是一个个『坐标轴』的定义\n            {dim: 0, name: schema[0].text}, // 每个『坐标轴』有个 'dim' 属性，表示坐标轴的维度号。\n            {dim: 1, name: schema[1].text},\n            {dim: 2, name: schema[2].text},\n            {dim: 3, name: schema[3].text},\n            {dim: 4, name: schema[4].text},\n            {dim: 5, name: schema[5].text},\n            {dim: 6, name: schema[6].text},\n            {dim: 7, name: schema[7].text,\n                type: 'category',           // 坐标轴也可以支持类别型数据\n                data: ['优', '良', '轻度污染', '中度污染', '重度污染', '严重污染']\n            }\n        ],\n        parallel: {                         // 这是『坐标系』的定义\n            left: '5%',                     // 平行坐标系的位置设置\n            right: '13%',\n            bottom: '10%',\n            top: '20%',\n            parallelAxisDefault: {          // 『坐标轴』的公有属性可以配置在这里避免重复书写\n                type: 'value',\n                nameLocation: 'end',\n                nameGap: 20\n            }\n        },\n        series: [                           // 这里三个系列共用一个平行坐标系\n            {\n                name: '北京',\n                type: 'parallel',           // 这个系列类型是 'parallel'\n                data: [\n                    [1,  55,  9,   56,  0.46,  18,  6,  '良'],\n                    [2,  25,  11,  21,  0.65,  34,  9,  '优'],\n                    ...\n                ]\n            },\n            {\n                name: '上海',\n                type: 'parallel',\n                data: [\n                    [3,  56,  7,   63,  0.3,   14,  5,  '良'],\n                    [4,  33,  7,   29,  0.33,  16,  6,  '优'],\n                    ...\n                ]\n            },\n            {\n                name: '广州',\n                type: 'parallel',\n                data: [\n                    [4,  33,  7,   29,  0.33,  16,  6,  '优'],\n                    [5,  42,  24,  44,  0.76,  40,  16, '优'],\n                    ...\n                ]\n            }\n        ]\n    };\n    \n\n需要涉及到三个组件：[parallel][2]、[parallelAxis][3]、[series-parallel][4]* [parallel][2] 这个配置项是平行坐标系的『坐标系』本身。一个系列（series）或多个系列（如上图中的『北京』、『上海』、『广州』分别各是一个系列）可以共用这个『坐标系』。 和其他坐标系一样，坐标系也可以创建多个。 位置设置，也是放在这里进行。\n* [parallelAxis][3] 这个是『坐标系』中的坐标轴的配置。自然，需要有多个坐标轴。 其中有 [parallelAxis.parallelIndex][5] 属性，指定这个『坐标轴』在哪个『坐标系』中。默认使用第一个『坐标系』。\n* [series-parallel][4] 这个是『系列』的定义。系列被画到『坐标系』上。 其中有 [series-parallel.parallelIndex][6] 属性，指定使用哪个『坐标系』。默认使用第一个『坐标系』。\n\n**配置注意和最佳实践** 配置多个 [parallelAxis][3] 时，有些值一样的属性，如果书写多遍则比较繁琐，那么可以放置在 [parallel.parallelAxisDefault][7] 里。在坐标轴初始化前，[parallel.parallelAxisDefault][7] 里的配置项，会分别融合进 [parallelAxis][3]，形成最终的坐标轴的配置。 **如果数据量很大并且发生卡顿** 建议把 [series-parallel.lineStyle.width][8] 设为 0.5（或更小）， 可能显著改善性能。 **高维数据的显示** 维度比较多时，比如有 50+ 的维度，那么就会有 50+ 个轴。那么可能会页面显示不下。 可以通过 [parallel.axisExpandable][9] 来改善显示效果。\n\n[0]: https://en.wikipedia.org/wiki/Parallel_coordinates\n[1]: #series-parallel.data\n[2]: #parallel\n[3]: #parallelAxis\n[4]: #series-parallel\n[5]: #parallelAxis.parallelIndex\n[6]: #series-parallel.parallelIndex\n[7]: #parallel.parallelAxisDefault\n[8]: #series-parallel.lineStyle.width\n[9]: #parallel.axisExpandable",
        "uiControl": {
            "type": "Object",
            "detailFileName": "parallelAxis"
        }
    },
    "singleAxis": {
        "desc": " 单轴。可以被应用到散点图中展现一维数据，如下示例 ",
        "uiControl": {
            "type": "Object",
            "detailFileName": "singleAxis"
        }
    },
    "timeline": {
        "desc": "timeline 组件，提供了在多个 ECharts option 间进行切换、播放等操作的功能。 示例效果如下： timeline 和其他场景有些不同，它需要操作『多个option』。我们把传入 setOption 第一个参数的东西，称为 ECOption，然后称传统的 ECharts 单个 option 为 ECUnitOption。 \n\n* 当 timeline 和 media query 没有被设置时，一个 ECUnitOption 就是一个 ECOption。\n* 当 timeline 或 media query 被使用设置时，一个 ECOption 由几个 ECUnitOption 组成。\n  * ECOption 的各个根属性，形成一个 ECUnitOption，叫做 baseOption，它代表了各种默认设置。\n  * options 数组每项，形成一个 ECUnitOption，我们为了方便也叫做 switchableOption，它代表了每个时间粒度对应的 option。\n* baseOption 和一个 switchableOption 会用来计算最终的 finalOption，图表就是根据这个最终结果绘制的。\n\n例如： \n\n    // 如下，baseOption 是一个 『原子option』，options 数组\n    // 中的每一项也是一个 『原子option』。\n    // 每个『原子option』中就是本文档中描述的各种配置项。\n    myChart.setOption({\n        // `baseOption` 的属性.\n        timeline: {\n            ...,\n            // `timeline.data` 中的每一项，对应于 `options`\n            // 数组中的每个 `option`\n            data: ['2002-01-01', '2003-01-01', '2004-01-01']\n        },\n        grid: { ... },\n        xAxis: [ ... ],\n        yAxis: [ ... ],\n        series: [{\n            // 系列一的一些其他配置\n            type: 'bar',\n            ...\n        }, {\n            // 系列二的一些其他配置\n            type: 'line',\n            ...\n        }, {\n            // 系列三的一些其他配置\n            type: 'pie',\n            ...\n        }],\n        // `switchableOption`s:\n        options: [{\n            // 这是'2002-01-01' 对应的 option\n            title: {\n                text: '2002年统计值'\n            },\n            series: [\n                { data: [] }, // 系列一的数据\n                { data: [] }, // 系列二的数据\n                { data: [] }  // 系列三的数据\n            ]\n        }, {\n            // 这是'2003-01-01' 对应的 option\n            title: {\n                text: '2003年统计值'\n            },\n            series: [\n                { data: [] },\n                { data: [] },\n                { data: [] }\n            ]\n        }, {\n            // 这是'2004-01-01' 对应的 option\n            title: {\n                text: '2004年统计值'\n            },\n            series: [\n                { data: [] },\n                { data: [] },\n                { data: [] }\n            ]\n        }]\n    });\n    \n\n  \n**finalOption 是怎么计算出来的?** 初始化的时候，对应于当前时间的那个 switchableOption 会被合并（merge）到 baseOption，形成 finalOption。而每当时间变化时，对应于新时间的 switchableOption 会被合并（merge）到finalOption。 有两种合并（merge）策略： \n\n* 默认使用 NORMAL_MERGE。\n* 如果 [timeline.replaceMerge][0] 被指定了，则使用 REPLACE_MERGE。如果要知道 REPLACE_MERGE 更多信息，可以参见 [setOption][1] 中 REPLACE_MERGE 一节。 。\n\n  \n**兼容 ECharts4** 如下这种设置方式，也支持： \n\n    option = {\n        baseOption: {\n            timeline: {},\n            series: [],\n            // ... other properties of baseOption.\n        },\n        options: []\n    };\n    \n\n\n\n[0]: #option.html#timeline.replaceMerge\n[1]: #api.html#echartsInstance.setOption",
        "uiControl": {
            "type": "Object",
            "detailFileName": "timeline"
        }
    },
    "graphic": {
        "desc": "graphic 是原生图形元素组件。可以支持的图形元素包括： [image][0], [text][1], [circle][2], [sector][3], [ring][4], [polygon][5], [polyline][6], [rect][7], [line][8], [bezierCurve][9], [arc][10], [group][11], 下面示例中，使用图形元素做了水印，和文本块： 下面示例中，使用隐藏的图形元素实现了拖拽：   \n- - -\n\n**graphic 设置介绍** 只配一个图形元素时的简写方法： \n\n    myChart.setOption({\n        ...,\n        graphic: {\n            type: 'image',\n            ...\n        }\n    });\n    \n\n配多个图形元素： \n\n    myChart.setOption({\n        ...,\n        graphic: [\n            { // 一个图形元素，类型是 image。\n                type: 'image',\n                ...\n            },\n            { // 一个图形元素，类型是 text，指定了 id。\n                type: 'text',\n                id: 'text1',\n                ...\n            },\n            { // 一个图形元素，类型是 group，可以嵌套子节点。\n                type: 'group',\n                children: [\n                    {\n                        type: 'rect',\n                        id: 'rect1',\n                        ...\n                    },\n                    {\n                        type: 'image',\n                        ...\n                    },\n                    ...\n                ]\n            }\n            ...\n        ]\n    });\n    \n    \n\n使用 setOption 来删除或更换（替代）已有的图形元素： \n\n    myChart.setOption({\n        ...,\n        graphic: [\n            { // 删除上例中定义的 'text1' 元素。\n                id: 'text1',\n                $action: 'remove',\n                ...\n            },\n            { // 将上例中定义的 'rect1' 元素换成 circle。\n              // 注意尽管 'rect1' 在一个 group 中，但这里并不需要顾忌层级，用id指定就可以了。\n                id: 'rect1',\n                $action: 'replace',\n                type: 'circle',\n                ...\n            }\n        ]\n    });\n    \n\n注意，如果没有指定 id，第二次 setOption 时会按照元素在 option 中出现的顺序和已有的图形元素进行匹配。这有时会产生不易理解的效果。 所以，一般来说，更新 elements 时推荐使用 id 进行准确的指定，而非省略 id。   \n- - -\n\n**图形元素设置介绍** 介绍每个图形元素的配置。不同类型的图形元素的设置有这些共性： \n\n    {\n        // id 用于在更新图形元素时指定更新哪个图形元素，如果不需要用可以忽略。\n        id: 'xxx',\n    \n        // 这个字段在第一次设置时不能忽略，取值见上方『支持的图形元素』。\n        type: 'image',\n    \n        // 下面的各个属性如果不需要设置都可以忽略，忽略则取默认值。\n    \n        // 指定本次 setOption 对此图形元素进行的操作。默认是 'merge'，还可以 'replace' 或 'remove'。\n        $action: 'replace',\n    \n        // 这是四个相对于父元素的定位属性，每个属性可取『像素值』或者『百分比』或者 'center'/'middle'。\n        left: 10,\n        // right: 10,\n        top: 'center',\n        // bottom: '10%',\n    \n        shape: {\n            // 定位、形状相关的设置，如 x, y, cx, cy, width, height, r, points 等。\n            // 注意，如果设置了 left/right/top/bottom，这里的定位用的 x/y/cx/cy 会失效。\n        },\n    \n        style: {\n            // 样式相关的设置，如 fill, stroke, lineWidth, shadowBlur 等。\n        },\n    \n        // 表示 z 高度，从而指定了图形元素的覆盖关系。\n        z: 10,\n        // 表示不响应事件。\n        silent: true,\n        // 表示节点不显示\n        invisible: false,\n        // 设置是否整体限制在父节点范围内。可选值：'raw', 'all'。\n        bouding: 'raw',\n        // 是否可以被拖拽。\n        draggable: false,\n        // 事件的监听器，还可以是 onmousemove, ondrag 等。支持的事件参见下。\n        onclick: function () {...}\n    }\n    \n\n  \n- - -\n\n**图形元素的事件** 支持这些事件配置： onclick, onmouseover, onmouseout, onmousemove, onmousewheel, onmousedown, onmouseup, ondrag, ondragstart, ondragend, ondragenter, ondragleave, ondragover, ondrop。   \n- - -\n\n**图形元素的层级关系** 只有 group 元素可以有子节点，从而以该 group 元素为根的元素树可以共同定位（共同移动）。   \n- - -\n\n**图形元素的基本形状设置** 每个图形元素本身有自己的图形基本的位置和尺寸设置，例如： \n\n    {\n        type: 'rect',\n        shape: {\n            x: 10,\n            y: 10,\n            width: 100,\n            height: 200\n        }\n    },\n    {\n        type: 'circle',\n        shape: {\n            cx: 20,\n            cy: 30,\n            r: 100\n        }\n    },\n    {\n        type: 'image',\n        style: {\n            image: 'http://xxx.xxx.xxx/a.png',\n            x: 100,\n            y: 200,\n            width: 230,\n            height: 400\n        }\n    },\n    {\n        type: 'text',\n        style: {\n            text: 'This text',\n            x: 100,\n            y: 200\n        }\n    \n    }\n    \n\n  \n- - -\n\n**图形元素的定位和 transfrom** 除此以外，可以以 transform 的方式对图形进行平移、旋转、缩放， 参见：[position][12]、[rotation][13]、[scale][14]、[origin][15]。 \n\n    {\n        type: 'rect',\n        position: [100, 200], // 平移，默认值为 [0, 0]。\n        scale: [2, 4], // 缩放，默认值为 [1, 1]。表示缩放的倍数。\n        rotation: Math.PI / 4, // 旋转，默认值为 0。表示旋转的弧度值。正值表示逆时针旋转。\n        origin: [10, 20], // 旋转和缩放的中心点，默认值为 [0, 0]。\n        shape: {\n            // ...\n        }\n    }\n    \n\n* 每个图形元素在父节点的坐标系中进行 transform，也就是说父子节点的 transform 能『叠加』。\n* 每个图形元素进行 transform 顺序是：\n  1. 平移 [-el.origin[0], -el.origin[1]]。\n  1. 根据 el.scale 缩放。\n  1. 根据 el.rotation 旋转。\n  1. 根据 el.origin 平移。\n  1. 根据 el.position 平移。\n* 也就是说先缩放旋转后平移，这样平移不会影响缩放旋转的 origin。\n\n  \n- - -\n\n**图形元素相对定位** 以上两者是基本的绝对定位，除此之外，在实际应用中，容器尺寸常常是不确定甚至动态变化的，所以需要提供相对定位的机制。graphic 组件使用 [left][16] / [right][17] / [top][18] / [bottom][19] / [width][20] / [height][21] 提供了相对定位的机制。 例如： \n\n    { // 将图片定位到最下方的中间：\n        type: 'image',\n        left: 'center', // 水平定位到中间\n        bottom: '10%',  // 定位到距离下边界 10% 处\n        style: {\n            image: 'http://xxx.xxx.xxx/a.png',\n            width: 45,\n            height: 45\n        }\n    },\n    { // 将旋转过的 group 整体定位右下角：\n        type: 'group',\n        right: 0,  // 定位到右下角\n        bottom: 0, // 定位到右下角\n        rotation: Math.PI / 4,\n        children: [\n            {\n                type: 'rect',\n                left: 'center', // 相对父元素居中\n                top: 'middle',  // 相对父元素居中\n                shape: {\n                    width: 190,\n                    height: 90\n                },\n                style: {\n                    fill: '#fff',\n                    stroke: '#999',\n                    lineWidth: 2,\n                    shadowBlur: 8,\n                    shadowOffsetX: 3,\n                    shadowOffsetY: 3,\n                    shadowColor: 'rgba(0,0,0,0.3)'\n                }\n            },\n            {\n                type: 'text',\n                left: 'center', // 相对父元素居中\n                top: 'middle',  // 相对父元素居中\n                style: {\n                    fill: '#777',\n                    text: [\n                        'This is text',\n                        '这是一段文字',\n                        'Print some text'\n                    ].join('\\n'),\n                    font: '14px Microsoft YaHei'\n                }\n            }\n        ]\n    }\n    \n\n注意，可以用 [bounding][22] 来设置是否整体限制在父节点范围内。\n\n[0]: #graphic.elements-image\n[1]: #graphic.elements-text\n[2]: #graphic.elements-circle\n[3]: #graphic.elements-sector\n[4]: #graphic.elements-ring\n[5]: #graphic.elements-polygon\n[6]: #graphic.elements-polyline\n[7]: #graphic.elements-rect\n[8]: #graphic.elements-line\n[9]: #graphic.elements-bezierCurve\n[10]: #graphic.elements-arc\n[11]: #graphic.elements-group\n[12]: #graphic.elements.position\n[13]: #graphic.elements.rotation\n[14]: #graphic.elements.scale\n[15]: #graphic.elements.origin\n[16]: #graphic.elements.left\n[17]: #graphic.elements.right\n[18]: #graphic.elements.top\n[19]: #graphic.elements.bottom\n[20]: #graphic.elements.width\n[21]: #graphic.elements.height\n[22]: graphic.elements.bounding",
        "uiControl": {
            "type": "*",
            "detailFileName": "graphic"
        }
    },
    "calendar": {
        "desc": " 日历坐标系组件。 在ECharts中，我们非常有创意地实现了日历图，是通过使用日历坐标系组件来达到日历图效果的，如下方的几个示例图所示，我们可以在热力图、散点图、关系图中使用日历坐标系。 在日历坐标系中使用热力图的示例: 在日历坐标系中使用散点图的示例: 在日历坐标系中使用关系图（以及混合图表）的示例: 灵活利用 echarts 图表和坐标系的组合，以及 API，可以实现更丰富的效果。 [在日历中使用文字][0]、 [在日历中放置饼图][1]- - -\n\n**水平和垂直放置日历** 在日历坐标系可以水平放置，也可以垂直放置。如上面的例子，使用热力图时，经常是水平放置的。但是如果需要格子的尺寸大些，水平放置就过于宽了，于是也可以选择垂直放置。参见 [calendar.orient][2]。 \n\n- - -\n\n**尺寸的自适应** 可以设置日历坐标系使他支持不同尺寸的容器（页面）大小变化的自适应。首先，和 echarts 其他组件一样，日历坐标系可以选择使用 [left][3][right][4][top][5][bottom][6][width][7][height][8] 来描述尺寸和位置，从而将日历摆放在上下左右各种位置，并随着页面尺寸变动而改变自身尺寸。另外，也可以使用 [cellSize][9] 来固定日历格子的长宽。 \n\n- - -\n\n**中西方日历习惯的支持** 中西方日历有所差别，西方常使用星期日作为一周的第一天，中国使用星期一为一周的第一天。日历坐标系做了这种切换的支持。参见 [calendar.dayLabel.firstDay][10]。 另外，日历上的『月份』和『星期几』的文字，也可以较方便的切换中英文，甚至自定义。参见 [calendar.dayLabel.nameMap][11][calendar.monthLabel.nameMap][12]。 \n\n- - -\n\n\n\n[0]: https://echarts.apache.org/examples/zh/editor.html?c=calendar-lunar&amp;edit=1&amp;reset=1\n[1]: https://echarts.apache.org/examples/zh/editor.html?c=calendar-pie&amp;edit=1&amp;reset=1\n[2]: #calendar.orient\n[3]: #calendar.left\n[4]: #calendar.right\n[5]: #calendar.top\n[6]: bottom\n[7]: #calendar.width\n[8]: #calendar.height\n[9]: #calendar.cellSize\n[10]: #calendar.dayLabel.firstDay\n[11]: #calendar.dayLabel.nameMap\n[12]: #calendar.monthLabel.nameMap",
        "uiControl": {
            "type": "Object",
            "detailFileName": "calendar"
        }
    },
    "dataset": {
        "desc": " ECharts 4 开始支持了 数据集（dataset）组件用于单独的数据集声明，从而数据可以单独管理，被多个组件复用，并且可以自由指定数据到视觉的映射。这在不少场景下能带来使用上的方便。 关于 dataset 的详情，请参见[教程][0]。\n\n[0]: https://echarts.apache.org/handbook/zh/concepts/dataset",
        "uiControl": {
            "type": "Object",
            "detailFileName": "dataset"
        }
    },
    "aria": {
        "desc": " W3C 制定了无障碍富互联网应用规范集（[WAI-ARIA][0]，the Accessible Rich Internet Applications Suite），致力于使得网页内容和网页应用能够被更多残障人士访问。Apache ECharts 4 遵从这一规范，支持自动根据图表配置项智能生成描述，使得盲人可以在朗读设备的帮助下了解图表内容，让图表可以被更多人群访问。除此之外，Apache ECharts 5 新增支持贴花纹理，作为颜色的辅助表达，进一步用以区分数据。 默认关闭，需要通过将 [aria.enabled][1] 设置为 true 开启。\n\n[0]: https://www.w3.org/WAI/intro/aria\n[1]: #aria.enabled",
        "uiControl": {
            "type": "*",
            "detailFileName": "aria"
        }
    },
    "series": {
        "desc": "",
        "uiControl": {
            "type": [
                "Array",
                "Object"
            ],
            "detailFileName": "series"
        }
    },
    "darkMode": {
        "desc": " 是否是暗黑模式，默认会根据背景色 [backgroundColor][0] 的亮度自动设置。 如果是设置了容器的背景色而无法判断到，就可以使用该配置手动指定，echarts 会根据是否是暗黑模式调整文本等的颜色。 该配置通常会被用于主题中。\n\n[0]: #backgroundColor",
        "uiControl": {
            "type": "boolean"
        }
    },
    "color": {
        "desc": " 调色盘颜色列表。如果系列没有设置颜色，则会依次循环从该列表中取颜色作为系列颜色。 默认为： \n\n    ['#5470c6', '#91cc75', '#fac858', '#ee6666', '#73c0de', '#3ba272', '#fc8452', '#9a60b4', '#ea7ccc']\n    \n\n支持的颜色格式： \n\n* 使用 RGB 表示纯颜色，比如 'rgb(128, 128, 128)'，如果想要加上 alpha 通道表示不透明度，可以使用 RGBA，比如 'rgba(128, 128, 128, 0.5)'，也可以使用十六进制格式，比如 '#ccc'。\n* 渐变色或者纹理填充 \n\n    // 线性渐变，前四个参数分别是 x0, y0, x2, y2, 范围从 0 - 1，相当于在图形包围盒中的百分比，如果 globalCoord 为 `true`，则该四个值是绝对的像素位置\n    {\n      type: 'linear',\n      x: 0,\n      y: 0,\n      x2: 0,\n      y2: 1,\n      colorStops: [{\n          offset: 0, color: 'red' // 0% 处的颜色\n      }, {\n          offset: 1, color: 'blue' // 100% 处的颜色\n      }],\n      global: false // 缺省为 false\n    }\n    // 径向渐变，前三个参数分别是圆心 x, y 和半径，取值同线性渐变\n    {\n      type: 'radial',\n      x: 0.5,\n      y: 0.5,\n      r: 0.5,\n      colorStops: [{\n          offset: 0, color: 'red' // 0% 处的颜色\n      }, {\n          offset: 1, color: 'blue' // 100% 处的颜色\n      }],\n      global: false // 缺省为 false\n    }\n    // 纹理填充\n    {\n      image: imageDom, // 支持为 HTMLImageElement, HTMLCanvasElement，不支持路径字符串\n      repeat: 'repeat' // 是否平铺，可以是 'repeat-x', 'repeat-y', 'no-repeat'\n    }\n\n",
        "uiControl": {
            "type": "Array"
        }
    },
    "backgroundColor": {
        "desc": " 背景色，默认无背景。 \n\n> 支持使用> rgb(255,255,255)> ，> rgba(255,255,255,1)> ，> #fff> 等方式设置为纯色，也支持设置为渐变色和纹理填充，具体见[> option.color][0]\n\n[0]: #color",
        "uiControl": {
            "type": "color",
            "default": "'transparent'"
        }
    },
    "textStyle": {
        "desc": " 全局的字体样式。 ",
        "uiControl": {
            "type": "Object",
            "detailFileName": "textStyle"
        }
    },
    "animation": {
        "desc": " 是否开启动画。 ",
        "uiControl": {
            "type": "boolean",
            "default": "true",
            "clean": "true"
        }
    },
    "animationThreshold": {
        "desc": " 是否开启动画的阈值，当单个系列显示的图形数量大于这个阈值时会关闭动画。 ",
        "uiControl": {
            "type": "number",
            "default": "2000"
        }
    },
    "animationDuration": {
        "desc": " 初始动画的时长，支持回调函数，可以通过每个数据返回不同的时长实现更戏剧的初始动画效果： \n\n    animationDuration: function (idx) {\n        // 越往后的数据时长越大\n        return idx * 100;\n    }\n    \n\n",
        "uiControl": {
            "type": "number",
            "min": "0",
            "default": "1000",
            "step": "20",
            "clean": "true"
        }
    },
    "animationEasing": {
        "desc": " 初始动画的缓动效果。不同的缓动效果可以参考 [缓动示例][0]。\n\n[0]: https://echarts.apache.org/examples/zh/editor.html?c=line-easing",
        "uiControl": {
            "type": "enum",
            "options": "'linear','quadraticIn','quadraticOut','quadraticInOut','cubicIn','cubicOut','cubicInOut','quarticIn','quarticOut','quarticInOut','quinticIn','quinticOut','quinticInOut','sinusoidalIn','sinusoidalOut','sinusoidalInOut','exponentialIn','exponentialOut','exponentialInOut','circularIn','circularOut','circularInOut','elasticIn','elasticOut','elasticInOut','backIn','backOut','backInOut','bounceIn','bounceOut','bounceInOut'",
            "clean": "true"
        }
    },
    "animationDelay": {
        "desc": " 初始动画的延迟，支持回调函数，可以通过每个数据返回不同的 delay 时间实现更戏剧的初始动画效果。 如下示例： \n\n    animationDelay: function (idx) {\n        // 越往后的数据延迟越大\n        return idx * 100;\n    }\n    \n\n也可以看[该示例][0]\n\n[0]: https://echarts.apache.org/examples/zh/editor.html?c=bar-animation-delay",
        "uiControl": {
            "type": [
                "number",
                "Function"
            ],
            "default": "0"
        }
    },
    "animationDurationUpdate": {
        "desc": " 数据更新动画的时长。 支持回调函数，可以通过每个数据返回不同的时长实现更戏剧的更新动画效果： \n\n    animationDurationUpdate: function (idx) {\n        // 越往后的数据时长越大\n        return idx * 100;\n    }\n    \n\n",
        "uiControl": {
            "type": "number",
            "min": "0",
            "default": "1000",
            "step": "20"
        }
    },
    "animationEasingUpdate": {
        "desc": " 数据更新动画的缓动效果。 ",
        "uiControl": {
            "type": "enum",
            "options": "'linear','quadraticIn','quadraticOut','quadraticInOut','cubicIn','cubicOut','cubicInOut','quarticIn','quarticOut','quarticInOut','quinticIn','quinticOut','quinticInOut','sinusoidalIn','sinusoidalOut','sinusoidalInOut','exponentialIn','exponentialOut','exponentialInOut','circularIn','circularOut','circularInOut','elasticIn','elasticOut','elasticInOut','backIn','backOut','backInOut','bounceIn','bounceOut','bounceInOut'"
        }
    },
    "animationDelayUpdate": {
        "desc": " 数据更新动画的延迟，支持回调函数，可以通过每个数据返回不同的 delay 时间实现更戏剧的更新动画效果。 如下示例： \n\n    animationDelayUpdate: function (idx) {\n        // 越往后的数据延迟越大\n        return idx * 100;\n    }\n    \n\n也可以看[该示例][0]\n\n[0]: https://echarts.apache.org/examples/zh/editor.html?c=bar-animation-delay",
        "uiControl": {
            "type": [
                "number",
                "Function"
            ],
            "default": "0"
        }
    },
    "stateAnimation": {
        "desc": " 状态切换的动画配置，支持在每个系列里设置单独针对该系列的配置。 ",
        "uiControl": {
            "type": "Object",
            "detailFileName": "stateAnimation"
        }
    },
    "blendMode": {
        "desc": " 图形的混合模式，不同的混合模式见 [https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation][0] 。 默认为 'source-over'。 支持每个系列单独设置。 'lighter' 也是比较常见的一种混合模式，该模式下图形数量集中的区域会颜色叠加成高亮度的颜色（白色）。常常能起到突出该区域的效果。见示例 [全球飞行航线][1]\n\n[0]: https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n[1]: https://echarts.apache.org/examples/zh/editor.html?c=lines-airline",
        "uiControl": {
            "type": "string",
            "default": "'source-over'"
        }
    },
    "hoverLayerThreshold": {
        "desc": " 图形数量阈值，决定是否开启单独的 hover 层，在整个图表的图形数量大于该阈值时开启单独的 hover 层。 单独的 hover 层主要是为了在高亮图形的时候不需要重绘整个图表，只需要把高亮的图形放入单独的一个 canvas 层进行绘制，防止在图形数量很多的时候因为高亮重绘所有图形导致卡顿。 ECharts 2 里是底层强制使用单独的层绘制高亮图形，但是会带来很多问题，比如高亮的图形可能会不正确的遮挡所有其它图形，还有图形有透明度因为高亮和正常图形叠加导致不正确的透明度显示，还有移动端上因为每个图表都要多一个 canvas 带来的额外内存开销。因此 3 里默认不会开启该优化，只有在图形数量特别多，有必要做该优化时才会自动开启。 ",
        "uiControl": {
            "type": "number",
            "default": "3000"
        }
    },
    "useUTC": {
        "desc": " 是否使用 UTC 时间。 \n\n* true: 表示 axis.type 为 'time' 时，依据 UTC 时间确定 tick 位置，并且 axisLabel 和 tooltip 默认展示的是 UTC 时间。\n* false: 表示 axis.type 为 'time' 时，依据本地时间确定 tick 位置，并且 axisLabel 和 tooltip 默认展示的是本地时间。\n\n默认取值为false，即使用本地时间。因为考虑到： \n\n* 很多情况下，需要展示为本地时间（无论服务器存储的是否为 UTC 时间）。\n* 如果 data 中的时间为 '2012-01-02' 这样的没有指定时区的时间表达式，往往意为本地时间。默认情况下，时间被展示时需要和输入一致而非有时差。\n\n注意，这个参数实际影响的是『展示』，而非用户输入的时间值的解析。 关于用户输入的时间值（例如 1491339540396, '2013-01-04' 等）的解析，参见 [date 中时间相关部分][0]。\n\n[0]: #series-line.data",
        "uiControl": {
            "type": "boolean",
            "default": "false"
        }
    },
    "options": {
        "desc": " 用于 [timeline][0] 的 option 数组。数组的每一项是一个 echarts option (ECUnitOption)。\n\n[0]: option.html#timeline",
        "uiControl": {
            "type": "Array"
        }
    },
    "media": {
        "desc": " 请参见 [移动端自适应][0]。\n\n[0]: tutorial.html#%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%87%AA%E9%80%82%E5%BA%94",
        "uiControl": {
            "type": "Array",
            "detailFileName": "media"
        }
    }
}