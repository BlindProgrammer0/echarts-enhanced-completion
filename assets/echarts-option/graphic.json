{
    "id": {
        "desc": " 组件 ID。默认不指定。指定则可用于在 option 或者 API 中引用组件。 ",
        "uiControl": {
            "type": "string"
        }
    },
    "elements": {
        "desc": " 里面是所有图形元素的集合。 注意：graphic 的标准写法是： \n\n    {\n        graphic: {\n            elements: [\n                {type: 'rect', ...}, {type: 'circle', ...}, ...\n            ]\n        }\n    }\n    \n\n但是我们常常可以用简写： \n\n    {\n        graphic: {\n            type: 'rect',\n            ...\n        }\n    }\n    \n\n或者： \n\n    {\n        graphic: [\n            {type: 'rect', ...}, {type: 'circle', ...}, ...\n        ]\n    }\n    \n\n",
        "uiControl": {
            "type": "Array"
        }
    },
    "elements-group": {
        "desc": " group 是唯一的可以有子节点的容器。group 可以用来整体定位一组图形元素。 "
    },
    "elements-group.type": {
        "desc": " 用 setOption 首次设定图形元素时必须指定。 可取值： [image][0], [text][1], [circle][2], [sector][3], [ring][4], [polygon][5], [polyline][6], [rect][7], [line][8], [bezierCurve][9], [arc][10], [group][11],\n\n[0]: #graphic.elements-image\n[1]: #graphic.elements-text\n[2]: #graphic.elements-circle\n[3]: #graphic.elements-sector\n[4]: #graphic.elements-ring\n[5]: #graphic.elements-polygon\n[6]: #graphic.elements-polyline\n[7]: #graphic.elements-rect\n[8]: #graphic.elements-line\n[9]: #graphic.elements-bezierCurve\n[10]: #graphic.elements-arc\n[11]: #graphic.elements-group"
    },
    "elements-group.id": {
        "desc": " id 用于在更新或删除图形元素时指定更新哪个图形元素，如果不需要用可以忽略。 "
    },
    "elements-group.$action": {
        "desc": " setOption 时指定本次对该图形元素的操作行为。 可取值： \n\n* 'merge'：如果已有元素，则新的配置项和已有的设定进行 merge。如果没有则新建。\n* 'replace'：如果已有元素，删除之，新建元素替代之。\n* 'remove'：删除元素。\n\n"
    },
    "elements-group.x": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-group.x\n[1]: #graphic.elements-group.y\n[2]: #graphic.elements-group.rotation\n[3]: #graphic.elements-group.scaleX\n[4]: #graphic.elements-group.scaleY\n[5]: #graphic.elements-group.originX\n[6]: #graphic.elements-group.originY\n[7]: #graphic.elements-group"
    },
    "elements-group.y": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-group.x\n[1]: #graphic.elements-group.y\n[2]: #graphic.elements-group.rotation\n[3]: #graphic.elements-group.scaleX\n[4]: #graphic.elements-group.scaleY\n[5]: #graphic.elements-group.originX\n[6]: #graphic.elements-group.originY\n[7]: #graphic.elements-group"
    },
    "elements-group.rotation": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-group.x\n[1]: #graphic.elements-group.y\n[2]: #graphic.elements-group.rotation\n[3]: #graphic.elements-group.scaleX\n[4]: #graphic.elements-group.scaleY\n[5]: #graphic.elements-group.originX\n[6]: #graphic.elements-group.originY\n[7]: #graphic.elements-group"
    },
    "elements-group.scaleX": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-group.x\n[1]: #graphic.elements-group.y\n[2]: #graphic.elements-group.rotation\n[3]: #graphic.elements-group.scaleX\n[4]: #graphic.elements-group.scaleY\n[5]: #graphic.elements-group.originX\n[6]: #graphic.elements-group.originY\n[7]: #graphic.elements-group"
    },
    "elements-group.scaleY": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-group.x\n[1]: #graphic.elements-group.y\n[2]: #graphic.elements-group.rotation\n[3]: #graphic.elements-group.scaleX\n[4]: #graphic.elements-group.scaleY\n[5]: #graphic.elements-group.originX\n[6]: #graphic.elements-group.originY\n[7]: #graphic.elements-group"
    },
    "elements-group.originX": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-group.x\n[1]: #graphic.elements-group.y\n[2]: #graphic.elements-group.rotation\n[3]: #graphic.elements-group.scaleX\n[4]: #graphic.elements-group.scaleY\n[5]: #graphic.elements-group.originX\n[6]: #graphic.elements-group.originY\n[7]: #graphic.elements-group"
    },
    "elements-group.originY": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-group.x\n[1]: #graphic.elements-group.y\n[2]: #graphic.elements-group.rotation\n[3]: #graphic.elements-group.scaleX\n[4]: #graphic.elements-group.scaleY\n[5]: #graphic.elements-group.originX\n[6]: #graphic.elements-group.originY\n[7]: #graphic.elements-group"
    },
    "elements-group.left": {
        "desc": " 描述怎么根据父元素进行定位。 『父元素』是指：如果是顶层元素，父元素是 echarts 图表容器。如果是 group 的子元素，父元素就是 group 元素。 值的类型可以是： \n\n* number：表示像素值。\n* 百分比值：如 '33%'，用父元素的高和此百分比计算出最终值。\n* 'center'：表示自动居中。\n\n[left][0] 和 [right][1] 只有一个可以生效。 如果指定 [left][0] 或 [right][1]，则 [shape][2] 里的 x、cx 等定位属性不再生效。\n\n[0]: #graphic.elements-group.left\n[1]: #graphic.elements-group.right\n[2]: #graphic.elements-group.shape"
    },
    "elements-group.right": {
        "desc": " 描述怎么根据父元素进行定位。 『父元素』是指：如果是顶层元素，父元素是 echarts 图表容器。如果是 group 的子元素，父元素就是 group 元素。 值的类型可以是： \n\n* number：表示像素值。\n* 百分比值：如 '33%'，用父元素的高和此百分比计算出最终值。\n* 'center'：表示自动居中。\n\n[left][0] 和 [right][1] 只有一个可以生效。 如果指定 [left][0] 或 [right][1]，则 [shape][2] 里的 x、cx 等定位属性不再生效。\n\n[0]: #graphic.elements-group.left\n[1]: #graphic.elements-group.right\n[2]: #graphic.elements-group.shape"
    },
    "elements-group.top": {
        "desc": " 描述怎么根据父元素进行定位。 『父元素』是指：如果是顶层元素，父元素是 echarts 图表容器。如果是 group 的子元素，父元素就是 group 元素。 值的类型可以是： \n\n* number：表示像素值。\n* 百分比值：如 '33%'，用父元素的宽和此百分比计算出最终值。\n* 'middle'：表示自动居中。\n\n[top][0] 和 [bottom][1] 只有一个可以生效。 如果指定 [top][0] 或 [bottom][1]，则 [shape][2] 里的 y、cy 等定位属性不再生效。\n\n[0]: #graphic.elements-group.top\n[1]: #graphic.elements-group.bottom\n[2]: #graphic.elements-group.shape"
    },
    "elements-group.bottom": {
        "desc": " 描述怎么根据父元素进行定位。 『父元素』是指：如果是顶层元素，父元素是 echarts 图表容器。如果是 group 的子元素，父元素就是 group 元素。 值的类型可以是： \n\n* number：表示像素值。\n* 百分比值：如 '33%'，用父元素的宽和此百分比计算出最终值。\n* 'middle'：表示自动居中。\n\n[top][0] 和 [bottom][1] 只有一个可以生效。 如果指定 [top][0] 或 [bottom][1]，则 [shape][2] 里的 y、cy 等定位属性不再生效。\n\n[0]: #graphic.elements-group.top\n[1]: #graphic.elements-group.bottom\n[2]: #graphic.elements-group.shape"
    },
    "elements-group.bounding": {
        "desc": " 决定此图形元素在定位时，对自身的包围盒计算方式。 参见例子： 暂时无法显示 可取值： \n\n* 'all'：（默认） 表示用自身以及子节点整体的经过 transform 后的包围盒进行定位。 这种方式易于使整体都限制在父元素范围中。\n* 'raw'： 表示仅仅用自身（不包括子节点）的没经过 tranform 的包围盒进行定位。 这种方式易于内容超出父元素范围的定位方式。\n\n"
    },
    "elements-group.z": {
        "desc": " z 方向的高度，决定层叠关系。 "
    },
    "elements-group.zlevel": {
        "desc": " 决定此元素绘制在哪个 canvas 层中。注意，越多 canvas 层会占用越多资源。 "
    },
    "elements-group.info": {
        "desc": " 用户定义的任意数据，可以在 event listener 中访问，如： \n\n    chart.on('click', function (params) {\n        console.log(params.info);\n    });\n    \n\n"
    },
    "elements-group.silent": {
        "desc": " 是否不响应鼠标以及触摸事件。 "
    },
    "elements-group.invisible": {
        "desc": " 节点是否可见。 "
    },
    "elements-group.ignore": {
        "desc": " 节点是否完全被忽略（既不渲染，也不响应事件）。 "
    },
    "elements-group.textContent": {
        "desc": " 这是一个文本定义，附着在一个节点上，会依据 textConfig 配置，相对于节点布局。 里面的属性同于 [text][0]。\n\n[0]: option.html#graphic.elements-text"
    },
    "elements-group.textConfig": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "elements-group.textConfig.position": {
        "desc": " Position of textContent. \n\n* 'left'\n* 'right'\n* 'top'\n* 'bottom'\n* 'inside'\n* 'insideLeft'\n* 'insideRight'\n* 'insideTop'\n* 'insideBottom'\n* 'insideTopLeft'\n* 'insideTopRight'\n* 'insideBottomLeft'\n* 'insideBottomRight'\n* or like [12, 33]\n* or like ['50%', '50%']\n\n"
    },
    "elements-group.textConfig.rotation": {
        "desc": "textContent 的旋转弧度。 "
    },
    "elements-group.textConfig.layoutRect": {
        "desc": "textContent 根据此矩形来布局位置。 默认是节点的包围盒。 \n\n    {\n        x: number\n        y: number\n        width: number\n        height: number\n    }\n    \n\n"
    },
    "elements-group.textConfig.offset": {
        "desc": "textContent 的偏移。 offset 和 position 的区别是，offset 是旋转（rotation）后计算。 "
    },
    "elements-group.textConfig.origin": {
        "desc": "origin 相对于节点的包围盒。 可以是百分数。 如果指定为 'center'，则定位在包围盒中心。 只有当 position and rotation 都设置时，生效。 \n\n* 如 [12, 33]\n* 或如 ['50%', '50%']\n* 'center'\n\n"
    },
    "elements-group.textConfig.distance": {
        "desc": " 距离 layoutRect 的距离。 "
    },
    "elements-group.textConfig.local": {
        "desc": " 如果 true 的话，会采用节点的 transform。 "
    },
    "elements-group.textConfig.insideFill": {
        "desc": "insideFill 可以是一个颜色字符串，或者空着。 如果 textContent 是 \"inside\"，它的 fill 会按这个优先级来选取： textContent.style.fill > textConfig.insideFill > \"auto-calculated-fill\" 在绝大多数场景下，\"auto-calculated-fill\" 是白色。 "
    },
    "elements-group.textConfig.insideStroke": {
        "desc": "insideStroke 可以是一个颜色字符串，或者空着。 如果 textContent 是 \"inside\"，它的 stroke 会按这个优先级来选取： textContent.style.stroke > textConfig.insideStroke > \"auto-calculated-stroke\" \"auto-calculated-stroke\" 的规则是： \n\n* 如果\n  * (A) fill 在 style 中被指定（无论是在 textContent.style 还是 textContent.style.rich 里）\n  * 或者 (B) 需要画文字的背景（无论是定义在 textContent.style 还是 textContent.style.rich 里）\n  * \"auto-calculated-stroke\" 都会为 null。\n* 否则\n  * \"auto-calculated-stroke\" 会和节点的 fill 相同，如果 fill 没有的话则为 null。\n\n"
    },
    "elements-group.textConfig.outsideFill": {
        "desc": "outsideFill 可以是一个颜色字符串，或者空着。 如果 textContent 是 \"inside\"，它的 fill 会按这个优先级来选取： textContent.style.fill > textConfig.outsideFill > #000 "
    },
    "elements-group.textConfig.outsideStroke": {
        "desc": "outsideStroke 可以是一个颜色字符串，或者空着。 如果 textContent 不是 \"inside\"，它的 stroke 会按这个优先级来选取： textContent.style.stroke > textConfig.outsideStroke > \"auto-calculated-stroke\" \"auto-calculated-stroke\" 的规则是： \n\n* 如果\n  * (A) fill 在 style 中被指定（无论是在 textContent.style 还是 textContent.style.rich 里）\n  * 或者 (B) 需要画文字的背景（无论是定义在 textContent.style 还是 textContent.style.rich 里）\n  * \"auto-calculated-stroke\" 都会为 null。\n* 否则\n  * \"auto-calculated-stroke\" 会为一个近似于白色的颜色，来区别于背景。\n\n"
    },
    "elements-group.textConfig.inside": {
        "desc": " 如果确定文本是在节点中的话，则此可设置为 true，避免 echarts 额外猜测。 "
    },
    "elements-group.cursor": {
        "desc": " 鼠标悬浮时在图形元素上时鼠标的样式是什么。同 CSS 的 cursor。 ",
        "uiControl": {
            "type": "enum",
            "options": "auto,pointer,move",
            "default": "pointer"
        }
    },
    "elements-group.draggable": {
        "desc": " 图形元素是否可以被拖拽。 "
    },
    "elements-group.progressive": {
        "desc": " 是否渐进式渲染。当图形元素过多时才使用。 "
    },
    "elements-group.width": {
        "desc": " 用于描述此 group 的宽。 这个宽只用于给子节点定位。 即便当宽度为零的时候，子节点也可以使用 left: 'center' 相对于父节点水平居中。 "
    },
    "elements-group.height": {
        "desc": " 用于描述此 group 的高。 这个高只用于给子节点定位。 即便当高度为零的时候，子节点也可以使用 top: 'middle' 相对于父节点垂直居中。 "
    },
    "elements-group.diffChildrenByName": {
        "desc": " 在 [自定义系列][0] 中，当 diffChildrenByName: true 时，对于 [renderItem][1] 返回值中的每一个 [group][2]，会根据其 [children][3] 中每个图形元素的 [name][4] 属性进行 \"diff\"。在这里，\"diff\" 的意思是，重绘的时候，在已存在的图形元素和新的图形元素之间建立对应关系（依据 name 是否相同），从如果数据有更新，能够形成的过渡动画。 但是注意，这会有性能开销。如果数据量较大，不要开启这个功能。\n\n[0]: #series-custom\n[1]: #series-custom.renderItem\n[2]: #graphic.elements-group\n[3]: #graphic.elements-group.children\n[4]: #graphic.elements-polygon.name"
    },
    "elements-group.children": {
        "desc": " 子节点列表，其中项都是一个图形元素定义。 "
    },
    "elements-image": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "elements-image.type": {
        "desc": " 用 setOption 首次设定图形元素时必须指定。 可取值： [image][0], [text][1], [circle][2], [sector][3], [ring][4], [polygon][5], [polyline][6], [rect][7], [line][8], [bezierCurve][9], [arc][10], [group][11],\n\n[0]: #graphic.elements-image\n[1]: #graphic.elements-text\n[2]: #graphic.elements-circle\n[3]: #graphic.elements-sector\n[4]: #graphic.elements-ring\n[5]: #graphic.elements-polygon\n[6]: #graphic.elements-polyline\n[7]: #graphic.elements-rect\n[8]: #graphic.elements-line\n[9]: #graphic.elements-bezierCurve\n[10]: #graphic.elements-arc\n[11]: #graphic.elements-group"
    },
    "elements-image.id": {
        "desc": " id 用于在更新或删除图形元素时指定更新哪个图形元素，如果不需要用可以忽略。 "
    },
    "elements-image.$action": {
        "desc": " setOption 时指定本次对该图形元素的操作行为。 可取值： \n\n* 'merge'：如果已有元素，则新的配置项和已有的设定进行 merge。如果没有则新建。\n* 'replace'：如果已有元素，删除之，新建元素替代之。\n* 'remove'：删除元素。\n\n"
    },
    "elements-image.x": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-image.x\n[1]: #graphic.elements-image.y\n[2]: #graphic.elements-image.rotation\n[3]: #graphic.elements-image.scaleX\n[4]: #graphic.elements-image.scaleY\n[5]: #graphic.elements-image.originX\n[6]: #graphic.elements-image.originY\n[7]: #graphic.elements-group"
    },
    "elements-image.y": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-image.x\n[1]: #graphic.elements-image.y\n[2]: #graphic.elements-image.rotation\n[3]: #graphic.elements-image.scaleX\n[4]: #graphic.elements-image.scaleY\n[5]: #graphic.elements-image.originX\n[6]: #graphic.elements-image.originY\n[7]: #graphic.elements-group"
    },
    "elements-image.rotation": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-image.x\n[1]: #graphic.elements-image.y\n[2]: #graphic.elements-image.rotation\n[3]: #graphic.elements-image.scaleX\n[4]: #graphic.elements-image.scaleY\n[5]: #graphic.elements-image.originX\n[6]: #graphic.elements-image.originY\n[7]: #graphic.elements-group"
    },
    "elements-image.scaleX": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-image.x\n[1]: #graphic.elements-image.y\n[2]: #graphic.elements-image.rotation\n[3]: #graphic.elements-image.scaleX\n[4]: #graphic.elements-image.scaleY\n[5]: #graphic.elements-image.originX\n[6]: #graphic.elements-image.originY\n[7]: #graphic.elements-group"
    },
    "elements-image.scaleY": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-image.x\n[1]: #graphic.elements-image.y\n[2]: #graphic.elements-image.rotation\n[3]: #graphic.elements-image.scaleX\n[4]: #graphic.elements-image.scaleY\n[5]: #graphic.elements-image.originX\n[6]: #graphic.elements-image.originY\n[7]: #graphic.elements-group"
    },
    "elements-image.originX": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-image.x\n[1]: #graphic.elements-image.y\n[2]: #graphic.elements-image.rotation\n[3]: #graphic.elements-image.scaleX\n[4]: #graphic.elements-image.scaleY\n[5]: #graphic.elements-image.originX\n[6]: #graphic.elements-image.originY\n[7]: #graphic.elements-group"
    },
    "elements-image.originY": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-image.x\n[1]: #graphic.elements-image.y\n[2]: #graphic.elements-image.rotation\n[3]: #graphic.elements-image.scaleX\n[4]: #graphic.elements-image.scaleY\n[5]: #graphic.elements-image.originX\n[6]: #graphic.elements-image.originY\n[7]: #graphic.elements-group"
    },
    "elements-image.left": {
        "desc": " 描述怎么根据父元素进行定位。 『父元素』是指：如果是顶层元素，父元素是 echarts 图表容器。如果是 group 的子元素，父元素就是 group 元素。 值的类型可以是： \n\n* number：表示像素值。\n* 百分比值：如 '33%'，用父元素的高和此百分比计算出最终值。\n* 'center'：表示自动居中。\n\n[left][0] 和 [right][1] 只有一个可以生效。 如果指定 [left][0] 或 [right][1]，则 [shape][2] 里的 x、cx 等定位属性不再生效。\n\n[0]: #graphic.elements-image.left\n[1]: #graphic.elements-image.right\n[2]: #graphic.elements-image.shape"
    },
    "elements-image.right": {
        "desc": " 描述怎么根据父元素进行定位。 『父元素』是指：如果是顶层元素，父元素是 echarts 图表容器。如果是 group 的子元素，父元素就是 group 元素。 值的类型可以是： \n\n* number：表示像素值。\n* 百分比值：如 '33%'，用父元素的高和此百分比计算出最终值。\n* 'center'：表示自动居中。\n\n[left][0] 和 [right][1] 只有一个可以生效。 如果指定 [left][0] 或 [right][1]，则 [shape][2] 里的 x、cx 等定位属性不再生效。\n\n[0]: #graphic.elements-image.left\n[1]: #graphic.elements-image.right\n[2]: #graphic.elements-image.shape"
    },
    "elements-image.top": {
        "desc": " 描述怎么根据父元素进行定位。 『父元素』是指：如果是顶层元素，父元素是 echarts 图表容器。如果是 group 的子元素，父元素就是 group 元素。 值的类型可以是： \n\n* number：表示像素值。\n* 百分比值：如 '33%'，用父元素的宽和此百分比计算出最终值。\n* 'middle'：表示自动居中。\n\n[top][0] 和 [bottom][1] 只有一个可以生效。 如果指定 [top][0] 或 [bottom][1]，则 [shape][2] 里的 y、cy 等定位属性不再生效。\n\n[0]: #graphic.elements-image.top\n[1]: #graphic.elements-image.bottom\n[2]: #graphic.elements-image.shape"
    },
    "elements-image.bottom": {
        "desc": " 描述怎么根据父元素进行定位。 『父元素』是指：如果是顶层元素，父元素是 echarts 图表容器。如果是 group 的子元素，父元素就是 group 元素。 值的类型可以是： \n\n* number：表示像素值。\n* 百分比值：如 '33%'，用父元素的宽和此百分比计算出最终值。\n* 'middle'：表示自动居中。\n\n[top][0] 和 [bottom][1] 只有一个可以生效。 如果指定 [top][0] 或 [bottom][1]，则 [shape][2] 里的 y、cy 等定位属性不再生效。\n\n[0]: #graphic.elements-image.top\n[1]: #graphic.elements-image.bottom\n[2]: #graphic.elements-image.shape"
    },
    "elements-image.bounding": {
        "desc": " 决定此图形元素在定位时，对自身的包围盒计算方式。 参见例子： 暂时无法显示 可取值： \n\n* 'all'：（默认） 表示用自身以及子节点整体的经过 transform 后的包围盒进行定位。 这种方式易于使整体都限制在父元素范围中。\n* 'raw'： 表示仅仅用自身（不包括子节点）的没经过 tranform 的包围盒进行定位。 这种方式易于内容超出父元素范围的定位方式。\n\n"
    },
    "elements-image.z": {
        "desc": " z 方向的高度，决定层叠关系。 "
    },
    "elements-image.zlevel": {
        "desc": " 决定此元素绘制在哪个 canvas 层中。注意，越多 canvas 层会占用越多资源。 "
    },
    "elements-image.info": {
        "desc": " 用户定义的任意数据，可以在 event listener 中访问，如： \n\n    chart.on('click', function (params) {\n        console.log(params.info);\n    });\n    \n\n"
    },
    "elements-image.silent": {
        "desc": " 是否不响应鼠标以及触摸事件。 "
    },
    "elements-image.invisible": {
        "desc": " 节点是否可见。 "
    },
    "elements-image.ignore": {
        "desc": " 节点是否完全被忽略（既不渲染，也不响应事件）。 "
    },
    "elements-image.textContent": {
        "desc": " 这是一个文本定义，附着在一个节点上，会依据 textConfig 配置，相对于节点布局。 里面的属性同于 [text][0]。\n\n[0]: option.html#graphic.elements-text"
    },
    "elements-image.textConfig": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "elements-image.textConfig.position": {
        "desc": " Position of textContent. \n\n* 'left'\n* 'right'\n* 'top'\n* 'bottom'\n* 'inside'\n* 'insideLeft'\n* 'insideRight'\n* 'insideTop'\n* 'insideBottom'\n* 'insideTopLeft'\n* 'insideTopRight'\n* 'insideBottomLeft'\n* 'insideBottomRight'\n* or like [12, 33]\n* or like ['50%', '50%']\n\n"
    },
    "elements-image.textConfig.rotation": {
        "desc": "textContent 的旋转弧度。 "
    },
    "elements-image.textConfig.layoutRect": {
        "desc": "textContent 根据此矩形来布局位置。 默认是节点的包围盒。 \n\n    {\n        x: number\n        y: number\n        width: number\n        height: number\n    }\n    \n\n"
    },
    "elements-image.textConfig.offset": {
        "desc": "textContent 的偏移。 offset 和 position 的区别是，offset 是旋转（rotation）后计算。 "
    },
    "elements-image.textConfig.origin": {
        "desc": "origin 相对于节点的包围盒。 可以是百分数。 如果指定为 'center'，则定位在包围盒中心。 只有当 position and rotation 都设置时，生效。 \n\n* 如 [12, 33]\n* 或如 ['50%', '50%']\n* 'center'\n\n"
    },
    "elements-image.textConfig.distance": {
        "desc": " 距离 layoutRect 的距离。 "
    },
    "elements-image.textConfig.local": {
        "desc": " 如果 true 的话，会采用节点的 transform。 "
    },
    "elements-image.textConfig.insideFill": {
        "desc": "insideFill 可以是一个颜色字符串，或者空着。 如果 textContent 是 \"inside\"，它的 fill 会按这个优先级来选取： textContent.style.fill > textConfig.insideFill > \"auto-calculated-fill\" 在绝大多数场景下，\"auto-calculated-fill\" 是白色。 "
    },
    "elements-image.textConfig.insideStroke": {
        "desc": "insideStroke 可以是一个颜色字符串，或者空着。 如果 textContent 是 \"inside\"，它的 stroke 会按这个优先级来选取： textContent.style.stroke > textConfig.insideStroke > \"auto-calculated-stroke\" \"auto-calculated-stroke\" 的规则是： \n\n* 如果\n  * (A) fill 在 style 中被指定（无论是在 textContent.style 还是 textContent.style.rich 里）\n  * 或者 (B) 需要画文字的背景（无论是定义在 textContent.style 还是 textContent.style.rich 里）\n  * \"auto-calculated-stroke\" 都会为 null。\n* 否则\n  * \"auto-calculated-stroke\" 会和节点的 fill 相同，如果 fill 没有的话则为 null。\n\n"
    },
    "elements-image.textConfig.outsideFill": {
        "desc": "outsideFill 可以是一个颜色字符串，或者空着。 如果 textContent 是 \"inside\"，它的 fill 会按这个优先级来选取： textContent.style.fill > textConfig.outsideFill > #000 "
    },
    "elements-image.textConfig.outsideStroke": {
        "desc": "outsideStroke 可以是一个颜色字符串，或者空着。 如果 textContent 不是 \"inside\"，它的 stroke 会按这个优先级来选取： textContent.style.stroke > textConfig.outsideStroke > \"auto-calculated-stroke\" \"auto-calculated-stroke\" 的规则是： \n\n* 如果\n  * (A) fill 在 style 中被指定（无论是在 textContent.style 还是 textContent.style.rich 里）\n  * 或者 (B) 需要画文字的背景（无论是定义在 textContent.style 还是 textContent.style.rich 里）\n  * \"auto-calculated-stroke\" 都会为 null。\n* 否则\n  * \"auto-calculated-stroke\" 会为一个近似于白色的颜色，来区别于背景。\n\n"
    },
    "elements-image.textConfig.inside": {
        "desc": " 如果确定文本是在节点中的话，则此可设置为 true，避免 echarts 额外猜测。 "
    },
    "elements-image.cursor": {
        "desc": " 鼠标悬浮时在图形元素上时鼠标的样式是什么。同 CSS 的 cursor。 ",
        "uiControl": {
            "type": "enum",
            "options": "auto,pointer,move",
            "default": "pointer"
        }
    },
    "elements-image.draggable": {
        "desc": " 图形元素是否可以被拖拽。 "
    },
    "elements-image.progressive": {
        "desc": " 是否渐进式渲染。当图形元素过多时才使用。 "
    },
    "elements-image.style": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "elements-image.style.image": {
        "desc": " 图片的内容，可以是图片的 URL，也可以是 [dataURI][0].\n\n[0]: https://tools.ietf.org/html/rfc2397"
    },
    "elements-image.style.x": {
        "desc": " 图形元素的左上角在父节点坐标系（以父节点左上角为原点）中的横坐标值。 "
    },
    "elements-image.style.y": {
        "desc": " 图形元素的左上角在父节点坐标系（以父节点左上角为原点）中的纵坐标值。 "
    },
    "elements-image.style.width": {
        "desc": " 图形元素的宽度。 "
    },
    "elements-image.style.height": {
        "desc": " 图形元素的高度。 注：关于图形元素中更多的样式设置（例如 [富文本标签][0]），参见 [zrender/graphic/Displayable][1] 中的 style 相关属性。 注意，这里图形元素的样式属性名称直接源于 zrender，和 echarts label、echarts itemStyle 等处同样含义的样式属性名称或有不同。例如，有如下对应： \n\n* [itemStyle.color][2] => style.fill\n* [itemStyle.borderColor][2] => style.stroke\n* [label.color][2] => style.textFill\n* [label.textBorderColor][3] => style.textStroke\n* ...\n\n\n\n[0]: tutorial.html#%E5%AF%8C%E6%96%87%E6%9C%AC%E6%A0%87%E7%AD%BE\n[1]: https://ecomfe.github.io/zrender-doc/public/api.html#zrenderdisplayable\n[2]: #series-scatter.label.color\n[3]: #series-scatter.label.textBorderColor"
    },
    "elements-image.style.fill": {
        "desc": " 填充色。 "
    },
    "elements-image.style.stroke": {
        "desc": " 笔画颜色。 "
    },
    "elements-image.style.lineWidth": {
        "desc": " 笔画宽度。 "
    },
    "elements-image.style.shadowBlur": {
        "desc": " 阴影宽度。 "
    },
    "elements-image.style.shadowOffsetX": {
        "desc": " 阴影 X 方向偏移。 "
    },
    "elements-image.style.shadowOffsetY": {
        "desc": " 阴影 Y 方向偏移。 "
    },
    "elements-image.style.shadowColor": {
        "desc": " 阴影颜色。 "
    },
    "elements-image.focus": {
        "desc": ">  从 > v5.0.0>  开始支持 在高亮图形时，是否淡出其它数据的图形已达到聚焦的效果。支持如下配置： \n\n* 'none' 不淡出其它图形，默认使用该配置。\n* 'self' 只聚焦（不淡出）当前高亮的数据的图形。\n* 'series' 聚焦当前高亮的数据所在的系列的所有图形。\n\n"
    },
    "elements-image.blurScope": {
        "desc": ">  从 > v5.0.0>  开始支持 在开启focus的时候，可以通过blurScope配置淡出的范围。支持如下配置 \n\n* 'coordinateSystem' 淡出范围为坐标系，默认使用该配置。\n* 'series' 淡出范围为系列。\n* 'global' 淡出范围为全局。\n\n"
    },
    "elements-text": {
        "desc": " 文本块。 "
    },
    "elements-text.type": {
        "desc": " 用 setOption 首次设定图形元素时必须指定。 可取值： [image][0], [text][1], [circle][2], [sector][3], [ring][4], [polygon][5], [polyline][6], [rect][7], [line][8], [bezierCurve][9], [arc][10], [group][11],\n\n[0]: #graphic.elements-image\n[1]: #graphic.elements-text\n[2]: #graphic.elements-circle\n[3]: #graphic.elements-sector\n[4]: #graphic.elements-ring\n[5]: #graphic.elements-polygon\n[6]: #graphic.elements-polyline\n[7]: #graphic.elements-rect\n[8]: #graphic.elements-line\n[9]: #graphic.elements-bezierCurve\n[10]: #graphic.elements-arc\n[11]: #graphic.elements-group"
    },
    "elements-text.id": {
        "desc": " id 用于在更新或删除图形元素时指定更新哪个图形元素，如果不需要用可以忽略。 "
    },
    "elements-text.$action": {
        "desc": " setOption 时指定本次对该图形元素的操作行为。 可取值： \n\n* 'merge'：如果已有元素，则新的配置项和已有的设定进行 merge。如果没有则新建。\n* 'replace'：如果已有元素，删除之，新建元素替代之。\n* 'remove'：删除元素。\n\n"
    },
    "elements-text.x": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-text.x\n[1]: #graphic.elements-text.y\n[2]: #graphic.elements-text.rotation\n[3]: #graphic.elements-text.scaleX\n[4]: #graphic.elements-text.scaleY\n[5]: #graphic.elements-text.originX\n[6]: #graphic.elements-text.originY\n[7]: #graphic.elements-group"
    },
    "elements-text.y": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-text.x\n[1]: #graphic.elements-text.y\n[2]: #graphic.elements-text.rotation\n[3]: #graphic.elements-text.scaleX\n[4]: #graphic.elements-text.scaleY\n[5]: #graphic.elements-text.originX\n[6]: #graphic.elements-text.originY\n[7]: #graphic.elements-group"
    },
    "elements-text.rotation": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-text.x\n[1]: #graphic.elements-text.y\n[2]: #graphic.elements-text.rotation\n[3]: #graphic.elements-text.scaleX\n[4]: #graphic.elements-text.scaleY\n[5]: #graphic.elements-text.originX\n[6]: #graphic.elements-text.originY\n[7]: #graphic.elements-group"
    },
    "elements-text.scaleX": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-text.x\n[1]: #graphic.elements-text.y\n[2]: #graphic.elements-text.rotation\n[3]: #graphic.elements-text.scaleX\n[4]: #graphic.elements-text.scaleY\n[5]: #graphic.elements-text.originX\n[6]: #graphic.elements-text.originY\n[7]: #graphic.elements-group"
    },
    "elements-text.scaleY": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-text.x\n[1]: #graphic.elements-text.y\n[2]: #graphic.elements-text.rotation\n[3]: #graphic.elements-text.scaleX\n[4]: #graphic.elements-text.scaleY\n[5]: #graphic.elements-text.originX\n[6]: #graphic.elements-text.originY\n[7]: #graphic.elements-group"
    },
    "elements-text.originX": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-text.x\n[1]: #graphic.elements-text.y\n[2]: #graphic.elements-text.rotation\n[3]: #graphic.elements-text.scaleX\n[4]: #graphic.elements-text.scaleY\n[5]: #graphic.elements-text.originX\n[6]: #graphic.elements-text.originY\n[7]: #graphic.elements-group"
    },
    "elements-text.originY": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-text.x\n[1]: #graphic.elements-text.y\n[2]: #graphic.elements-text.rotation\n[3]: #graphic.elements-text.scaleX\n[4]: #graphic.elements-text.scaleY\n[5]: #graphic.elements-text.originX\n[6]: #graphic.elements-text.originY\n[7]: #graphic.elements-group"
    },
    "elements-text.left": {
        "desc": " 描述怎么根据父元素进行定位。 『父元素』是指：如果是顶层元素，父元素是 echarts 图表容器。如果是 group 的子元素，父元素就是 group 元素。 值的类型可以是： \n\n* number：表示像素值。\n* 百分比值：如 '33%'，用父元素的高和此百分比计算出最终值。\n* 'center'：表示自动居中。\n\n[left][0] 和 [right][1] 只有一个可以生效。 如果指定 [left][0] 或 [right][1]，则 [shape][2] 里的 x、cx 等定位属性不再生效。\n\n[0]: #graphic.elements-text.left\n[1]: #graphic.elements-text.right\n[2]: #graphic.elements-text.shape"
    },
    "elements-text.right": {
        "desc": " 描述怎么根据父元素进行定位。 『父元素』是指：如果是顶层元素，父元素是 echarts 图表容器。如果是 group 的子元素，父元素就是 group 元素。 值的类型可以是： \n\n* number：表示像素值。\n* 百分比值：如 '33%'，用父元素的高和此百分比计算出最终值。\n* 'center'：表示自动居中。\n\n[left][0] 和 [right][1] 只有一个可以生效。 如果指定 [left][0] 或 [right][1]，则 [shape][2] 里的 x、cx 等定位属性不再生效。\n\n[0]: #graphic.elements-text.left\n[1]: #graphic.elements-text.right\n[2]: #graphic.elements-text.shape"
    },
    "elements-text.top": {
        "desc": " 描述怎么根据父元素进行定位。 『父元素』是指：如果是顶层元素，父元素是 echarts 图表容器。如果是 group 的子元素，父元素就是 group 元素。 值的类型可以是： \n\n* number：表示像素值。\n* 百分比值：如 '33%'，用父元素的宽和此百分比计算出最终值。\n* 'middle'：表示自动居中。\n\n[top][0] 和 [bottom][1] 只有一个可以生效。 如果指定 [top][0] 或 [bottom][1]，则 [shape][2] 里的 y、cy 等定位属性不再生效。\n\n[0]: #graphic.elements-text.top\n[1]: #graphic.elements-text.bottom\n[2]: #graphic.elements-text.shape"
    },
    "elements-text.bottom": {
        "desc": " 描述怎么根据父元素进行定位。 『父元素』是指：如果是顶层元素，父元素是 echarts 图表容器。如果是 group 的子元素，父元素就是 group 元素。 值的类型可以是： \n\n* number：表示像素值。\n* 百分比值：如 '33%'，用父元素的宽和此百分比计算出最终值。\n* 'middle'：表示自动居中。\n\n[top][0] 和 [bottom][1] 只有一个可以生效。 如果指定 [top][0] 或 [bottom][1]，则 [shape][2] 里的 y、cy 等定位属性不再生效。\n\n[0]: #graphic.elements-text.top\n[1]: #graphic.elements-text.bottom\n[2]: #graphic.elements-text.shape"
    },
    "elements-text.bounding": {
        "desc": " 决定此图形元素在定位时，对自身的包围盒计算方式。 参见例子： 暂时无法显示 可取值： \n\n* 'all'：（默认） 表示用自身以及子节点整体的经过 transform 后的包围盒进行定位。 这种方式易于使整体都限制在父元素范围中。\n* 'raw'： 表示仅仅用自身（不包括子节点）的没经过 tranform 的包围盒进行定位。 这种方式易于内容超出父元素范围的定位方式。\n\n"
    },
    "elements-text.z": {
        "desc": " z 方向的高度，决定层叠关系。 "
    },
    "elements-text.zlevel": {
        "desc": " 决定此元素绘制在哪个 canvas 层中。注意，越多 canvas 层会占用越多资源。 "
    },
    "elements-text.info": {
        "desc": " 用户定义的任意数据，可以在 event listener 中访问，如： \n\n    chart.on('click', function (params) {\n        console.log(params.info);\n    });\n    \n\n"
    },
    "elements-text.silent": {
        "desc": " 是否不响应鼠标以及触摸事件。 "
    },
    "elements-text.invisible": {
        "desc": " 节点是否可见。 "
    },
    "elements-text.ignore": {
        "desc": " 节点是否完全被忽略（既不渲染，也不响应事件）。 "
    },
    "elements-text.textContent": {
        "desc": " 这是一个文本定义，附着在一个节点上，会依据 textConfig 配置，相对于节点布局。 里面的属性同于 [text][0]。\n\n[0]: option.html#graphic.elements-text"
    },
    "elements-text.textConfig": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "elements-text.textConfig.position": {
        "desc": " Position of textContent. \n\n* 'left'\n* 'right'\n* 'top'\n* 'bottom'\n* 'inside'\n* 'insideLeft'\n* 'insideRight'\n* 'insideTop'\n* 'insideBottom'\n* 'insideTopLeft'\n* 'insideTopRight'\n* 'insideBottomLeft'\n* 'insideBottomRight'\n* or like [12, 33]\n* or like ['50%', '50%']\n\n"
    },
    "elements-text.textConfig.rotation": {
        "desc": "textContent 的旋转弧度。 "
    },
    "elements-text.textConfig.layoutRect": {
        "desc": "textContent 根据此矩形来布局位置。 默认是节点的包围盒。 \n\n    {\n        x: number\n        y: number\n        width: number\n        height: number\n    }\n    \n\n"
    },
    "elements-text.textConfig.offset": {
        "desc": "textContent 的偏移。 offset 和 position 的区别是，offset 是旋转（rotation）后计算。 "
    },
    "elements-text.textConfig.origin": {
        "desc": "origin 相对于节点的包围盒。 可以是百分数。 如果指定为 'center'，则定位在包围盒中心。 只有当 position and rotation 都设置时，生效。 \n\n* 如 [12, 33]\n* 或如 ['50%', '50%']\n* 'center'\n\n"
    },
    "elements-text.textConfig.distance": {
        "desc": " 距离 layoutRect 的距离。 "
    },
    "elements-text.textConfig.local": {
        "desc": " 如果 true 的话，会采用节点的 transform。 "
    },
    "elements-text.textConfig.insideFill": {
        "desc": "insideFill 可以是一个颜色字符串，或者空着。 如果 textContent 是 \"inside\"，它的 fill 会按这个优先级来选取： textContent.style.fill > textConfig.insideFill > \"auto-calculated-fill\" 在绝大多数场景下，\"auto-calculated-fill\" 是白色。 "
    },
    "elements-text.textConfig.insideStroke": {
        "desc": "insideStroke 可以是一个颜色字符串，或者空着。 如果 textContent 是 \"inside\"，它的 stroke 会按这个优先级来选取： textContent.style.stroke > textConfig.insideStroke > \"auto-calculated-stroke\" \"auto-calculated-stroke\" 的规则是： \n\n* 如果\n  * (A) fill 在 style 中被指定（无论是在 textContent.style 还是 textContent.style.rich 里）\n  * 或者 (B) 需要画文字的背景（无论是定义在 textContent.style 还是 textContent.style.rich 里）\n  * \"auto-calculated-stroke\" 都会为 null。\n* 否则\n  * \"auto-calculated-stroke\" 会和节点的 fill 相同，如果 fill 没有的话则为 null。\n\n"
    },
    "elements-text.textConfig.outsideFill": {
        "desc": "outsideFill 可以是一个颜色字符串，或者空着。 如果 textContent 是 \"inside\"，它的 fill 会按这个优先级来选取： textContent.style.fill > textConfig.outsideFill > #000 "
    },
    "elements-text.textConfig.outsideStroke": {
        "desc": "outsideStroke 可以是一个颜色字符串，或者空着。 如果 textContent 不是 \"inside\"，它的 stroke 会按这个优先级来选取： textContent.style.stroke > textConfig.outsideStroke > \"auto-calculated-stroke\" \"auto-calculated-stroke\" 的规则是： \n\n* 如果\n  * (A) fill 在 style 中被指定（无论是在 textContent.style 还是 textContent.style.rich 里）\n  * 或者 (B) 需要画文字的背景（无论是定义在 textContent.style 还是 textContent.style.rich 里）\n  * \"auto-calculated-stroke\" 都会为 null。\n* 否则\n  * \"auto-calculated-stroke\" 会为一个近似于白色的颜色，来区别于背景。\n\n"
    },
    "elements-text.textConfig.inside": {
        "desc": " 如果确定文本是在节点中的话，则此可设置为 true，避免 echarts 额外猜测。 "
    },
    "elements-text.cursor": {
        "desc": " 鼠标悬浮时在图形元素上时鼠标的样式是什么。同 CSS 的 cursor。 ",
        "uiControl": {
            "type": "enum",
            "options": "auto,pointer,move",
            "default": "pointer"
        }
    },
    "elements-text.draggable": {
        "desc": " 图形元素是否可以被拖拽。 "
    },
    "elements-text.progressive": {
        "desc": " 是否渐进式渲染。当图形元素过多时才使用。 "
    },
    "elements-text.style": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "elements-text.style.text": {
        "desc": " 文本块文字。可以使用 \\n 来换行。 "
    },
    "elements-text.style.x": {
        "desc": " 图形元素的左上角在父节点坐标系（以父节点左上角为原点）中的横坐标值。 "
    },
    "elements-text.style.y": {
        "desc": " 图形元素的左上角在父节点坐标系（以父节点左上角为原点）中的纵坐标值。 "
    },
    "elements-text.style.font": {
        "desc": " 字体大小、字体类型、粗细、字体样式。格式参见 [css font][0]。 例如： \n\n    // size | family\n    font: '2em \"STHeiti\", sans-serif'\n    \n    // style | weight | size | family\n    font: 'italic bolder 16px cursive'\n    \n    // weight | size | family\n    font: 'bolder 2em \"Microsoft YaHei\", sans-serif'\n    \n\n[0]: https://developer.mozilla.org/en-US/docs/Web/CSS/font"
    },
    "elements-text.style.textAlign": {
        "desc": " 水平对齐方式，取值：'left', 'center', 'right'。 如果为 'left'，表示文本最左端在 x 值上。如果为 'right'，表示文本最右端在 x 值上。 "
    },
    "elements-text.style.textVerticalAlign": {
        "desc": " 垂直对齐方式，取值：'top', 'middle', 'bottom'。 注：关于图形元素中更多的样式设置（例如 [富文本标签][0]），参见 [zrender/graphic/Displayable][1] 中的 style 相关属性。 注意，这里图形元素的样式属性名称直接源于 zrender，和 echarts label、echarts itemStyle 等处同样含义的样式属性名称或有不同。例如，有如下对应： \n\n* [itemStyle.color][2] => style.fill\n* [itemStyle.borderColor][2] => style.stroke\n* [label.color][2] => style.textFill\n* [label.textBorderColor][3] => style.textStroke\n* ...\n\n\n\n[0]: tutorial.html#%E5%AF%8C%E6%96%87%E6%9C%AC%E6%A0%87%E7%AD%BE\n[1]: https://ecomfe.github.io/zrender-doc/public/api.html#zrenderdisplayable\n[2]: #series-scatter.label.color\n[3]: #series-scatter.label.textBorderColor"
    },
    "elements-text.style.fill": {
        "desc": " 填充色。 "
    },
    "elements-text.style.stroke": {
        "desc": " 笔画颜色。 "
    },
    "elements-text.style.lineWidth": {
        "desc": " 笔画宽度。 "
    },
    "elements-text.style.shadowBlur": {
        "desc": " 阴影宽度。 "
    },
    "elements-text.style.shadowOffsetX": {
        "desc": " 阴影 X 方向偏移。 "
    },
    "elements-text.style.shadowOffsetY": {
        "desc": " 阴影 Y 方向偏移。 "
    },
    "elements-text.style.shadowColor": {
        "desc": " 阴影颜色。 "
    },
    "elements-text.focus": {
        "desc": ">  从 > v5.0.0>  开始支持 在高亮图形时，是否淡出其它数据的图形已达到聚焦的效果。支持如下配置： \n\n* 'none' 不淡出其它图形，默认使用该配置。\n* 'self' 只聚焦（不淡出）当前高亮的数据的图形。\n* 'series' 聚焦当前高亮的数据所在的系列的所有图形。\n\n"
    },
    "elements-text.blurScope": {
        "desc": ">  从 > v5.0.0>  开始支持 在开启focus的时候，可以通过blurScope配置淡出的范围。支持如下配置 \n\n* 'coordinateSystem' 淡出范围为坐标系，默认使用该配置。\n* 'series' 淡出范围为系列。\n* 'global' 淡出范围为全局。\n\n"
    },
    "elements-rect": {
        "desc": " 矩形。 "
    },
    "elements-rect.type": {
        "desc": " 用 setOption 首次设定图形元素时必须指定。 可取值： [image][0], [text][1], [circle][2], [sector][3], [ring][4], [polygon][5], [polyline][6], [rect][7], [line][8], [bezierCurve][9], [arc][10], [group][11],\n\n[0]: #graphic.elements-image\n[1]: #graphic.elements-text\n[2]: #graphic.elements-circle\n[3]: #graphic.elements-sector\n[4]: #graphic.elements-ring\n[5]: #graphic.elements-polygon\n[6]: #graphic.elements-polyline\n[7]: #graphic.elements-rect\n[8]: #graphic.elements-line\n[9]: #graphic.elements-bezierCurve\n[10]: #graphic.elements-arc\n[11]: #graphic.elements-group"
    },
    "elements-rect.id": {
        "desc": " id 用于在更新或删除图形元素时指定更新哪个图形元素，如果不需要用可以忽略。 "
    },
    "elements-rect.$action": {
        "desc": " setOption 时指定本次对该图形元素的操作行为。 可取值： \n\n* 'merge'：如果已有元素，则新的配置项和已有的设定进行 merge。如果没有则新建。\n* 'replace'：如果已有元素，删除之，新建元素替代之。\n* 'remove'：删除元素。\n\n"
    },
    "elements-rect.x": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-rect.x\n[1]: #graphic.elements-rect.y\n[2]: #graphic.elements-rect.rotation\n[3]: #graphic.elements-rect.scaleX\n[4]: #graphic.elements-rect.scaleY\n[5]: #graphic.elements-rect.originX\n[6]: #graphic.elements-rect.originY\n[7]: #graphic.elements-group"
    },
    "elements-rect.y": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-rect.x\n[1]: #graphic.elements-rect.y\n[2]: #graphic.elements-rect.rotation\n[3]: #graphic.elements-rect.scaleX\n[4]: #graphic.elements-rect.scaleY\n[5]: #graphic.elements-rect.originX\n[6]: #graphic.elements-rect.originY\n[7]: #graphic.elements-group"
    },
    "elements-rect.rotation": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-rect.x\n[1]: #graphic.elements-rect.y\n[2]: #graphic.elements-rect.rotation\n[3]: #graphic.elements-rect.scaleX\n[4]: #graphic.elements-rect.scaleY\n[5]: #graphic.elements-rect.originX\n[6]: #graphic.elements-rect.originY\n[7]: #graphic.elements-group"
    },
    "elements-rect.scaleX": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-rect.x\n[1]: #graphic.elements-rect.y\n[2]: #graphic.elements-rect.rotation\n[3]: #graphic.elements-rect.scaleX\n[4]: #graphic.elements-rect.scaleY\n[5]: #graphic.elements-rect.originX\n[6]: #graphic.elements-rect.originY\n[7]: #graphic.elements-group"
    },
    "elements-rect.scaleY": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-rect.x\n[1]: #graphic.elements-rect.y\n[2]: #graphic.elements-rect.rotation\n[3]: #graphic.elements-rect.scaleX\n[4]: #graphic.elements-rect.scaleY\n[5]: #graphic.elements-rect.originX\n[6]: #graphic.elements-rect.originY\n[7]: #graphic.elements-group"
    },
    "elements-rect.originX": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-rect.x\n[1]: #graphic.elements-rect.y\n[2]: #graphic.elements-rect.rotation\n[3]: #graphic.elements-rect.scaleX\n[4]: #graphic.elements-rect.scaleY\n[5]: #graphic.elements-rect.originX\n[6]: #graphic.elements-rect.originY\n[7]: #graphic.elements-group"
    },
    "elements-rect.originY": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-rect.x\n[1]: #graphic.elements-rect.y\n[2]: #graphic.elements-rect.rotation\n[3]: #graphic.elements-rect.scaleX\n[4]: #graphic.elements-rect.scaleY\n[5]: #graphic.elements-rect.originX\n[6]: #graphic.elements-rect.originY\n[7]: #graphic.elements-group"
    },
    "elements-rect.left": {
        "desc": " 描述怎么根据父元素进行定位。 『父元素』是指：如果是顶层元素，父元素是 echarts 图表容器。如果是 group 的子元素，父元素就是 group 元素。 值的类型可以是： \n\n* number：表示像素值。\n* 百分比值：如 '33%'，用父元素的高和此百分比计算出最终值。\n* 'center'：表示自动居中。\n\n[left][0] 和 [right][1] 只有一个可以生效。 如果指定 [left][0] 或 [right][1]，则 [shape][2] 里的 x、cx 等定位属性不再生效。\n\n[0]: #graphic.elements-rect.left\n[1]: #graphic.elements-rect.right\n[2]: #graphic.elements-rect.shape"
    },
    "elements-rect.right": {
        "desc": " 描述怎么根据父元素进行定位。 『父元素』是指：如果是顶层元素，父元素是 echarts 图表容器。如果是 group 的子元素，父元素就是 group 元素。 值的类型可以是： \n\n* number：表示像素值。\n* 百分比值：如 '33%'，用父元素的高和此百分比计算出最终值。\n* 'center'：表示自动居中。\n\n[left][0] 和 [right][1] 只有一个可以生效。 如果指定 [left][0] 或 [right][1]，则 [shape][2] 里的 x、cx 等定位属性不再生效。\n\n[0]: #graphic.elements-rect.left\n[1]: #graphic.elements-rect.right\n[2]: #graphic.elements-rect.shape"
    },
    "elements-rect.top": {
        "desc": " 描述怎么根据父元素进行定位。 『父元素』是指：如果是顶层元素，父元素是 echarts 图表容器。如果是 group 的子元素，父元素就是 group 元素。 值的类型可以是： \n\n* number：表示像素值。\n* 百分比值：如 '33%'，用父元素的宽和此百分比计算出最终值。\n* 'middle'：表示自动居中。\n\n[top][0] 和 [bottom][1] 只有一个可以生效。 如果指定 [top][0] 或 [bottom][1]，则 [shape][2] 里的 y、cy 等定位属性不再生效。\n\n[0]: #graphic.elements-rect.top\n[1]: #graphic.elements-rect.bottom\n[2]: #graphic.elements-rect.shape"
    },
    "elements-rect.bottom": {
        "desc": " 描述怎么根据父元素进行定位。 『父元素』是指：如果是顶层元素，父元素是 echarts 图表容器。如果是 group 的子元素，父元素就是 group 元素。 值的类型可以是： \n\n* number：表示像素值。\n* 百分比值：如 '33%'，用父元素的宽和此百分比计算出最终值。\n* 'middle'：表示自动居中。\n\n[top][0] 和 [bottom][1] 只有一个可以生效。 如果指定 [top][0] 或 [bottom][1]，则 [shape][2] 里的 y、cy 等定位属性不再生效。\n\n[0]: #graphic.elements-rect.top\n[1]: #graphic.elements-rect.bottom\n[2]: #graphic.elements-rect.shape"
    },
    "elements-rect.bounding": {
        "desc": " 决定此图形元素在定位时，对自身的包围盒计算方式。 参见例子： 暂时无法显示 可取值： \n\n* 'all'：（默认） 表示用自身以及子节点整体的经过 transform 后的包围盒进行定位。 这种方式易于使整体都限制在父元素范围中。\n* 'raw'： 表示仅仅用自身（不包括子节点）的没经过 tranform 的包围盒进行定位。 这种方式易于内容超出父元素范围的定位方式。\n\n"
    },
    "elements-rect.z": {
        "desc": " z 方向的高度，决定层叠关系。 "
    },
    "elements-rect.zlevel": {
        "desc": " 决定此元素绘制在哪个 canvas 层中。注意，越多 canvas 层会占用越多资源。 "
    },
    "elements-rect.info": {
        "desc": " 用户定义的任意数据，可以在 event listener 中访问，如： \n\n    chart.on('click', function (params) {\n        console.log(params.info);\n    });\n    \n\n"
    },
    "elements-rect.silent": {
        "desc": " 是否不响应鼠标以及触摸事件。 "
    },
    "elements-rect.invisible": {
        "desc": " 节点是否可见。 "
    },
    "elements-rect.ignore": {
        "desc": " 节点是否完全被忽略（既不渲染，也不响应事件）。 "
    },
    "elements-rect.textContent": {
        "desc": " 这是一个文本定义，附着在一个节点上，会依据 textConfig 配置，相对于节点布局。 里面的属性同于 [text][0]。\n\n[0]: option.html#graphic.elements-text"
    },
    "elements-rect.textConfig": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "elements-rect.textConfig.position": {
        "desc": " Position of textContent. \n\n* 'left'\n* 'right'\n* 'top'\n* 'bottom'\n* 'inside'\n* 'insideLeft'\n* 'insideRight'\n* 'insideTop'\n* 'insideBottom'\n* 'insideTopLeft'\n* 'insideTopRight'\n* 'insideBottomLeft'\n* 'insideBottomRight'\n* or like [12, 33]\n* or like ['50%', '50%']\n\n"
    },
    "elements-rect.textConfig.rotation": {
        "desc": "textContent 的旋转弧度。 "
    },
    "elements-rect.textConfig.layoutRect": {
        "desc": "textContent 根据此矩形来布局位置。 默认是节点的包围盒。 \n\n    {\n        x: number\n        y: number\n        width: number\n        height: number\n    }\n    \n\n"
    },
    "elements-rect.textConfig.offset": {
        "desc": "textContent 的偏移。 offset 和 position 的区别是，offset 是旋转（rotation）后计算。 "
    },
    "elements-rect.textConfig.origin": {
        "desc": "origin 相对于节点的包围盒。 可以是百分数。 如果指定为 'center'，则定位在包围盒中心。 只有当 position and rotation 都设置时，生效。 \n\n* 如 [12, 33]\n* 或如 ['50%', '50%']\n* 'center'\n\n"
    },
    "elements-rect.textConfig.distance": {
        "desc": " 距离 layoutRect 的距离。 "
    },
    "elements-rect.textConfig.local": {
        "desc": " 如果 true 的话，会采用节点的 transform。 "
    },
    "elements-rect.textConfig.insideFill": {
        "desc": "insideFill 可以是一个颜色字符串，或者空着。 如果 textContent 是 \"inside\"，它的 fill 会按这个优先级来选取： textContent.style.fill > textConfig.insideFill > \"auto-calculated-fill\" 在绝大多数场景下，\"auto-calculated-fill\" 是白色。 "
    },
    "elements-rect.textConfig.insideStroke": {
        "desc": "insideStroke 可以是一个颜色字符串，或者空着。 如果 textContent 是 \"inside\"，它的 stroke 会按这个优先级来选取： textContent.style.stroke > textConfig.insideStroke > \"auto-calculated-stroke\" \"auto-calculated-stroke\" 的规则是： \n\n* 如果\n  * (A) fill 在 style 中被指定（无论是在 textContent.style 还是 textContent.style.rich 里）\n  * 或者 (B) 需要画文字的背景（无论是定义在 textContent.style 还是 textContent.style.rich 里）\n  * \"auto-calculated-stroke\" 都会为 null。\n* 否则\n  * \"auto-calculated-stroke\" 会和节点的 fill 相同，如果 fill 没有的话则为 null。\n\n"
    },
    "elements-rect.textConfig.outsideFill": {
        "desc": "outsideFill 可以是一个颜色字符串，或者空着。 如果 textContent 是 \"inside\"，它的 fill 会按这个优先级来选取： textContent.style.fill > textConfig.outsideFill > #000 "
    },
    "elements-rect.textConfig.outsideStroke": {
        "desc": "outsideStroke 可以是一个颜色字符串，或者空着。 如果 textContent 不是 \"inside\"，它的 stroke 会按这个优先级来选取： textContent.style.stroke > textConfig.outsideStroke > \"auto-calculated-stroke\" \"auto-calculated-stroke\" 的规则是： \n\n* 如果\n  * (A) fill 在 style 中被指定（无论是在 textContent.style 还是 textContent.style.rich 里）\n  * 或者 (B) 需要画文字的背景（无论是定义在 textContent.style 还是 textContent.style.rich 里）\n  * \"auto-calculated-stroke\" 都会为 null。\n* 否则\n  * \"auto-calculated-stroke\" 会为一个近似于白色的颜色，来区别于背景。\n\n"
    },
    "elements-rect.textConfig.inside": {
        "desc": " 如果确定文本是在节点中的话，则此可设置为 true，避免 echarts 额外猜测。 "
    },
    "elements-rect.cursor": {
        "desc": " 鼠标悬浮时在图形元素上时鼠标的样式是什么。同 CSS 的 cursor。 ",
        "uiControl": {
            "type": "enum",
            "options": "auto,pointer,move",
            "default": "pointer"
        }
    },
    "elements-rect.draggable": {
        "desc": " 图形元素是否可以被拖拽。 "
    },
    "elements-rect.progressive": {
        "desc": " 是否渐进式渲染。当图形元素过多时才使用。 "
    },
    "elements-rect.shape": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "elements-rect.shape.x": {
        "desc": " 图形元素的左上角在父节点坐标系（以父节点左上角为原点）中的横坐标值。 "
    },
    "elements-rect.shape.y": {
        "desc": " 图形元素的左上角在父节点坐标系（以父节点左上角为原点）中的纵坐标值。 "
    },
    "elements-rect.shape.width": {
        "desc": " 图形元素的宽度。 "
    },
    "elements-rect.shape.height": {
        "desc": " 图形元素的高度。 "
    },
    "elements-rect.shape.r": {
        "desc": " 可以用于设置圆角矩形。r: [r1, r2, r3, r4]， 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4。 可以缩写，例如： \n\n* r 缩写为 1 相当于 [1, 1, 1, 1]\n* r 缩写为 [1] 相当于 [1, 1, 1, 1]\n* r 缩写为 [1, 2] 相当于 [1, 2, 1, 2]\n* r 缩写为 [1, 2, 3]1 相当于[1, 2, 3, 2]`\n\n"
    },
    "elements-rect.style": {
        "desc": " 注：关于图形元素中更多的样式设置（例如 [富文本标签][0]），参见 [zrender/graphic/Displayable][1] 中的 style 相关属性。 注意，这里图形元素的样式属性名称直接源于 zrender，和 echarts label、echarts itemStyle 等处同样含义的样式属性名称或有不同。例如，有如下对应： \n\n* [itemStyle.color][2] => style.fill\n* [itemStyle.borderColor][2] => style.stroke\n* [label.color][2] => style.textFill\n* [label.textBorderColor][3] => style.textStroke\n* ...\n\n\n\n[0]: tutorial.html#%E5%AF%8C%E6%96%87%E6%9C%AC%E6%A0%87%E7%AD%BE\n[1]: https://ecomfe.github.io/zrender-doc/public/api.html#zrenderdisplayable\n[2]: #series-scatter.label.color\n[3]: #series-scatter.label.textBorderColor"
    },
    "elements-rect.style.fill": {
        "desc": " 填充色。 "
    },
    "elements-rect.style.stroke": {
        "desc": " 笔画颜色。 "
    },
    "elements-rect.style.lineWidth": {
        "desc": " 笔画宽度。 "
    },
    "elements-rect.style.shadowBlur": {
        "desc": " 阴影宽度。 "
    },
    "elements-rect.style.shadowOffsetX": {
        "desc": " 阴影 X 方向偏移。 "
    },
    "elements-rect.style.shadowOffsetY": {
        "desc": " 阴影 Y 方向偏移。 "
    },
    "elements-rect.style.shadowColor": {
        "desc": " 阴影颜色。 "
    },
    "elements-rect.focus": {
        "desc": ">  从 > v5.0.0>  开始支持 在高亮图形时，是否淡出其它数据的图形已达到聚焦的效果。支持如下配置： \n\n* 'none' 不淡出其它图形，默认使用该配置。\n* 'self' 只聚焦（不淡出）当前高亮的数据的图形。\n* 'series' 聚焦当前高亮的数据所在的系列的所有图形。\n\n"
    },
    "elements-rect.blurScope": {
        "desc": ">  从 > v5.0.0>  开始支持 在开启focus的时候，可以通过blurScope配置淡出的范围。支持如下配置 \n\n* 'coordinateSystem' 淡出范围为坐标系，默认使用该配置。\n* 'series' 淡出范围为系列。\n* 'global' 淡出范围为全局。\n\n"
    },
    "elements-circle": {
        "desc": " 圆。 "
    },
    "elements-circle.type": {
        "desc": " 用 setOption 首次设定图形元素时必须指定。 可取值： [image][0], [text][1], [circle][2], [sector][3], [ring][4], [polygon][5], [polyline][6], [rect][7], [line][8], [bezierCurve][9], [arc][10], [group][11],\n\n[0]: #graphic.elements-image\n[1]: #graphic.elements-text\n[2]: #graphic.elements-circle\n[3]: #graphic.elements-sector\n[4]: #graphic.elements-ring\n[5]: #graphic.elements-polygon\n[6]: #graphic.elements-polyline\n[7]: #graphic.elements-rect\n[8]: #graphic.elements-line\n[9]: #graphic.elements-bezierCurve\n[10]: #graphic.elements-arc\n[11]: #graphic.elements-group"
    },
    "elements-circle.id": {
        "desc": " id 用于在更新或删除图形元素时指定更新哪个图形元素，如果不需要用可以忽略。 "
    },
    "elements-circle.$action": {
        "desc": " setOption 时指定本次对该图形元素的操作行为。 可取值： \n\n* 'merge'：如果已有元素，则新的配置项和已有的设定进行 merge。如果没有则新建。\n* 'replace'：如果已有元素，删除之，新建元素替代之。\n* 'remove'：删除元素。\n\n"
    },
    "elements-circle.x": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-circle.x\n[1]: #graphic.elements-circle.y\n[2]: #graphic.elements-circle.rotation\n[3]: #graphic.elements-circle.scaleX\n[4]: #graphic.elements-circle.scaleY\n[5]: #graphic.elements-circle.originX\n[6]: #graphic.elements-circle.originY\n[7]: #graphic.elements-group"
    },
    "elements-circle.y": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-circle.x\n[1]: #graphic.elements-circle.y\n[2]: #graphic.elements-circle.rotation\n[3]: #graphic.elements-circle.scaleX\n[4]: #graphic.elements-circle.scaleY\n[5]: #graphic.elements-circle.originX\n[6]: #graphic.elements-circle.originY\n[7]: #graphic.elements-group"
    },
    "elements-circle.rotation": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-circle.x\n[1]: #graphic.elements-circle.y\n[2]: #graphic.elements-circle.rotation\n[3]: #graphic.elements-circle.scaleX\n[4]: #graphic.elements-circle.scaleY\n[5]: #graphic.elements-circle.originX\n[6]: #graphic.elements-circle.originY\n[7]: #graphic.elements-group"
    },
    "elements-circle.scaleX": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-circle.x\n[1]: #graphic.elements-circle.y\n[2]: #graphic.elements-circle.rotation\n[3]: #graphic.elements-circle.scaleX\n[4]: #graphic.elements-circle.scaleY\n[5]: #graphic.elements-circle.originX\n[6]: #graphic.elements-circle.originY\n[7]: #graphic.elements-group"
    },
    "elements-circle.scaleY": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-circle.x\n[1]: #graphic.elements-circle.y\n[2]: #graphic.elements-circle.rotation\n[3]: #graphic.elements-circle.scaleX\n[4]: #graphic.elements-circle.scaleY\n[5]: #graphic.elements-circle.originX\n[6]: #graphic.elements-circle.originY\n[7]: #graphic.elements-group"
    },
    "elements-circle.originX": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-circle.x\n[1]: #graphic.elements-circle.y\n[2]: #graphic.elements-circle.rotation\n[3]: #graphic.elements-circle.scaleX\n[4]: #graphic.elements-circle.scaleY\n[5]: #graphic.elements-circle.originX\n[6]: #graphic.elements-circle.originY\n[7]: #graphic.elements-group"
    },
    "elements-circle.originY": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-circle.x\n[1]: #graphic.elements-circle.y\n[2]: #graphic.elements-circle.rotation\n[3]: #graphic.elements-circle.scaleX\n[4]: #graphic.elements-circle.scaleY\n[5]: #graphic.elements-circle.originX\n[6]: #graphic.elements-circle.originY\n[7]: #graphic.elements-group"
    },
    "elements-circle.left": {
        "desc": " 描述怎么根据父元素进行定位。 『父元素』是指：如果是顶层元素，父元素是 echarts 图表容器。如果是 group 的子元素，父元素就是 group 元素。 值的类型可以是： \n\n* number：表示像素值。\n* 百分比值：如 '33%'，用父元素的高和此百分比计算出最终值。\n* 'center'：表示自动居中。\n\n[left][0] 和 [right][1] 只有一个可以生效。 如果指定 [left][0] 或 [right][1]，则 [shape][2] 里的 x、cx 等定位属性不再生效。\n\n[0]: #graphic.elements-circle.left\n[1]: #graphic.elements-circle.right\n[2]: #graphic.elements-circle.shape"
    },
    "elements-circle.right": {
        "desc": " 描述怎么根据父元素进行定位。 『父元素』是指：如果是顶层元素，父元素是 echarts 图表容器。如果是 group 的子元素，父元素就是 group 元素。 值的类型可以是： \n\n* number：表示像素值。\n* 百分比值：如 '33%'，用父元素的高和此百分比计算出最终值。\n* 'center'：表示自动居中。\n\n[left][0] 和 [right][1] 只有一个可以生效。 如果指定 [left][0] 或 [right][1]，则 [shape][2] 里的 x、cx 等定位属性不再生效。\n\n[0]: #graphic.elements-circle.left\n[1]: #graphic.elements-circle.right\n[2]: #graphic.elements-circle.shape"
    },
    "elements-circle.top": {
        "desc": " 描述怎么根据父元素进行定位。 『父元素』是指：如果是顶层元素，父元素是 echarts 图表容器。如果是 group 的子元素，父元素就是 group 元素。 值的类型可以是： \n\n* number：表示像素值。\n* 百分比值：如 '33%'，用父元素的宽和此百分比计算出最终值。\n* 'middle'：表示自动居中。\n\n[top][0] 和 [bottom][1] 只有一个可以生效。 如果指定 [top][0] 或 [bottom][1]，则 [shape][2] 里的 y、cy 等定位属性不再生效。\n\n[0]: #graphic.elements-circle.top\n[1]: #graphic.elements-circle.bottom\n[2]: #graphic.elements-circle.shape"
    },
    "elements-circle.bottom": {
        "desc": " 描述怎么根据父元素进行定位。 『父元素』是指：如果是顶层元素，父元素是 echarts 图表容器。如果是 group 的子元素，父元素就是 group 元素。 值的类型可以是： \n\n* number：表示像素值。\n* 百分比值：如 '33%'，用父元素的宽和此百分比计算出最终值。\n* 'middle'：表示自动居中。\n\n[top][0] 和 [bottom][1] 只有一个可以生效。 如果指定 [top][0] 或 [bottom][1]，则 [shape][2] 里的 y、cy 等定位属性不再生效。\n\n[0]: #graphic.elements-circle.top\n[1]: #graphic.elements-circle.bottom\n[2]: #graphic.elements-circle.shape"
    },
    "elements-circle.bounding": {
        "desc": " 决定此图形元素在定位时，对自身的包围盒计算方式。 参见例子： 暂时无法显示 可取值： \n\n* 'all'：（默认） 表示用自身以及子节点整体的经过 transform 后的包围盒进行定位。 这种方式易于使整体都限制在父元素范围中。\n* 'raw'： 表示仅仅用自身（不包括子节点）的没经过 tranform 的包围盒进行定位。 这种方式易于内容超出父元素范围的定位方式。\n\n"
    },
    "elements-circle.z": {
        "desc": " z 方向的高度，决定层叠关系。 "
    },
    "elements-circle.zlevel": {
        "desc": " 决定此元素绘制在哪个 canvas 层中。注意，越多 canvas 层会占用越多资源。 "
    },
    "elements-circle.info": {
        "desc": " 用户定义的任意数据，可以在 event listener 中访问，如： \n\n    chart.on('click', function (params) {\n        console.log(params.info);\n    });\n    \n\n"
    },
    "elements-circle.silent": {
        "desc": " 是否不响应鼠标以及触摸事件。 "
    },
    "elements-circle.invisible": {
        "desc": " 节点是否可见。 "
    },
    "elements-circle.ignore": {
        "desc": " 节点是否完全被忽略（既不渲染，也不响应事件）。 "
    },
    "elements-circle.textContent": {
        "desc": " 这是一个文本定义，附着在一个节点上，会依据 textConfig 配置，相对于节点布局。 里面的属性同于 [text][0]。\n\n[0]: option.html#graphic.elements-text"
    },
    "elements-circle.textConfig": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "elements-circle.textConfig.position": {
        "desc": " Position of textContent. \n\n* 'left'\n* 'right'\n* 'top'\n* 'bottom'\n* 'inside'\n* 'insideLeft'\n* 'insideRight'\n* 'insideTop'\n* 'insideBottom'\n* 'insideTopLeft'\n* 'insideTopRight'\n* 'insideBottomLeft'\n* 'insideBottomRight'\n* or like [12, 33]\n* or like ['50%', '50%']\n\n"
    },
    "elements-circle.textConfig.rotation": {
        "desc": "textContent 的旋转弧度。 "
    },
    "elements-circle.textConfig.layoutRect": {
        "desc": "textContent 根据此矩形来布局位置。 默认是节点的包围盒。 \n\n    {\n        x: number\n        y: number\n        width: number\n        height: number\n    }\n    \n\n"
    },
    "elements-circle.textConfig.offset": {
        "desc": "textContent 的偏移。 offset 和 position 的区别是，offset 是旋转（rotation）后计算。 "
    },
    "elements-circle.textConfig.origin": {
        "desc": "origin 相对于节点的包围盒。 可以是百分数。 如果指定为 'center'，则定位在包围盒中心。 只有当 position and rotation 都设置时，生效。 \n\n* 如 [12, 33]\n* 或如 ['50%', '50%']\n* 'center'\n\n"
    },
    "elements-circle.textConfig.distance": {
        "desc": " 距离 layoutRect 的距离。 "
    },
    "elements-circle.textConfig.local": {
        "desc": " 如果 true 的话，会采用节点的 transform。 "
    },
    "elements-circle.textConfig.insideFill": {
        "desc": "insideFill 可以是一个颜色字符串，或者空着。 如果 textContent 是 \"inside\"，它的 fill 会按这个优先级来选取： textContent.style.fill > textConfig.insideFill > \"auto-calculated-fill\" 在绝大多数场景下，\"auto-calculated-fill\" 是白色。 "
    },
    "elements-circle.textConfig.insideStroke": {
        "desc": "insideStroke 可以是一个颜色字符串，或者空着。 如果 textContent 是 \"inside\"，它的 stroke 会按这个优先级来选取： textContent.style.stroke > textConfig.insideStroke > \"auto-calculated-stroke\" \"auto-calculated-stroke\" 的规则是： \n\n* 如果\n  * (A) fill 在 style 中被指定（无论是在 textContent.style 还是 textContent.style.rich 里）\n  * 或者 (B) 需要画文字的背景（无论是定义在 textContent.style 还是 textContent.style.rich 里）\n  * \"auto-calculated-stroke\" 都会为 null。\n* 否则\n  * \"auto-calculated-stroke\" 会和节点的 fill 相同，如果 fill 没有的话则为 null。\n\n"
    },
    "elements-circle.textConfig.outsideFill": {
        "desc": "outsideFill 可以是一个颜色字符串，或者空着。 如果 textContent 是 \"inside\"，它的 fill 会按这个优先级来选取： textContent.style.fill > textConfig.outsideFill > #000 "
    },
    "elements-circle.textConfig.outsideStroke": {
        "desc": "outsideStroke 可以是一个颜色字符串，或者空着。 如果 textContent 不是 \"inside\"，它的 stroke 会按这个优先级来选取： textContent.style.stroke > textConfig.outsideStroke > \"auto-calculated-stroke\" \"auto-calculated-stroke\" 的规则是： \n\n* 如果\n  * (A) fill 在 style 中被指定（无论是在 textContent.style 还是 textContent.style.rich 里）\n  * 或者 (B) 需要画文字的背景（无论是定义在 textContent.style 还是 textContent.style.rich 里）\n  * \"auto-calculated-stroke\" 都会为 null。\n* 否则\n  * \"auto-calculated-stroke\" 会为一个近似于白色的颜色，来区别于背景。\n\n"
    },
    "elements-circle.textConfig.inside": {
        "desc": " 如果确定文本是在节点中的话，则此可设置为 true，避免 echarts 额外猜测。 "
    },
    "elements-circle.cursor": {
        "desc": " 鼠标悬浮时在图形元素上时鼠标的样式是什么。同 CSS 的 cursor。 ",
        "uiControl": {
            "type": "enum",
            "options": "auto,pointer,move",
            "default": "pointer"
        }
    },
    "elements-circle.draggable": {
        "desc": " 图形元素是否可以被拖拽。 "
    },
    "elements-circle.progressive": {
        "desc": " 是否渐进式渲染。当图形元素过多时才使用。 "
    },
    "elements-circle.shape": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "elements-circle.shape.cx": {
        "desc": " 图形元素的中心在父节点坐标系（以父节点左上角为原点）中的横坐标值。 "
    },
    "elements-circle.shape.cy": {
        "desc": " 图形元素的中心在父节点坐标系（以父节点左上角为原点）中的纵坐标值。 "
    },
    "elements-circle.shape.r": {
        "desc": " 外半径。 "
    },
    "elements-circle.style": {
        "desc": " 注：关于图形元素中更多的样式设置（例如 [富文本标签][0]），参见 [zrender/graphic/Displayable][1] 中的 style 相关属性。 注意，这里图形元素的样式属性名称直接源于 zrender，和 echarts label、echarts itemStyle 等处同样含义的样式属性名称或有不同。例如，有如下对应： \n\n* [itemStyle.color][2] => style.fill\n* [itemStyle.borderColor][2] => style.stroke\n* [label.color][2] => style.textFill\n* [label.textBorderColor][3] => style.textStroke\n* ...\n\n\n\n[0]: tutorial.html#%E5%AF%8C%E6%96%87%E6%9C%AC%E6%A0%87%E7%AD%BE\n[1]: https://ecomfe.github.io/zrender-doc/public/api.html#zrenderdisplayable\n[2]: #series-scatter.label.color\n[3]: #series-scatter.label.textBorderColor"
    },
    "elements-circle.style.fill": {
        "desc": " 填充色。 "
    },
    "elements-circle.style.stroke": {
        "desc": " 笔画颜色。 "
    },
    "elements-circle.style.lineWidth": {
        "desc": " 笔画宽度。 "
    },
    "elements-circle.style.shadowBlur": {
        "desc": " 阴影宽度。 "
    },
    "elements-circle.style.shadowOffsetX": {
        "desc": " 阴影 X 方向偏移。 "
    },
    "elements-circle.style.shadowOffsetY": {
        "desc": " 阴影 Y 方向偏移。 "
    },
    "elements-circle.style.shadowColor": {
        "desc": " 阴影颜色。 "
    },
    "elements-circle.focus": {
        "desc": ">  从 > v5.0.0>  开始支持 在高亮图形时，是否淡出其它数据的图形已达到聚焦的效果。支持如下配置： \n\n* 'none' 不淡出其它图形，默认使用该配置。\n* 'self' 只聚焦（不淡出）当前高亮的数据的图形。\n* 'series' 聚焦当前高亮的数据所在的系列的所有图形。\n\n"
    },
    "elements-circle.blurScope": {
        "desc": ">  从 > v5.0.0>  开始支持 在开启focus的时候，可以通过blurScope配置淡出的范围。支持如下配置 \n\n* 'coordinateSystem' 淡出范围为坐标系，默认使用该配置。\n* 'series' 淡出范围为系列。\n* 'global' 淡出范围为全局。\n\n"
    },
    "elements-ring": {
        "desc": " 圆环。 "
    },
    "elements-ring.type": {
        "desc": " 用 setOption 首次设定图形元素时必须指定。 可取值： [image][0], [text][1], [circle][2], [sector][3], [ring][4], [polygon][5], [polyline][6], [rect][7], [line][8], [bezierCurve][9], [arc][10], [group][11],\n\n[0]: #graphic.elements-image\n[1]: #graphic.elements-text\n[2]: #graphic.elements-circle\n[3]: #graphic.elements-sector\n[4]: #graphic.elements-ring\n[5]: #graphic.elements-polygon\n[6]: #graphic.elements-polyline\n[7]: #graphic.elements-rect\n[8]: #graphic.elements-line\n[9]: #graphic.elements-bezierCurve\n[10]: #graphic.elements-arc\n[11]: #graphic.elements-group"
    },
    "elements-ring.id": {
        "desc": " id 用于在更新或删除图形元素时指定更新哪个图形元素，如果不需要用可以忽略。 "
    },
    "elements-ring.$action": {
        "desc": " setOption 时指定本次对该图形元素的操作行为。 可取值： \n\n* 'merge'：如果已有元素，则新的配置项和已有的设定进行 merge。如果没有则新建。\n* 'replace'：如果已有元素，删除之，新建元素替代之。\n* 'remove'：删除元素。\n\n"
    },
    "elements-ring.x": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-ring.x\n[1]: #graphic.elements-ring.y\n[2]: #graphic.elements-ring.rotation\n[3]: #graphic.elements-ring.scaleX\n[4]: #graphic.elements-ring.scaleY\n[5]: #graphic.elements-ring.originX\n[6]: #graphic.elements-ring.originY\n[7]: #graphic.elements-group"
    },
    "elements-ring.y": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-ring.x\n[1]: #graphic.elements-ring.y\n[2]: #graphic.elements-ring.rotation\n[3]: #graphic.elements-ring.scaleX\n[4]: #graphic.elements-ring.scaleY\n[5]: #graphic.elements-ring.originX\n[6]: #graphic.elements-ring.originY\n[7]: #graphic.elements-group"
    },
    "elements-ring.rotation": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-ring.x\n[1]: #graphic.elements-ring.y\n[2]: #graphic.elements-ring.rotation\n[3]: #graphic.elements-ring.scaleX\n[4]: #graphic.elements-ring.scaleY\n[5]: #graphic.elements-ring.originX\n[6]: #graphic.elements-ring.originY\n[7]: #graphic.elements-group"
    },
    "elements-ring.scaleX": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-ring.x\n[1]: #graphic.elements-ring.y\n[2]: #graphic.elements-ring.rotation\n[3]: #graphic.elements-ring.scaleX\n[4]: #graphic.elements-ring.scaleY\n[5]: #graphic.elements-ring.originX\n[6]: #graphic.elements-ring.originY\n[7]: #graphic.elements-group"
    },
    "elements-ring.scaleY": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-ring.x\n[1]: #graphic.elements-ring.y\n[2]: #graphic.elements-ring.rotation\n[3]: #graphic.elements-ring.scaleX\n[4]: #graphic.elements-ring.scaleY\n[5]: #graphic.elements-ring.originX\n[6]: #graphic.elements-ring.originY\n[7]: #graphic.elements-group"
    },
    "elements-ring.originX": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-ring.x\n[1]: #graphic.elements-ring.y\n[2]: #graphic.elements-ring.rotation\n[3]: #graphic.elements-ring.scaleX\n[4]: #graphic.elements-ring.scaleY\n[5]: #graphic.elements-ring.originX\n[6]: #graphic.elements-ring.originY\n[7]: #graphic.elements-group"
    },
    "elements-ring.originY": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-ring.x\n[1]: #graphic.elements-ring.y\n[2]: #graphic.elements-ring.rotation\n[3]: #graphic.elements-ring.scaleX\n[4]: #graphic.elements-ring.scaleY\n[5]: #graphic.elements-ring.originX\n[6]: #graphic.elements-ring.originY\n[7]: #graphic.elements-group"
    },
    "elements-ring.left": {
        "desc": " 描述怎么根据父元素进行定位。 『父元素』是指：如果是顶层元素，父元素是 echarts 图表容器。如果是 group 的子元素，父元素就是 group 元素。 值的类型可以是： \n\n* number：表示像素值。\n* 百分比值：如 '33%'，用父元素的高和此百分比计算出最终值。\n* 'center'：表示自动居中。\n\n[left][0] 和 [right][1] 只有一个可以生效。 如果指定 [left][0] 或 [right][1]，则 [shape][2] 里的 x、cx 等定位属性不再生效。\n\n[0]: #graphic.elements-ring.left\n[1]: #graphic.elements-ring.right\n[2]: #graphic.elements-ring.shape"
    },
    "elements-ring.right": {
        "desc": " 描述怎么根据父元素进行定位。 『父元素』是指：如果是顶层元素，父元素是 echarts 图表容器。如果是 group 的子元素，父元素就是 group 元素。 值的类型可以是： \n\n* number：表示像素值。\n* 百分比值：如 '33%'，用父元素的高和此百分比计算出最终值。\n* 'center'：表示自动居中。\n\n[left][0] 和 [right][1] 只有一个可以生效。 如果指定 [left][0] 或 [right][1]，则 [shape][2] 里的 x、cx 等定位属性不再生效。\n\n[0]: #graphic.elements-ring.left\n[1]: #graphic.elements-ring.right\n[2]: #graphic.elements-ring.shape"
    },
    "elements-ring.top": {
        "desc": " 描述怎么根据父元素进行定位。 『父元素』是指：如果是顶层元素，父元素是 echarts 图表容器。如果是 group 的子元素，父元素就是 group 元素。 值的类型可以是： \n\n* number：表示像素值。\n* 百分比值：如 '33%'，用父元素的宽和此百分比计算出最终值。\n* 'middle'：表示自动居中。\n\n[top][0] 和 [bottom][1] 只有一个可以生效。 如果指定 [top][0] 或 [bottom][1]，则 [shape][2] 里的 y、cy 等定位属性不再生效。\n\n[0]: #graphic.elements-ring.top\n[1]: #graphic.elements-ring.bottom\n[2]: #graphic.elements-ring.shape"
    },
    "elements-ring.bottom": {
        "desc": " 描述怎么根据父元素进行定位。 『父元素』是指：如果是顶层元素，父元素是 echarts 图表容器。如果是 group 的子元素，父元素就是 group 元素。 值的类型可以是： \n\n* number：表示像素值。\n* 百分比值：如 '33%'，用父元素的宽和此百分比计算出最终值。\n* 'middle'：表示自动居中。\n\n[top][0] 和 [bottom][1] 只有一个可以生效。 如果指定 [top][0] 或 [bottom][1]，则 [shape][2] 里的 y、cy 等定位属性不再生效。\n\n[0]: #graphic.elements-ring.top\n[1]: #graphic.elements-ring.bottom\n[2]: #graphic.elements-ring.shape"
    },
    "elements-ring.bounding": {
        "desc": " 决定此图形元素在定位时，对自身的包围盒计算方式。 参见例子： 暂时无法显示 可取值： \n\n* 'all'：（默认） 表示用自身以及子节点整体的经过 transform 后的包围盒进行定位。 这种方式易于使整体都限制在父元素范围中。\n* 'raw'： 表示仅仅用自身（不包括子节点）的没经过 tranform 的包围盒进行定位。 这种方式易于内容超出父元素范围的定位方式。\n\n"
    },
    "elements-ring.z": {
        "desc": " z 方向的高度，决定层叠关系。 "
    },
    "elements-ring.zlevel": {
        "desc": " 决定此元素绘制在哪个 canvas 层中。注意，越多 canvas 层会占用越多资源。 "
    },
    "elements-ring.info": {
        "desc": " 用户定义的任意数据，可以在 event listener 中访问，如： \n\n    chart.on('click', function (params) {\n        console.log(params.info);\n    });\n    \n\n"
    },
    "elements-ring.silent": {
        "desc": " 是否不响应鼠标以及触摸事件。 "
    },
    "elements-ring.invisible": {
        "desc": " 节点是否可见。 "
    },
    "elements-ring.ignore": {
        "desc": " 节点是否完全被忽略（既不渲染，也不响应事件）。 "
    },
    "elements-ring.textContent": {
        "desc": " 这是一个文本定义，附着在一个节点上，会依据 textConfig 配置，相对于节点布局。 里面的属性同于 [text][0]。\n\n[0]: option.html#graphic.elements-text"
    },
    "elements-ring.textConfig": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "elements-ring.textConfig.position": {
        "desc": " Position of textContent. \n\n* 'left'\n* 'right'\n* 'top'\n* 'bottom'\n* 'inside'\n* 'insideLeft'\n* 'insideRight'\n* 'insideTop'\n* 'insideBottom'\n* 'insideTopLeft'\n* 'insideTopRight'\n* 'insideBottomLeft'\n* 'insideBottomRight'\n* or like [12, 33]\n* or like ['50%', '50%']\n\n"
    },
    "elements-ring.textConfig.rotation": {
        "desc": "textContent 的旋转弧度。 "
    },
    "elements-ring.textConfig.layoutRect": {
        "desc": "textContent 根据此矩形来布局位置。 默认是节点的包围盒。 \n\n    {\n        x: number\n        y: number\n        width: number\n        height: number\n    }\n    \n\n"
    },
    "elements-ring.textConfig.offset": {
        "desc": "textContent 的偏移。 offset 和 position 的区别是，offset 是旋转（rotation）后计算。 "
    },
    "elements-ring.textConfig.origin": {
        "desc": "origin 相对于节点的包围盒。 可以是百分数。 如果指定为 'center'，则定位在包围盒中心。 只有当 position and rotation 都设置时，生效。 \n\n* 如 [12, 33]\n* 或如 ['50%', '50%']\n* 'center'\n\n"
    },
    "elements-ring.textConfig.distance": {
        "desc": " 距离 layoutRect 的距离。 "
    },
    "elements-ring.textConfig.local": {
        "desc": " 如果 true 的话，会采用节点的 transform。 "
    },
    "elements-ring.textConfig.insideFill": {
        "desc": "insideFill 可以是一个颜色字符串，或者空着。 如果 textContent 是 \"inside\"，它的 fill 会按这个优先级来选取： textContent.style.fill > textConfig.insideFill > \"auto-calculated-fill\" 在绝大多数场景下，\"auto-calculated-fill\" 是白色。 "
    },
    "elements-ring.textConfig.insideStroke": {
        "desc": "insideStroke 可以是一个颜色字符串，或者空着。 如果 textContent 是 \"inside\"，它的 stroke 会按这个优先级来选取： textContent.style.stroke > textConfig.insideStroke > \"auto-calculated-stroke\" \"auto-calculated-stroke\" 的规则是： \n\n* 如果\n  * (A) fill 在 style 中被指定（无论是在 textContent.style 还是 textContent.style.rich 里）\n  * 或者 (B) 需要画文字的背景（无论是定义在 textContent.style 还是 textContent.style.rich 里）\n  * \"auto-calculated-stroke\" 都会为 null。\n* 否则\n  * \"auto-calculated-stroke\" 会和节点的 fill 相同，如果 fill 没有的话则为 null。\n\n"
    },
    "elements-ring.textConfig.outsideFill": {
        "desc": "outsideFill 可以是一个颜色字符串，或者空着。 如果 textContent 是 \"inside\"，它的 fill 会按这个优先级来选取： textContent.style.fill > textConfig.outsideFill > #000 "
    },
    "elements-ring.textConfig.outsideStroke": {
        "desc": "outsideStroke 可以是一个颜色字符串，或者空着。 如果 textContent 不是 \"inside\"，它的 stroke 会按这个优先级来选取： textContent.style.stroke > textConfig.outsideStroke > \"auto-calculated-stroke\" \"auto-calculated-stroke\" 的规则是： \n\n* 如果\n  * (A) fill 在 style 中被指定（无论是在 textContent.style 还是 textContent.style.rich 里）\n  * 或者 (B) 需要画文字的背景（无论是定义在 textContent.style 还是 textContent.style.rich 里）\n  * \"auto-calculated-stroke\" 都会为 null。\n* 否则\n  * \"auto-calculated-stroke\" 会为一个近似于白色的颜色，来区别于背景。\n\n"
    },
    "elements-ring.textConfig.inside": {
        "desc": " 如果确定文本是在节点中的话，则此可设置为 true，避免 echarts 额外猜测。 "
    },
    "elements-ring.cursor": {
        "desc": " 鼠标悬浮时在图形元素上时鼠标的样式是什么。同 CSS 的 cursor。 ",
        "uiControl": {
            "type": "enum",
            "options": "auto,pointer,move",
            "default": "pointer"
        }
    },
    "elements-ring.draggable": {
        "desc": " 图形元素是否可以被拖拽。 "
    },
    "elements-ring.progressive": {
        "desc": " 是否渐进式渲染。当图形元素过多时才使用。 "
    },
    "elements-ring.shape": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "elements-ring.shape.cx": {
        "desc": " 图形元素的中心在父节点坐标系（以父节点左上角为原点）中的横坐标值。 "
    },
    "elements-ring.shape.cy": {
        "desc": " 图形元素的中心在父节点坐标系（以父节点左上角为原点）中的纵坐标值。 "
    },
    "elements-ring.shape.r": {
        "desc": " 外半径。 "
    },
    "elements-ring.shape.r0": {
        "desc": " 内半径。 "
    },
    "elements-ring.style": {
        "desc": " 注：关于图形元素中更多的样式设置（例如 [富文本标签][0]），参见 [zrender/graphic/Displayable][1] 中的 style 相关属性。 注意，这里图形元素的样式属性名称直接源于 zrender，和 echarts label、echarts itemStyle 等处同样含义的样式属性名称或有不同。例如，有如下对应： \n\n* [itemStyle.color][2] => style.fill\n* [itemStyle.borderColor][2] => style.stroke\n* [label.color][2] => style.textFill\n* [label.textBorderColor][3] => style.textStroke\n* ...\n\n\n\n[0]: tutorial.html#%E5%AF%8C%E6%96%87%E6%9C%AC%E6%A0%87%E7%AD%BE\n[1]: https://ecomfe.github.io/zrender-doc/public/api.html#zrenderdisplayable\n[2]: #series-scatter.label.color\n[3]: #series-scatter.label.textBorderColor"
    },
    "elements-ring.style.fill": {
        "desc": " 填充色。 "
    },
    "elements-ring.style.stroke": {
        "desc": " 笔画颜色。 "
    },
    "elements-ring.style.lineWidth": {
        "desc": " 笔画宽度。 "
    },
    "elements-ring.style.shadowBlur": {
        "desc": " 阴影宽度。 "
    },
    "elements-ring.style.shadowOffsetX": {
        "desc": " 阴影 X 方向偏移。 "
    },
    "elements-ring.style.shadowOffsetY": {
        "desc": " 阴影 Y 方向偏移。 "
    },
    "elements-ring.style.shadowColor": {
        "desc": " 阴影颜色。 "
    },
    "elements-ring.focus": {
        "desc": ">  从 > v5.0.0>  开始支持 在高亮图形时，是否淡出其它数据的图形已达到聚焦的效果。支持如下配置： \n\n* 'none' 不淡出其它图形，默认使用该配置。\n* 'self' 只聚焦（不淡出）当前高亮的数据的图形。\n* 'series' 聚焦当前高亮的数据所在的系列的所有图形。\n\n"
    },
    "elements-ring.blurScope": {
        "desc": ">  从 > v5.0.0>  开始支持 在开启focus的时候，可以通过blurScope配置淡出的范围。支持如下配置 \n\n* 'coordinateSystem' 淡出范围为坐标系，默认使用该配置。\n* 'series' 淡出范围为系列。\n* 'global' 淡出范围为全局。\n\n"
    },
    "elements-sector": {
        "desc": " 扇形。 "
    },
    "elements-sector.type": {
        "desc": " 用 setOption 首次设定图形元素时必须指定。 可取值： [image][0], [text][1], [circle][2], [sector][3], [ring][4], [polygon][5], [polyline][6], [rect][7], [line][8], [bezierCurve][9], [arc][10], [group][11],\n\n[0]: #graphic.elements-image\n[1]: #graphic.elements-text\n[2]: #graphic.elements-circle\n[3]: #graphic.elements-sector\n[4]: #graphic.elements-ring\n[5]: #graphic.elements-polygon\n[6]: #graphic.elements-polyline\n[7]: #graphic.elements-rect\n[8]: #graphic.elements-line\n[9]: #graphic.elements-bezierCurve\n[10]: #graphic.elements-arc\n[11]: #graphic.elements-group"
    },
    "elements-sector.id": {
        "desc": " id 用于在更新或删除图形元素时指定更新哪个图形元素，如果不需要用可以忽略。 "
    },
    "elements-sector.$action": {
        "desc": " setOption 时指定本次对该图形元素的操作行为。 可取值： \n\n* 'merge'：如果已有元素，则新的配置项和已有的设定进行 merge。如果没有则新建。\n* 'replace'：如果已有元素，删除之，新建元素替代之。\n* 'remove'：删除元素。\n\n"
    },
    "elements-sector.x": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-sector.x\n[1]: #graphic.elements-sector.y\n[2]: #graphic.elements-sector.rotation\n[3]: #graphic.elements-sector.scaleX\n[4]: #graphic.elements-sector.scaleY\n[5]: #graphic.elements-sector.originX\n[6]: #graphic.elements-sector.originY\n[7]: #graphic.elements-group"
    },
    "elements-sector.y": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-sector.x\n[1]: #graphic.elements-sector.y\n[2]: #graphic.elements-sector.rotation\n[3]: #graphic.elements-sector.scaleX\n[4]: #graphic.elements-sector.scaleY\n[5]: #graphic.elements-sector.originX\n[6]: #graphic.elements-sector.originY\n[7]: #graphic.elements-group"
    },
    "elements-sector.rotation": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-sector.x\n[1]: #graphic.elements-sector.y\n[2]: #graphic.elements-sector.rotation\n[3]: #graphic.elements-sector.scaleX\n[4]: #graphic.elements-sector.scaleY\n[5]: #graphic.elements-sector.originX\n[6]: #graphic.elements-sector.originY\n[7]: #graphic.elements-group"
    },
    "elements-sector.scaleX": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-sector.x\n[1]: #graphic.elements-sector.y\n[2]: #graphic.elements-sector.rotation\n[3]: #graphic.elements-sector.scaleX\n[4]: #graphic.elements-sector.scaleY\n[5]: #graphic.elements-sector.originX\n[6]: #graphic.elements-sector.originY\n[7]: #graphic.elements-group"
    },
    "elements-sector.scaleY": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-sector.x\n[1]: #graphic.elements-sector.y\n[2]: #graphic.elements-sector.rotation\n[3]: #graphic.elements-sector.scaleX\n[4]: #graphic.elements-sector.scaleY\n[5]: #graphic.elements-sector.originX\n[6]: #graphic.elements-sector.originY\n[7]: #graphic.elements-group"
    },
    "elements-sector.originX": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-sector.x\n[1]: #graphic.elements-sector.y\n[2]: #graphic.elements-sector.rotation\n[3]: #graphic.elements-sector.scaleX\n[4]: #graphic.elements-sector.scaleY\n[5]: #graphic.elements-sector.originX\n[6]: #graphic.elements-sector.originY\n[7]: #graphic.elements-group"
    },
    "elements-sector.originY": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-sector.x\n[1]: #graphic.elements-sector.y\n[2]: #graphic.elements-sector.rotation\n[3]: #graphic.elements-sector.scaleX\n[4]: #graphic.elements-sector.scaleY\n[5]: #graphic.elements-sector.originX\n[6]: #graphic.elements-sector.originY\n[7]: #graphic.elements-group"
    },
    "elements-sector.left": {
        "desc": " 描述怎么根据父元素进行定位。 『父元素』是指：如果是顶层元素，父元素是 echarts 图表容器。如果是 group 的子元素，父元素就是 group 元素。 值的类型可以是： \n\n* number：表示像素值。\n* 百分比值：如 '33%'，用父元素的高和此百分比计算出最终值。\n* 'center'：表示自动居中。\n\n[left][0] 和 [right][1] 只有一个可以生效。 如果指定 [left][0] 或 [right][1]，则 [shape][2] 里的 x、cx 等定位属性不再生效。\n\n[0]: #graphic.elements-sector.left\n[1]: #graphic.elements-sector.right\n[2]: #graphic.elements-sector.shape"
    },
    "elements-sector.right": {
        "desc": " 描述怎么根据父元素进行定位。 『父元素』是指：如果是顶层元素，父元素是 echarts 图表容器。如果是 group 的子元素，父元素就是 group 元素。 值的类型可以是： \n\n* number：表示像素值。\n* 百分比值：如 '33%'，用父元素的高和此百分比计算出最终值。\n* 'center'：表示自动居中。\n\n[left][0] 和 [right][1] 只有一个可以生效。 如果指定 [left][0] 或 [right][1]，则 [shape][2] 里的 x、cx 等定位属性不再生效。\n\n[0]: #graphic.elements-sector.left\n[1]: #graphic.elements-sector.right\n[2]: #graphic.elements-sector.shape"
    },
    "elements-sector.top": {
        "desc": " 描述怎么根据父元素进行定位。 『父元素』是指：如果是顶层元素，父元素是 echarts 图表容器。如果是 group 的子元素，父元素就是 group 元素。 值的类型可以是： \n\n* number：表示像素值。\n* 百分比值：如 '33%'，用父元素的宽和此百分比计算出最终值。\n* 'middle'：表示自动居中。\n\n[top][0] 和 [bottom][1] 只有一个可以生效。 如果指定 [top][0] 或 [bottom][1]，则 [shape][2] 里的 y、cy 等定位属性不再生效。\n\n[0]: #graphic.elements-sector.top\n[1]: #graphic.elements-sector.bottom\n[2]: #graphic.elements-sector.shape"
    },
    "elements-sector.bottom": {
        "desc": " 描述怎么根据父元素进行定位。 『父元素』是指：如果是顶层元素，父元素是 echarts 图表容器。如果是 group 的子元素，父元素就是 group 元素。 值的类型可以是： \n\n* number：表示像素值。\n* 百分比值：如 '33%'，用父元素的宽和此百分比计算出最终值。\n* 'middle'：表示自动居中。\n\n[top][0] 和 [bottom][1] 只有一个可以生效。 如果指定 [top][0] 或 [bottom][1]，则 [shape][2] 里的 y、cy 等定位属性不再生效。\n\n[0]: #graphic.elements-sector.top\n[1]: #graphic.elements-sector.bottom\n[2]: #graphic.elements-sector.shape"
    },
    "elements-sector.bounding": {
        "desc": " 决定此图形元素在定位时，对自身的包围盒计算方式。 参见例子： 暂时无法显示 可取值： \n\n* 'all'：（默认） 表示用自身以及子节点整体的经过 transform 后的包围盒进行定位。 这种方式易于使整体都限制在父元素范围中。\n* 'raw'： 表示仅仅用自身（不包括子节点）的没经过 tranform 的包围盒进行定位。 这种方式易于内容超出父元素范围的定位方式。\n\n"
    },
    "elements-sector.z": {
        "desc": " z 方向的高度，决定层叠关系。 "
    },
    "elements-sector.zlevel": {
        "desc": " 决定此元素绘制在哪个 canvas 层中。注意，越多 canvas 层会占用越多资源。 "
    },
    "elements-sector.info": {
        "desc": " 用户定义的任意数据，可以在 event listener 中访问，如： \n\n    chart.on('click', function (params) {\n        console.log(params.info);\n    });\n    \n\n"
    },
    "elements-sector.silent": {
        "desc": " 是否不响应鼠标以及触摸事件。 "
    },
    "elements-sector.invisible": {
        "desc": " 节点是否可见。 "
    },
    "elements-sector.ignore": {
        "desc": " 节点是否完全被忽略（既不渲染，也不响应事件）。 "
    },
    "elements-sector.textContent": {
        "desc": " 这是一个文本定义，附着在一个节点上，会依据 textConfig 配置，相对于节点布局。 里面的属性同于 [text][0]。\n\n[0]: option.html#graphic.elements-text"
    },
    "elements-sector.textConfig": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "elements-sector.textConfig.position": {
        "desc": " Position of textContent. \n\n* 'left'\n* 'right'\n* 'top'\n* 'bottom'\n* 'inside'\n* 'insideLeft'\n* 'insideRight'\n* 'insideTop'\n* 'insideBottom'\n* 'insideTopLeft'\n* 'insideTopRight'\n* 'insideBottomLeft'\n* 'insideBottomRight'\n* or like [12, 33]\n* or like ['50%', '50%']\n\n"
    },
    "elements-sector.textConfig.rotation": {
        "desc": "textContent 的旋转弧度。 "
    },
    "elements-sector.textConfig.layoutRect": {
        "desc": "textContent 根据此矩形来布局位置。 默认是节点的包围盒。 \n\n    {\n        x: number\n        y: number\n        width: number\n        height: number\n    }\n    \n\n"
    },
    "elements-sector.textConfig.offset": {
        "desc": "textContent 的偏移。 offset 和 position 的区别是，offset 是旋转（rotation）后计算。 "
    },
    "elements-sector.textConfig.origin": {
        "desc": "origin 相对于节点的包围盒。 可以是百分数。 如果指定为 'center'，则定位在包围盒中心。 只有当 position and rotation 都设置时，生效。 \n\n* 如 [12, 33]\n* 或如 ['50%', '50%']\n* 'center'\n\n"
    },
    "elements-sector.textConfig.distance": {
        "desc": " 距离 layoutRect 的距离。 "
    },
    "elements-sector.textConfig.local": {
        "desc": " 如果 true 的话，会采用节点的 transform。 "
    },
    "elements-sector.textConfig.insideFill": {
        "desc": "insideFill 可以是一个颜色字符串，或者空着。 如果 textContent 是 \"inside\"，它的 fill 会按这个优先级来选取： textContent.style.fill > textConfig.insideFill > \"auto-calculated-fill\" 在绝大多数场景下，\"auto-calculated-fill\" 是白色。 "
    },
    "elements-sector.textConfig.insideStroke": {
        "desc": "insideStroke 可以是一个颜色字符串，或者空着。 如果 textContent 是 \"inside\"，它的 stroke 会按这个优先级来选取： textContent.style.stroke > textConfig.insideStroke > \"auto-calculated-stroke\" \"auto-calculated-stroke\" 的规则是： \n\n* 如果\n  * (A) fill 在 style 中被指定（无论是在 textContent.style 还是 textContent.style.rich 里）\n  * 或者 (B) 需要画文字的背景（无论是定义在 textContent.style 还是 textContent.style.rich 里）\n  * \"auto-calculated-stroke\" 都会为 null。\n* 否则\n  * \"auto-calculated-stroke\" 会和节点的 fill 相同，如果 fill 没有的话则为 null。\n\n"
    },
    "elements-sector.textConfig.outsideFill": {
        "desc": "outsideFill 可以是一个颜色字符串，或者空着。 如果 textContent 是 \"inside\"，它的 fill 会按这个优先级来选取： textContent.style.fill > textConfig.outsideFill > #000 "
    },
    "elements-sector.textConfig.outsideStroke": {
        "desc": "outsideStroke 可以是一个颜色字符串，或者空着。 如果 textContent 不是 \"inside\"，它的 stroke 会按这个优先级来选取： textContent.style.stroke > textConfig.outsideStroke > \"auto-calculated-stroke\" \"auto-calculated-stroke\" 的规则是： \n\n* 如果\n  * (A) fill 在 style 中被指定（无论是在 textContent.style 还是 textContent.style.rich 里）\n  * 或者 (B) 需要画文字的背景（无论是定义在 textContent.style 还是 textContent.style.rich 里）\n  * \"auto-calculated-stroke\" 都会为 null。\n* 否则\n  * \"auto-calculated-stroke\" 会为一个近似于白色的颜色，来区别于背景。\n\n"
    },
    "elements-sector.textConfig.inside": {
        "desc": " 如果确定文本是在节点中的话，则此可设置为 true，避免 echarts 额外猜测。 "
    },
    "elements-sector.cursor": {
        "desc": " 鼠标悬浮时在图形元素上时鼠标的样式是什么。同 CSS 的 cursor。 ",
        "uiControl": {
            "type": "enum",
            "options": "auto,pointer,move",
            "default": "pointer"
        }
    },
    "elements-sector.draggable": {
        "desc": " 图形元素是否可以被拖拽。 "
    },
    "elements-sector.progressive": {
        "desc": " 是否渐进式渲染。当图形元素过多时才使用。 "
    },
    "elements-sector.shape": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "elements-sector.shape.cx": {
        "desc": " 图形元素的中心在父节点坐标系（以父节点左上角为原点）中的横坐标值。 "
    },
    "elements-sector.shape.cy": {
        "desc": " 图形元素的中心在父节点坐标系（以父节点左上角为原点）中的纵坐标值。 "
    },
    "elements-sector.shape.r": {
        "desc": " 外半径。 "
    },
    "elements-sector.shape.r0": {
        "desc": " 内半径。 "
    },
    "elements-sector.shape.startAngle": {
        "desc": " 开始弧度。 "
    },
    "elements-sector.shape.endAngle": {
        "desc": " 结束弧度。 "
    },
    "elements-sector.shape.clockwise": {
        "desc": " 是否顺时针。 "
    },
    "elements-sector.style": {
        "desc": " 注：关于图形元素中更多的样式设置（例如 [富文本标签][0]），参见 [zrender/graphic/Displayable][1] 中的 style 相关属性。 注意，这里图形元素的样式属性名称直接源于 zrender，和 echarts label、echarts itemStyle 等处同样含义的样式属性名称或有不同。例如，有如下对应： \n\n* [itemStyle.color][2] => style.fill\n* [itemStyle.borderColor][2] => style.stroke\n* [label.color][2] => style.textFill\n* [label.textBorderColor][3] => style.textStroke\n* ...\n\n\n\n[0]: tutorial.html#%E5%AF%8C%E6%96%87%E6%9C%AC%E6%A0%87%E7%AD%BE\n[1]: https://ecomfe.github.io/zrender-doc/public/api.html#zrenderdisplayable\n[2]: #series-scatter.label.color\n[3]: #series-scatter.label.textBorderColor"
    },
    "elements-sector.style.fill": {
        "desc": " 填充色。 "
    },
    "elements-sector.style.stroke": {
        "desc": " 笔画颜色。 "
    },
    "elements-sector.style.lineWidth": {
        "desc": " 笔画宽度。 "
    },
    "elements-sector.style.shadowBlur": {
        "desc": " 阴影宽度。 "
    },
    "elements-sector.style.shadowOffsetX": {
        "desc": " 阴影 X 方向偏移。 "
    },
    "elements-sector.style.shadowOffsetY": {
        "desc": " 阴影 Y 方向偏移。 "
    },
    "elements-sector.style.shadowColor": {
        "desc": " 阴影颜色。 "
    },
    "elements-sector.focus": {
        "desc": ">  从 > v5.0.0>  开始支持 在高亮图形时，是否淡出其它数据的图形已达到聚焦的效果。支持如下配置： \n\n* 'none' 不淡出其它图形，默认使用该配置。\n* 'self' 只聚焦（不淡出）当前高亮的数据的图形。\n* 'series' 聚焦当前高亮的数据所在的系列的所有图形。\n\n"
    },
    "elements-sector.blurScope": {
        "desc": ">  从 > v5.0.0>  开始支持 在开启focus的时候，可以通过blurScope配置淡出的范围。支持如下配置 \n\n* 'coordinateSystem' 淡出范围为坐标系，默认使用该配置。\n* 'series' 淡出范围为系列。\n* 'global' 淡出范围为全局。\n\n"
    },
    "elements-arc": {
        "desc": " 圆弧。 "
    },
    "elements-arc.type": {
        "desc": " 用 setOption 首次设定图形元素时必须指定。 可取值： [image][0], [text][1], [circle][2], [sector][3], [ring][4], [polygon][5], [polyline][6], [rect][7], [line][8], [bezierCurve][9], [arc][10], [group][11],\n\n[0]: #graphic.elements-image\n[1]: #graphic.elements-text\n[2]: #graphic.elements-circle\n[3]: #graphic.elements-sector\n[4]: #graphic.elements-ring\n[5]: #graphic.elements-polygon\n[6]: #graphic.elements-polyline\n[7]: #graphic.elements-rect\n[8]: #graphic.elements-line\n[9]: #graphic.elements-bezierCurve\n[10]: #graphic.elements-arc\n[11]: #graphic.elements-group"
    },
    "elements-arc.id": {
        "desc": " id 用于在更新或删除图形元素时指定更新哪个图形元素，如果不需要用可以忽略。 "
    },
    "elements-arc.$action": {
        "desc": " setOption 时指定本次对该图形元素的操作行为。 可取值： \n\n* 'merge'：如果已有元素，则新的配置项和已有的设定进行 merge。如果没有则新建。\n* 'replace'：如果已有元素，删除之，新建元素替代之。\n* 'remove'：删除元素。\n\n"
    },
    "elements-arc.x": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-arc.x\n[1]: #graphic.elements-arc.y\n[2]: #graphic.elements-arc.rotation\n[3]: #graphic.elements-arc.scaleX\n[4]: #graphic.elements-arc.scaleY\n[5]: #graphic.elements-arc.originX\n[6]: #graphic.elements-arc.originY\n[7]: #graphic.elements-group"
    },
    "elements-arc.y": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-arc.x\n[1]: #graphic.elements-arc.y\n[2]: #graphic.elements-arc.rotation\n[3]: #graphic.elements-arc.scaleX\n[4]: #graphic.elements-arc.scaleY\n[5]: #graphic.elements-arc.originX\n[6]: #graphic.elements-arc.originY\n[7]: #graphic.elements-group"
    },
    "elements-arc.rotation": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-arc.x\n[1]: #graphic.elements-arc.y\n[2]: #graphic.elements-arc.rotation\n[3]: #graphic.elements-arc.scaleX\n[4]: #graphic.elements-arc.scaleY\n[5]: #graphic.elements-arc.originX\n[6]: #graphic.elements-arc.originY\n[7]: #graphic.elements-group"
    },
    "elements-arc.scaleX": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-arc.x\n[1]: #graphic.elements-arc.y\n[2]: #graphic.elements-arc.rotation\n[3]: #graphic.elements-arc.scaleX\n[4]: #graphic.elements-arc.scaleY\n[5]: #graphic.elements-arc.originX\n[6]: #graphic.elements-arc.originY\n[7]: #graphic.elements-group"
    },
    "elements-arc.scaleY": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-arc.x\n[1]: #graphic.elements-arc.y\n[2]: #graphic.elements-arc.rotation\n[3]: #graphic.elements-arc.scaleX\n[4]: #graphic.elements-arc.scaleY\n[5]: #graphic.elements-arc.originX\n[6]: #graphic.elements-arc.originY\n[7]: #graphic.elements-group"
    },
    "elements-arc.originX": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-arc.x\n[1]: #graphic.elements-arc.y\n[2]: #graphic.elements-arc.rotation\n[3]: #graphic.elements-arc.scaleX\n[4]: #graphic.elements-arc.scaleY\n[5]: #graphic.elements-arc.originX\n[6]: #graphic.elements-arc.originY\n[7]: #graphic.elements-group"
    },
    "elements-arc.originY": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-arc.x\n[1]: #graphic.elements-arc.y\n[2]: #graphic.elements-arc.rotation\n[3]: #graphic.elements-arc.scaleX\n[4]: #graphic.elements-arc.scaleY\n[5]: #graphic.elements-arc.originX\n[6]: #graphic.elements-arc.originY\n[7]: #graphic.elements-group"
    },
    "elements-arc.left": {
        "desc": " 描述怎么根据父元素进行定位。 『父元素』是指：如果是顶层元素，父元素是 echarts 图表容器。如果是 group 的子元素，父元素就是 group 元素。 值的类型可以是： \n\n* number：表示像素值。\n* 百分比值：如 '33%'，用父元素的高和此百分比计算出最终值。\n* 'center'：表示自动居中。\n\n[left][0] 和 [right][1] 只有一个可以生效。 如果指定 [left][0] 或 [right][1]，则 [shape][2] 里的 x、cx 等定位属性不再生效。\n\n[0]: #graphic.elements-arc.left\n[1]: #graphic.elements-arc.right\n[2]: #graphic.elements-arc.shape"
    },
    "elements-arc.right": {
        "desc": " 描述怎么根据父元素进行定位。 『父元素』是指：如果是顶层元素，父元素是 echarts 图表容器。如果是 group 的子元素，父元素就是 group 元素。 值的类型可以是： \n\n* number：表示像素值。\n* 百分比值：如 '33%'，用父元素的高和此百分比计算出最终值。\n* 'center'：表示自动居中。\n\n[left][0] 和 [right][1] 只有一个可以生效。 如果指定 [left][0] 或 [right][1]，则 [shape][2] 里的 x、cx 等定位属性不再生效。\n\n[0]: #graphic.elements-arc.left\n[1]: #graphic.elements-arc.right\n[2]: #graphic.elements-arc.shape"
    },
    "elements-arc.top": {
        "desc": " 描述怎么根据父元素进行定位。 『父元素』是指：如果是顶层元素，父元素是 echarts 图表容器。如果是 group 的子元素，父元素就是 group 元素。 值的类型可以是： \n\n* number：表示像素值。\n* 百分比值：如 '33%'，用父元素的宽和此百分比计算出最终值。\n* 'middle'：表示自动居中。\n\n[top][0] 和 [bottom][1] 只有一个可以生效。 如果指定 [top][0] 或 [bottom][1]，则 [shape][2] 里的 y、cy 等定位属性不再生效。\n\n[0]: #graphic.elements-arc.top\n[1]: #graphic.elements-arc.bottom\n[2]: #graphic.elements-arc.shape"
    },
    "elements-arc.bottom": {
        "desc": " 描述怎么根据父元素进行定位。 『父元素』是指：如果是顶层元素，父元素是 echarts 图表容器。如果是 group 的子元素，父元素就是 group 元素。 值的类型可以是： \n\n* number：表示像素值。\n* 百分比值：如 '33%'，用父元素的宽和此百分比计算出最终值。\n* 'middle'：表示自动居中。\n\n[top][0] 和 [bottom][1] 只有一个可以生效。 如果指定 [top][0] 或 [bottom][1]，则 [shape][2] 里的 y、cy 等定位属性不再生效。\n\n[0]: #graphic.elements-arc.top\n[1]: #graphic.elements-arc.bottom\n[2]: #graphic.elements-arc.shape"
    },
    "elements-arc.bounding": {
        "desc": " 决定此图形元素在定位时，对自身的包围盒计算方式。 参见例子： 暂时无法显示 可取值： \n\n* 'all'：（默认） 表示用自身以及子节点整体的经过 transform 后的包围盒进行定位。 这种方式易于使整体都限制在父元素范围中。\n* 'raw'： 表示仅仅用自身（不包括子节点）的没经过 tranform 的包围盒进行定位。 这种方式易于内容超出父元素范围的定位方式。\n\n"
    },
    "elements-arc.z": {
        "desc": " z 方向的高度，决定层叠关系。 "
    },
    "elements-arc.zlevel": {
        "desc": " 决定此元素绘制在哪个 canvas 层中。注意，越多 canvas 层会占用越多资源。 "
    },
    "elements-arc.info": {
        "desc": " 用户定义的任意数据，可以在 event listener 中访问，如： \n\n    chart.on('click', function (params) {\n        console.log(params.info);\n    });\n    \n\n"
    },
    "elements-arc.silent": {
        "desc": " 是否不响应鼠标以及触摸事件。 "
    },
    "elements-arc.invisible": {
        "desc": " 节点是否可见。 "
    },
    "elements-arc.ignore": {
        "desc": " 节点是否完全被忽略（既不渲染，也不响应事件）。 "
    },
    "elements-arc.textContent": {
        "desc": " 这是一个文本定义，附着在一个节点上，会依据 textConfig 配置，相对于节点布局。 里面的属性同于 [text][0]。\n\n[0]: option.html#graphic.elements-text"
    },
    "elements-arc.textConfig": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "elements-arc.textConfig.position": {
        "desc": " Position of textContent. \n\n* 'left'\n* 'right'\n* 'top'\n* 'bottom'\n* 'inside'\n* 'insideLeft'\n* 'insideRight'\n* 'insideTop'\n* 'insideBottom'\n* 'insideTopLeft'\n* 'insideTopRight'\n* 'insideBottomLeft'\n* 'insideBottomRight'\n* or like [12, 33]\n* or like ['50%', '50%']\n\n"
    },
    "elements-arc.textConfig.rotation": {
        "desc": "textContent 的旋转弧度。 "
    },
    "elements-arc.textConfig.layoutRect": {
        "desc": "textContent 根据此矩形来布局位置。 默认是节点的包围盒。 \n\n    {\n        x: number\n        y: number\n        width: number\n        height: number\n    }\n    \n\n"
    },
    "elements-arc.textConfig.offset": {
        "desc": "textContent 的偏移。 offset 和 position 的区别是，offset 是旋转（rotation）后计算。 "
    },
    "elements-arc.textConfig.origin": {
        "desc": "origin 相对于节点的包围盒。 可以是百分数。 如果指定为 'center'，则定位在包围盒中心。 只有当 position and rotation 都设置时，生效。 \n\n* 如 [12, 33]\n* 或如 ['50%', '50%']\n* 'center'\n\n"
    },
    "elements-arc.textConfig.distance": {
        "desc": " 距离 layoutRect 的距离。 "
    },
    "elements-arc.textConfig.local": {
        "desc": " 如果 true 的话，会采用节点的 transform。 "
    },
    "elements-arc.textConfig.insideFill": {
        "desc": "insideFill 可以是一个颜色字符串，或者空着。 如果 textContent 是 \"inside\"，它的 fill 会按这个优先级来选取： textContent.style.fill > textConfig.insideFill > \"auto-calculated-fill\" 在绝大多数场景下，\"auto-calculated-fill\" 是白色。 "
    },
    "elements-arc.textConfig.insideStroke": {
        "desc": "insideStroke 可以是一个颜色字符串，或者空着。 如果 textContent 是 \"inside\"，它的 stroke 会按这个优先级来选取： textContent.style.stroke > textConfig.insideStroke > \"auto-calculated-stroke\" \"auto-calculated-stroke\" 的规则是： \n\n* 如果\n  * (A) fill 在 style 中被指定（无论是在 textContent.style 还是 textContent.style.rich 里）\n  * 或者 (B) 需要画文字的背景（无论是定义在 textContent.style 还是 textContent.style.rich 里）\n  * \"auto-calculated-stroke\" 都会为 null。\n* 否则\n  * \"auto-calculated-stroke\" 会和节点的 fill 相同，如果 fill 没有的话则为 null。\n\n"
    },
    "elements-arc.textConfig.outsideFill": {
        "desc": "outsideFill 可以是一个颜色字符串，或者空着。 如果 textContent 是 \"inside\"，它的 fill 会按这个优先级来选取： textContent.style.fill > textConfig.outsideFill > #000 "
    },
    "elements-arc.textConfig.outsideStroke": {
        "desc": "outsideStroke 可以是一个颜色字符串，或者空着。 如果 textContent 不是 \"inside\"，它的 stroke 会按这个优先级来选取： textContent.style.stroke > textConfig.outsideStroke > \"auto-calculated-stroke\" \"auto-calculated-stroke\" 的规则是： \n\n* 如果\n  * (A) fill 在 style 中被指定（无论是在 textContent.style 还是 textContent.style.rich 里）\n  * 或者 (B) 需要画文字的背景（无论是定义在 textContent.style 还是 textContent.style.rich 里）\n  * \"auto-calculated-stroke\" 都会为 null。\n* 否则\n  * \"auto-calculated-stroke\" 会为一个近似于白色的颜色，来区别于背景。\n\n"
    },
    "elements-arc.textConfig.inside": {
        "desc": " 如果确定文本是在节点中的话，则此可设置为 true，避免 echarts 额外猜测。 "
    },
    "elements-arc.cursor": {
        "desc": " 鼠标悬浮时在图形元素上时鼠标的样式是什么。同 CSS 的 cursor。 ",
        "uiControl": {
            "type": "enum",
            "options": "auto,pointer,move",
            "default": "pointer"
        }
    },
    "elements-arc.draggable": {
        "desc": " 图形元素是否可以被拖拽。 "
    },
    "elements-arc.progressive": {
        "desc": " 是否渐进式渲染。当图形元素过多时才使用。 "
    },
    "elements-arc.shape": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "elements-arc.shape.cx": {
        "desc": " 图形元素的中心在父节点坐标系（以父节点左上角为原点）中的横坐标值。 "
    },
    "elements-arc.shape.cy": {
        "desc": " 图形元素的中心在父节点坐标系（以父节点左上角为原点）中的纵坐标值。 "
    },
    "elements-arc.shape.r": {
        "desc": " 外半径。 "
    },
    "elements-arc.shape.r0": {
        "desc": " 内半径。 "
    },
    "elements-arc.shape.startAngle": {
        "desc": " 开始弧度。 "
    },
    "elements-arc.shape.endAngle": {
        "desc": " 结束弧度。 "
    },
    "elements-arc.shape.clockwise": {
        "desc": " 是否顺时针。 "
    },
    "elements-arc.style": {
        "desc": " 注：关于图形元素中更多的样式设置（例如 [富文本标签][0]），参见 [zrender/graphic/Displayable][1] 中的 style 相关属性。 注意，这里图形元素的样式属性名称直接源于 zrender，和 echarts label、echarts itemStyle 等处同样含义的样式属性名称或有不同。例如，有如下对应： \n\n* [itemStyle.color][2] => style.fill\n* [itemStyle.borderColor][2] => style.stroke\n* [label.color][2] => style.textFill\n* [label.textBorderColor][3] => style.textStroke\n* ...\n\n\n\n[0]: tutorial.html#%E5%AF%8C%E6%96%87%E6%9C%AC%E6%A0%87%E7%AD%BE\n[1]: https://ecomfe.github.io/zrender-doc/public/api.html#zrenderdisplayable\n[2]: #series-scatter.label.color\n[3]: #series-scatter.label.textBorderColor"
    },
    "elements-arc.style.fill": {
        "desc": " 填充色。 "
    },
    "elements-arc.style.stroke": {
        "desc": " 笔画颜色。 "
    },
    "elements-arc.style.lineWidth": {
        "desc": " 笔画宽度。 "
    },
    "elements-arc.style.shadowBlur": {
        "desc": " 阴影宽度。 "
    },
    "elements-arc.style.shadowOffsetX": {
        "desc": " 阴影 X 方向偏移。 "
    },
    "elements-arc.style.shadowOffsetY": {
        "desc": " 阴影 Y 方向偏移。 "
    },
    "elements-arc.style.shadowColor": {
        "desc": " 阴影颜色。 "
    },
    "elements-arc.focus": {
        "desc": ">  从 > v5.0.0>  开始支持 在高亮图形时，是否淡出其它数据的图形已达到聚焦的效果。支持如下配置： \n\n* 'none' 不淡出其它图形，默认使用该配置。\n* 'self' 只聚焦（不淡出）当前高亮的数据的图形。\n* 'series' 聚焦当前高亮的数据所在的系列的所有图形。\n\n"
    },
    "elements-arc.blurScope": {
        "desc": ">  从 > v5.0.0>  开始支持 在开启focus的时候，可以通过blurScope配置淡出的范围。支持如下配置 \n\n* 'coordinateSystem' 淡出范围为坐标系，默认使用该配置。\n* 'series' 淡出范围为系列。\n* 'global' 淡出范围为全局。\n\n"
    },
    "elements-polygon": {
        "desc": " 多边形。 "
    },
    "elements-polygon.type": {
        "desc": " 用 setOption 首次设定图形元素时必须指定。 可取值： [image][0], [text][1], [circle][2], [sector][3], [ring][4], [polygon][5], [polyline][6], [rect][7], [line][8], [bezierCurve][9], [arc][10], [group][11],\n\n[0]: #graphic.elements-image\n[1]: #graphic.elements-text\n[2]: #graphic.elements-circle\n[3]: #graphic.elements-sector\n[4]: #graphic.elements-ring\n[5]: #graphic.elements-polygon\n[6]: #graphic.elements-polyline\n[7]: #graphic.elements-rect\n[8]: #graphic.elements-line\n[9]: #graphic.elements-bezierCurve\n[10]: #graphic.elements-arc\n[11]: #graphic.elements-group"
    },
    "elements-polygon.id": {
        "desc": " id 用于在更新或删除图形元素时指定更新哪个图形元素，如果不需要用可以忽略。 "
    },
    "elements-polygon.$action": {
        "desc": " setOption 时指定本次对该图形元素的操作行为。 可取值： \n\n* 'merge'：如果已有元素，则新的配置项和已有的设定进行 merge。如果没有则新建。\n* 'replace'：如果已有元素，删除之，新建元素替代之。\n* 'remove'：删除元素。\n\n"
    },
    "elements-polygon.x": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-polygon.x\n[1]: #graphic.elements-polygon.y\n[2]: #graphic.elements-polygon.rotation\n[3]: #graphic.elements-polygon.scaleX\n[4]: #graphic.elements-polygon.scaleY\n[5]: #graphic.elements-polygon.originX\n[6]: #graphic.elements-polygon.originY\n[7]: #graphic.elements-group"
    },
    "elements-polygon.y": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-polygon.x\n[1]: #graphic.elements-polygon.y\n[2]: #graphic.elements-polygon.rotation\n[3]: #graphic.elements-polygon.scaleX\n[4]: #graphic.elements-polygon.scaleY\n[5]: #graphic.elements-polygon.originX\n[6]: #graphic.elements-polygon.originY\n[7]: #graphic.elements-group"
    },
    "elements-polygon.rotation": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-polygon.x\n[1]: #graphic.elements-polygon.y\n[2]: #graphic.elements-polygon.rotation\n[3]: #graphic.elements-polygon.scaleX\n[4]: #graphic.elements-polygon.scaleY\n[5]: #graphic.elements-polygon.originX\n[6]: #graphic.elements-polygon.originY\n[7]: #graphic.elements-group"
    },
    "elements-polygon.scaleX": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-polygon.x\n[1]: #graphic.elements-polygon.y\n[2]: #graphic.elements-polygon.rotation\n[3]: #graphic.elements-polygon.scaleX\n[4]: #graphic.elements-polygon.scaleY\n[5]: #graphic.elements-polygon.originX\n[6]: #graphic.elements-polygon.originY\n[7]: #graphic.elements-group"
    },
    "elements-polygon.scaleY": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-polygon.x\n[1]: #graphic.elements-polygon.y\n[2]: #graphic.elements-polygon.rotation\n[3]: #graphic.elements-polygon.scaleX\n[4]: #graphic.elements-polygon.scaleY\n[5]: #graphic.elements-polygon.originX\n[6]: #graphic.elements-polygon.originY\n[7]: #graphic.elements-group"
    },
    "elements-polygon.originX": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-polygon.x\n[1]: #graphic.elements-polygon.y\n[2]: #graphic.elements-polygon.rotation\n[3]: #graphic.elements-polygon.scaleX\n[4]: #graphic.elements-polygon.scaleY\n[5]: #graphic.elements-polygon.originX\n[6]: #graphic.elements-polygon.originY\n[7]: #graphic.elements-group"
    },
    "elements-polygon.originY": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-polygon.x\n[1]: #graphic.elements-polygon.y\n[2]: #graphic.elements-polygon.rotation\n[3]: #graphic.elements-polygon.scaleX\n[4]: #graphic.elements-polygon.scaleY\n[5]: #graphic.elements-polygon.originX\n[6]: #graphic.elements-polygon.originY\n[7]: #graphic.elements-group"
    },
    "elements-polygon.left": {
        "desc": " 描述怎么根据父元素进行定位。 『父元素』是指：如果是顶层元素，父元素是 echarts 图表容器。如果是 group 的子元素，父元素就是 group 元素。 值的类型可以是： \n\n* number：表示像素值。\n* 百分比值：如 '33%'，用父元素的高和此百分比计算出最终值。\n* 'center'：表示自动居中。\n\n[left][0] 和 [right][1] 只有一个可以生效。 如果指定 [left][0] 或 [right][1]，则 [shape][2] 里的 x、cx 等定位属性不再生效。\n\n[0]: #graphic.elements-polygon.left\n[1]: #graphic.elements-polygon.right\n[2]: #graphic.elements-polygon.shape"
    },
    "elements-polygon.right": {
        "desc": " 描述怎么根据父元素进行定位。 『父元素』是指：如果是顶层元素，父元素是 echarts 图表容器。如果是 group 的子元素，父元素就是 group 元素。 值的类型可以是： \n\n* number：表示像素值。\n* 百分比值：如 '33%'，用父元素的高和此百分比计算出最终值。\n* 'center'：表示自动居中。\n\n[left][0] 和 [right][1] 只有一个可以生效。 如果指定 [left][0] 或 [right][1]，则 [shape][2] 里的 x、cx 等定位属性不再生效。\n\n[0]: #graphic.elements-polygon.left\n[1]: #graphic.elements-polygon.right\n[2]: #graphic.elements-polygon.shape"
    },
    "elements-polygon.top": {
        "desc": " 描述怎么根据父元素进行定位。 『父元素』是指：如果是顶层元素，父元素是 echarts 图表容器。如果是 group 的子元素，父元素就是 group 元素。 值的类型可以是： \n\n* number：表示像素值。\n* 百分比值：如 '33%'，用父元素的宽和此百分比计算出最终值。\n* 'middle'：表示自动居中。\n\n[top][0] 和 [bottom][1] 只有一个可以生效。 如果指定 [top][0] 或 [bottom][1]，则 [shape][2] 里的 y、cy 等定位属性不再生效。\n\n[0]: #graphic.elements-polygon.top\n[1]: #graphic.elements-polygon.bottom\n[2]: #graphic.elements-polygon.shape"
    },
    "elements-polygon.bottom": {
        "desc": " 描述怎么根据父元素进行定位。 『父元素』是指：如果是顶层元素，父元素是 echarts 图表容器。如果是 group 的子元素，父元素就是 group 元素。 值的类型可以是： \n\n* number：表示像素值。\n* 百分比值：如 '33%'，用父元素的宽和此百分比计算出最终值。\n* 'middle'：表示自动居中。\n\n[top][0] 和 [bottom][1] 只有一个可以生效。 如果指定 [top][0] 或 [bottom][1]，则 [shape][2] 里的 y、cy 等定位属性不再生效。\n\n[0]: #graphic.elements-polygon.top\n[1]: #graphic.elements-polygon.bottom\n[2]: #graphic.elements-polygon.shape"
    },
    "elements-polygon.bounding": {
        "desc": " 决定此图形元素在定位时，对自身的包围盒计算方式。 参见例子： 暂时无法显示 可取值： \n\n* 'all'：（默认） 表示用自身以及子节点整体的经过 transform 后的包围盒进行定位。 这种方式易于使整体都限制在父元素范围中。\n* 'raw'： 表示仅仅用自身（不包括子节点）的没经过 tranform 的包围盒进行定位。 这种方式易于内容超出父元素范围的定位方式。\n\n"
    },
    "elements-polygon.z": {
        "desc": " z 方向的高度，决定层叠关系。 "
    },
    "elements-polygon.zlevel": {
        "desc": " 决定此元素绘制在哪个 canvas 层中。注意，越多 canvas 层会占用越多资源。 "
    },
    "elements-polygon.info": {
        "desc": " 用户定义的任意数据，可以在 event listener 中访问，如： \n\n    chart.on('click', function (params) {\n        console.log(params.info);\n    });\n    \n\n"
    },
    "elements-polygon.silent": {
        "desc": " 是否不响应鼠标以及触摸事件。 "
    },
    "elements-polygon.invisible": {
        "desc": " 节点是否可见。 "
    },
    "elements-polygon.ignore": {
        "desc": " 节点是否完全被忽略（既不渲染，也不响应事件）。 "
    },
    "elements-polygon.textContent": {
        "desc": " 这是一个文本定义，附着在一个节点上，会依据 textConfig 配置，相对于节点布局。 里面的属性同于 [text][0]。\n\n[0]: option.html#graphic.elements-text"
    },
    "elements-polygon.textConfig": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "elements-polygon.textConfig.position": {
        "desc": " Position of textContent. \n\n* 'left'\n* 'right'\n* 'top'\n* 'bottom'\n* 'inside'\n* 'insideLeft'\n* 'insideRight'\n* 'insideTop'\n* 'insideBottom'\n* 'insideTopLeft'\n* 'insideTopRight'\n* 'insideBottomLeft'\n* 'insideBottomRight'\n* or like [12, 33]\n* or like ['50%', '50%']\n\n"
    },
    "elements-polygon.textConfig.rotation": {
        "desc": "textContent 的旋转弧度。 "
    },
    "elements-polygon.textConfig.layoutRect": {
        "desc": "textContent 根据此矩形来布局位置。 默认是节点的包围盒。 \n\n    {\n        x: number\n        y: number\n        width: number\n        height: number\n    }\n    \n\n"
    },
    "elements-polygon.textConfig.offset": {
        "desc": "textContent 的偏移。 offset 和 position 的区别是，offset 是旋转（rotation）后计算。 "
    },
    "elements-polygon.textConfig.origin": {
        "desc": "origin 相对于节点的包围盒。 可以是百分数。 如果指定为 'center'，则定位在包围盒中心。 只有当 position and rotation 都设置时，生效。 \n\n* 如 [12, 33]\n* 或如 ['50%', '50%']\n* 'center'\n\n"
    },
    "elements-polygon.textConfig.distance": {
        "desc": " 距离 layoutRect 的距离。 "
    },
    "elements-polygon.textConfig.local": {
        "desc": " 如果 true 的话，会采用节点的 transform。 "
    },
    "elements-polygon.textConfig.insideFill": {
        "desc": "insideFill 可以是一个颜色字符串，或者空着。 如果 textContent 是 \"inside\"，它的 fill 会按这个优先级来选取： textContent.style.fill > textConfig.insideFill > \"auto-calculated-fill\" 在绝大多数场景下，\"auto-calculated-fill\" 是白色。 "
    },
    "elements-polygon.textConfig.insideStroke": {
        "desc": "insideStroke 可以是一个颜色字符串，或者空着。 如果 textContent 是 \"inside\"，它的 stroke 会按这个优先级来选取： textContent.style.stroke > textConfig.insideStroke > \"auto-calculated-stroke\" \"auto-calculated-stroke\" 的规则是： \n\n* 如果\n  * (A) fill 在 style 中被指定（无论是在 textContent.style 还是 textContent.style.rich 里）\n  * 或者 (B) 需要画文字的背景（无论是定义在 textContent.style 还是 textContent.style.rich 里）\n  * \"auto-calculated-stroke\" 都会为 null。\n* 否则\n  * \"auto-calculated-stroke\" 会和节点的 fill 相同，如果 fill 没有的话则为 null。\n\n"
    },
    "elements-polygon.textConfig.outsideFill": {
        "desc": "outsideFill 可以是一个颜色字符串，或者空着。 如果 textContent 是 \"inside\"，它的 fill 会按这个优先级来选取： textContent.style.fill > textConfig.outsideFill > #000 "
    },
    "elements-polygon.textConfig.outsideStroke": {
        "desc": "outsideStroke 可以是一个颜色字符串，或者空着。 如果 textContent 不是 \"inside\"，它的 stroke 会按这个优先级来选取： textContent.style.stroke > textConfig.outsideStroke > \"auto-calculated-stroke\" \"auto-calculated-stroke\" 的规则是： \n\n* 如果\n  * (A) fill 在 style 中被指定（无论是在 textContent.style 还是 textContent.style.rich 里）\n  * 或者 (B) 需要画文字的背景（无论是定义在 textContent.style 还是 textContent.style.rich 里）\n  * \"auto-calculated-stroke\" 都会为 null。\n* 否则\n  * \"auto-calculated-stroke\" 会为一个近似于白色的颜色，来区别于背景。\n\n"
    },
    "elements-polygon.textConfig.inside": {
        "desc": " 如果确定文本是在节点中的话，则此可设置为 true，避免 echarts 额外猜测。 "
    },
    "elements-polygon.cursor": {
        "desc": " 鼠标悬浮时在图形元素上时鼠标的样式是什么。同 CSS 的 cursor。 ",
        "uiControl": {
            "type": "enum",
            "options": "auto,pointer,move",
            "default": "pointer"
        }
    },
    "elements-polygon.draggable": {
        "desc": " 图形元素是否可以被拖拽。 "
    },
    "elements-polygon.progressive": {
        "desc": " 是否渐进式渲染。当图形元素过多时才使用。 "
    },
    "elements-polygon.shape": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "elements-polygon.shape.points": {
        "desc": " 点列表，用于定义形状，如 [[22, 44], [44, 55], [11, 44], ...]"
    },
    "elements-polygon.shape.smooth": {
        "desc": " 是否平滑曲线。 \n\n* 如果为 number：表示贝塞尔 (bezier) 差值平滑，smooth 指定了平滑等级，范围 [0, 1]。\n* 如果为 'spline'：表示 Catmull-Rom spline 差值平滑。\n\n"
    },
    "elements-polygon.shape.smoothConstraint": {
        "desc": " 是否将平滑曲线约束在包围盒中。smooth 为 number（bezier）时生效。 "
    },
    "elements-polygon.style": {
        "desc": " 注：关于图形元素中更多的样式设置（例如 [富文本标签][0]），参见 [zrender/graphic/Displayable][1] 中的 style 相关属性。 注意，这里图形元素的样式属性名称直接源于 zrender，和 echarts label、echarts itemStyle 等处同样含义的样式属性名称或有不同。例如，有如下对应： \n\n* [itemStyle.color][2] => style.fill\n* [itemStyle.borderColor][2] => style.stroke\n* [label.color][2] => style.textFill\n* [label.textBorderColor][3] => style.textStroke\n* ...\n\n\n\n[0]: tutorial.html#%E5%AF%8C%E6%96%87%E6%9C%AC%E6%A0%87%E7%AD%BE\n[1]: https://ecomfe.github.io/zrender-doc/public/api.html#zrenderdisplayable\n[2]: #series-scatter.label.color\n[3]: #series-scatter.label.textBorderColor"
    },
    "elements-polygon.style.fill": {
        "desc": " 填充色。 "
    },
    "elements-polygon.style.stroke": {
        "desc": " 笔画颜色。 "
    },
    "elements-polygon.style.lineWidth": {
        "desc": " 笔画宽度。 "
    },
    "elements-polygon.style.shadowBlur": {
        "desc": " 阴影宽度。 "
    },
    "elements-polygon.style.shadowOffsetX": {
        "desc": " 阴影 X 方向偏移。 "
    },
    "elements-polygon.style.shadowOffsetY": {
        "desc": " 阴影 Y 方向偏移。 "
    },
    "elements-polygon.style.shadowColor": {
        "desc": " 阴影颜色。 "
    },
    "elements-polygon.focus": {
        "desc": ">  从 > v5.0.0>  开始支持 在高亮图形时，是否淡出其它数据的图形已达到聚焦的效果。支持如下配置： \n\n* 'none' 不淡出其它图形，默认使用该配置。\n* 'self' 只聚焦（不淡出）当前高亮的数据的图形。\n* 'series' 聚焦当前高亮的数据所在的系列的所有图形。\n\n"
    },
    "elements-polygon.blurScope": {
        "desc": ">  从 > v5.0.0>  开始支持 在开启focus的时候，可以通过blurScope配置淡出的范围。支持如下配置 \n\n* 'coordinateSystem' 淡出范围为坐标系，默认使用该配置。\n* 'series' 淡出范围为系列。\n* 'global' 淡出范围为全局。\n\n"
    },
    "elements-polyline": {
        "desc": " 折线。 "
    },
    "elements-polyline.type": {
        "desc": " 用 setOption 首次设定图形元素时必须指定。 可取值： [image][0], [text][1], [circle][2], [sector][3], [ring][4], [polygon][5], [polyline][6], [rect][7], [line][8], [bezierCurve][9], [arc][10], [group][11],\n\n[0]: #graphic.elements-image\n[1]: #graphic.elements-text\n[2]: #graphic.elements-circle\n[3]: #graphic.elements-sector\n[4]: #graphic.elements-ring\n[5]: #graphic.elements-polygon\n[6]: #graphic.elements-polyline\n[7]: #graphic.elements-rect\n[8]: #graphic.elements-line\n[9]: #graphic.elements-bezierCurve\n[10]: #graphic.elements-arc\n[11]: #graphic.elements-group"
    },
    "elements-polyline.id": {
        "desc": " id 用于在更新或删除图形元素时指定更新哪个图形元素，如果不需要用可以忽略。 "
    },
    "elements-polyline.$action": {
        "desc": " setOption 时指定本次对该图形元素的操作行为。 可取值： \n\n* 'merge'：如果已有元素，则新的配置项和已有的设定进行 merge。如果没有则新建。\n* 'replace'：如果已有元素，删除之，新建元素替代之。\n* 'remove'：删除元素。\n\n"
    },
    "elements-polyline.x": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-polyline.x\n[1]: #graphic.elements-polyline.y\n[2]: #graphic.elements-polyline.rotation\n[3]: #graphic.elements-polyline.scaleX\n[4]: #graphic.elements-polyline.scaleY\n[5]: #graphic.elements-polyline.originX\n[6]: #graphic.elements-polyline.originY\n[7]: #graphic.elements-group"
    },
    "elements-polyline.y": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-polyline.x\n[1]: #graphic.elements-polyline.y\n[2]: #graphic.elements-polyline.rotation\n[3]: #graphic.elements-polyline.scaleX\n[4]: #graphic.elements-polyline.scaleY\n[5]: #graphic.elements-polyline.originX\n[6]: #graphic.elements-polyline.originY\n[7]: #graphic.elements-group"
    },
    "elements-polyline.rotation": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-polyline.x\n[1]: #graphic.elements-polyline.y\n[2]: #graphic.elements-polyline.rotation\n[3]: #graphic.elements-polyline.scaleX\n[4]: #graphic.elements-polyline.scaleY\n[5]: #graphic.elements-polyline.originX\n[6]: #graphic.elements-polyline.originY\n[7]: #graphic.elements-group"
    },
    "elements-polyline.scaleX": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-polyline.x\n[1]: #graphic.elements-polyline.y\n[2]: #graphic.elements-polyline.rotation\n[3]: #graphic.elements-polyline.scaleX\n[4]: #graphic.elements-polyline.scaleY\n[5]: #graphic.elements-polyline.originX\n[6]: #graphic.elements-polyline.originY\n[7]: #graphic.elements-group"
    },
    "elements-polyline.scaleY": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-polyline.x\n[1]: #graphic.elements-polyline.y\n[2]: #graphic.elements-polyline.rotation\n[3]: #graphic.elements-polyline.scaleX\n[4]: #graphic.elements-polyline.scaleY\n[5]: #graphic.elements-polyline.originX\n[6]: #graphic.elements-polyline.originY\n[7]: #graphic.elements-group"
    },
    "elements-polyline.originX": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-polyline.x\n[1]: #graphic.elements-polyline.y\n[2]: #graphic.elements-polyline.rotation\n[3]: #graphic.elements-polyline.scaleX\n[4]: #graphic.elements-polyline.scaleY\n[5]: #graphic.elements-polyline.originX\n[6]: #graphic.elements-polyline.originY\n[7]: #graphic.elements-group"
    },
    "elements-polyline.originY": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-polyline.x\n[1]: #graphic.elements-polyline.y\n[2]: #graphic.elements-polyline.rotation\n[3]: #graphic.elements-polyline.scaleX\n[4]: #graphic.elements-polyline.scaleY\n[5]: #graphic.elements-polyline.originX\n[6]: #graphic.elements-polyline.originY\n[7]: #graphic.elements-group"
    },
    "elements-polyline.left": {
        "desc": " 描述怎么根据父元素进行定位。 『父元素』是指：如果是顶层元素，父元素是 echarts 图表容器。如果是 group 的子元素，父元素就是 group 元素。 值的类型可以是： \n\n* number：表示像素值。\n* 百分比值：如 '33%'，用父元素的高和此百分比计算出最终值。\n* 'center'：表示自动居中。\n\n[left][0] 和 [right][1] 只有一个可以生效。 如果指定 [left][0] 或 [right][1]，则 [shape][2] 里的 x、cx 等定位属性不再生效。\n\n[0]: #graphic.elements-polyline.left\n[1]: #graphic.elements-polyline.right\n[2]: #graphic.elements-polyline.shape"
    },
    "elements-polyline.right": {
        "desc": " 描述怎么根据父元素进行定位。 『父元素』是指：如果是顶层元素，父元素是 echarts 图表容器。如果是 group 的子元素，父元素就是 group 元素。 值的类型可以是： \n\n* number：表示像素值。\n* 百分比值：如 '33%'，用父元素的高和此百分比计算出最终值。\n* 'center'：表示自动居中。\n\n[left][0] 和 [right][1] 只有一个可以生效。 如果指定 [left][0] 或 [right][1]，则 [shape][2] 里的 x、cx 等定位属性不再生效。\n\n[0]: #graphic.elements-polyline.left\n[1]: #graphic.elements-polyline.right\n[2]: #graphic.elements-polyline.shape"
    },
    "elements-polyline.top": {
        "desc": " 描述怎么根据父元素进行定位。 『父元素』是指：如果是顶层元素，父元素是 echarts 图表容器。如果是 group 的子元素，父元素就是 group 元素。 值的类型可以是： \n\n* number：表示像素值。\n* 百分比值：如 '33%'，用父元素的宽和此百分比计算出最终值。\n* 'middle'：表示自动居中。\n\n[top][0] 和 [bottom][1] 只有一个可以生效。 如果指定 [top][0] 或 [bottom][1]，则 [shape][2] 里的 y、cy 等定位属性不再生效。\n\n[0]: #graphic.elements-polyline.top\n[1]: #graphic.elements-polyline.bottom\n[2]: #graphic.elements-polyline.shape"
    },
    "elements-polyline.bottom": {
        "desc": " 描述怎么根据父元素进行定位。 『父元素』是指：如果是顶层元素，父元素是 echarts 图表容器。如果是 group 的子元素，父元素就是 group 元素。 值的类型可以是： \n\n* number：表示像素值。\n* 百分比值：如 '33%'，用父元素的宽和此百分比计算出最终值。\n* 'middle'：表示自动居中。\n\n[top][0] 和 [bottom][1] 只有一个可以生效。 如果指定 [top][0] 或 [bottom][1]，则 [shape][2] 里的 y、cy 等定位属性不再生效。\n\n[0]: #graphic.elements-polyline.top\n[1]: #graphic.elements-polyline.bottom\n[2]: #graphic.elements-polyline.shape"
    },
    "elements-polyline.bounding": {
        "desc": " 决定此图形元素在定位时，对自身的包围盒计算方式。 参见例子： 暂时无法显示 可取值： \n\n* 'all'：（默认） 表示用自身以及子节点整体的经过 transform 后的包围盒进行定位。 这种方式易于使整体都限制在父元素范围中。\n* 'raw'： 表示仅仅用自身（不包括子节点）的没经过 tranform 的包围盒进行定位。 这种方式易于内容超出父元素范围的定位方式。\n\n"
    },
    "elements-polyline.z": {
        "desc": " z 方向的高度，决定层叠关系。 "
    },
    "elements-polyline.zlevel": {
        "desc": " 决定此元素绘制在哪个 canvas 层中。注意，越多 canvas 层会占用越多资源。 "
    },
    "elements-polyline.info": {
        "desc": " 用户定义的任意数据，可以在 event listener 中访问，如： \n\n    chart.on('click', function (params) {\n        console.log(params.info);\n    });\n    \n\n"
    },
    "elements-polyline.silent": {
        "desc": " 是否不响应鼠标以及触摸事件。 "
    },
    "elements-polyline.invisible": {
        "desc": " 节点是否可见。 "
    },
    "elements-polyline.ignore": {
        "desc": " 节点是否完全被忽略（既不渲染，也不响应事件）。 "
    },
    "elements-polyline.textContent": {
        "desc": " 这是一个文本定义，附着在一个节点上，会依据 textConfig 配置，相对于节点布局。 里面的属性同于 [text][0]。\n\n[0]: option.html#graphic.elements-text"
    },
    "elements-polyline.textConfig": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "elements-polyline.textConfig.position": {
        "desc": " Position of textContent. \n\n* 'left'\n* 'right'\n* 'top'\n* 'bottom'\n* 'inside'\n* 'insideLeft'\n* 'insideRight'\n* 'insideTop'\n* 'insideBottom'\n* 'insideTopLeft'\n* 'insideTopRight'\n* 'insideBottomLeft'\n* 'insideBottomRight'\n* or like [12, 33]\n* or like ['50%', '50%']\n\n"
    },
    "elements-polyline.textConfig.rotation": {
        "desc": "textContent 的旋转弧度。 "
    },
    "elements-polyline.textConfig.layoutRect": {
        "desc": "textContent 根据此矩形来布局位置。 默认是节点的包围盒。 \n\n    {\n        x: number\n        y: number\n        width: number\n        height: number\n    }\n    \n\n"
    },
    "elements-polyline.textConfig.offset": {
        "desc": "textContent 的偏移。 offset 和 position 的区别是，offset 是旋转（rotation）后计算。 "
    },
    "elements-polyline.textConfig.origin": {
        "desc": "origin 相对于节点的包围盒。 可以是百分数。 如果指定为 'center'，则定位在包围盒中心。 只有当 position and rotation 都设置时，生效。 \n\n* 如 [12, 33]\n* 或如 ['50%', '50%']\n* 'center'\n\n"
    },
    "elements-polyline.textConfig.distance": {
        "desc": " 距离 layoutRect 的距离。 "
    },
    "elements-polyline.textConfig.local": {
        "desc": " 如果 true 的话，会采用节点的 transform。 "
    },
    "elements-polyline.textConfig.insideFill": {
        "desc": "insideFill 可以是一个颜色字符串，或者空着。 如果 textContent 是 \"inside\"，它的 fill 会按这个优先级来选取： textContent.style.fill > textConfig.insideFill > \"auto-calculated-fill\" 在绝大多数场景下，\"auto-calculated-fill\" 是白色。 "
    },
    "elements-polyline.textConfig.insideStroke": {
        "desc": "insideStroke 可以是一个颜色字符串，或者空着。 如果 textContent 是 \"inside\"，它的 stroke 会按这个优先级来选取： textContent.style.stroke > textConfig.insideStroke > \"auto-calculated-stroke\" \"auto-calculated-stroke\" 的规则是： \n\n* 如果\n  * (A) fill 在 style 中被指定（无论是在 textContent.style 还是 textContent.style.rich 里）\n  * 或者 (B) 需要画文字的背景（无论是定义在 textContent.style 还是 textContent.style.rich 里）\n  * \"auto-calculated-stroke\" 都会为 null。\n* 否则\n  * \"auto-calculated-stroke\" 会和节点的 fill 相同，如果 fill 没有的话则为 null。\n\n"
    },
    "elements-polyline.textConfig.outsideFill": {
        "desc": "outsideFill 可以是一个颜色字符串，或者空着。 如果 textContent 是 \"inside\"，它的 fill 会按这个优先级来选取： textContent.style.fill > textConfig.outsideFill > #000 "
    },
    "elements-polyline.textConfig.outsideStroke": {
        "desc": "outsideStroke 可以是一个颜色字符串，或者空着。 如果 textContent 不是 \"inside\"，它的 stroke 会按这个优先级来选取： textContent.style.stroke > textConfig.outsideStroke > \"auto-calculated-stroke\" \"auto-calculated-stroke\" 的规则是： \n\n* 如果\n  * (A) fill 在 style 中被指定（无论是在 textContent.style 还是 textContent.style.rich 里）\n  * 或者 (B) 需要画文字的背景（无论是定义在 textContent.style 还是 textContent.style.rich 里）\n  * \"auto-calculated-stroke\" 都会为 null。\n* 否则\n  * \"auto-calculated-stroke\" 会为一个近似于白色的颜色，来区别于背景。\n\n"
    },
    "elements-polyline.textConfig.inside": {
        "desc": " 如果确定文本是在节点中的话，则此可设置为 true，避免 echarts 额外猜测。 "
    },
    "elements-polyline.cursor": {
        "desc": " 鼠标悬浮时在图形元素上时鼠标的样式是什么。同 CSS 的 cursor。 ",
        "uiControl": {
            "type": "enum",
            "options": "auto,pointer,move",
            "default": "pointer"
        }
    },
    "elements-polyline.draggable": {
        "desc": " 图形元素是否可以被拖拽。 "
    },
    "elements-polyline.progressive": {
        "desc": " 是否渐进式渲染。当图形元素过多时才使用。 "
    },
    "elements-polyline.shape": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "elements-polyline.shape.points": {
        "desc": " 点列表，用于定义形状，如 [[22, 44], [44, 55], [11, 44], ...]"
    },
    "elements-polyline.shape.smooth": {
        "desc": " 是否平滑曲线。 \n\n* 如果为 number：表示贝塞尔 (bezier) 差值平滑，smooth 指定了平滑等级，范围 [0, 1]。\n* 如果为 'spline'：表示 Catmull-Rom spline 差值平滑。\n\n"
    },
    "elements-polyline.shape.smoothConstraint": {
        "desc": " 是否将平滑曲线约束在包围盒中。smooth 为 number（bezier）时生效。 "
    },
    "elements-polyline.style": {
        "desc": " 注：关于图形元素中更多的样式设置（例如 [富文本标签][0]），参见 [zrender/graphic/Displayable][1] 中的 style 相关属性。 注意，这里图形元素的样式属性名称直接源于 zrender，和 echarts label、echarts itemStyle 等处同样含义的样式属性名称或有不同。例如，有如下对应： \n\n* [itemStyle.color][2] => style.fill\n* [itemStyle.borderColor][2] => style.stroke\n* [label.color][2] => style.textFill\n* [label.textBorderColor][3] => style.textStroke\n* ...\n\n\n\n[0]: tutorial.html#%E5%AF%8C%E6%96%87%E6%9C%AC%E6%A0%87%E7%AD%BE\n[1]: https://ecomfe.github.io/zrender-doc/public/api.html#zrenderdisplayable\n[2]: #series-scatter.label.color\n[3]: #series-scatter.label.textBorderColor"
    },
    "elements-polyline.style.fill": {
        "desc": " 填充色。 "
    },
    "elements-polyline.style.stroke": {
        "desc": " 笔画颜色。 "
    },
    "elements-polyline.style.lineWidth": {
        "desc": " 笔画宽度。 "
    },
    "elements-polyline.style.shadowBlur": {
        "desc": " 阴影宽度。 "
    },
    "elements-polyline.style.shadowOffsetX": {
        "desc": " 阴影 X 方向偏移。 "
    },
    "elements-polyline.style.shadowOffsetY": {
        "desc": " 阴影 Y 方向偏移。 "
    },
    "elements-polyline.style.shadowColor": {
        "desc": " 阴影颜色。 "
    },
    "elements-polyline.focus": {
        "desc": ">  从 > v5.0.0>  开始支持 在高亮图形时，是否淡出其它数据的图形已达到聚焦的效果。支持如下配置： \n\n* 'none' 不淡出其它图形，默认使用该配置。\n* 'self' 只聚焦（不淡出）当前高亮的数据的图形。\n* 'series' 聚焦当前高亮的数据所在的系列的所有图形。\n\n"
    },
    "elements-polyline.blurScope": {
        "desc": ">  从 > v5.0.0>  开始支持 在开启focus的时候，可以通过blurScope配置淡出的范围。支持如下配置 \n\n* 'coordinateSystem' 淡出范围为坐标系，默认使用该配置。\n* 'series' 淡出范围为系列。\n* 'global' 淡出范围为全局。\n\n"
    },
    "elements-line": {
        "desc": " 直线。 "
    },
    "elements-line.type": {
        "desc": " 用 setOption 首次设定图形元素时必须指定。 可取值： [image][0], [text][1], [circle][2], [sector][3], [ring][4], [polygon][5], [polyline][6], [rect][7], [line][8], [bezierCurve][9], [arc][10], [group][11],\n\n[0]: #graphic.elements-image\n[1]: #graphic.elements-text\n[2]: #graphic.elements-circle\n[3]: #graphic.elements-sector\n[4]: #graphic.elements-ring\n[5]: #graphic.elements-polygon\n[6]: #graphic.elements-polyline\n[7]: #graphic.elements-rect\n[8]: #graphic.elements-line\n[9]: #graphic.elements-bezierCurve\n[10]: #graphic.elements-arc\n[11]: #graphic.elements-group"
    },
    "elements-line.id": {
        "desc": " id 用于在更新或删除图形元素时指定更新哪个图形元素，如果不需要用可以忽略。 "
    },
    "elements-line.$action": {
        "desc": " setOption 时指定本次对该图形元素的操作行为。 可取值： \n\n* 'merge'：如果已有元素，则新的配置项和已有的设定进行 merge。如果没有则新建。\n* 'replace'：如果已有元素，删除之，新建元素替代之。\n* 'remove'：删除元素。\n\n"
    },
    "elements-line.x": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-line.x\n[1]: #graphic.elements-line.y\n[2]: #graphic.elements-line.rotation\n[3]: #graphic.elements-line.scaleX\n[4]: #graphic.elements-line.scaleY\n[5]: #graphic.elements-line.originX\n[6]: #graphic.elements-line.originY\n[7]: #graphic.elements-group"
    },
    "elements-line.y": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-line.x\n[1]: #graphic.elements-line.y\n[2]: #graphic.elements-line.rotation\n[3]: #graphic.elements-line.scaleX\n[4]: #graphic.elements-line.scaleY\n[5]: #graphic.elements-line.originX\n[6]: #graphic.elements-line.originY\n[7]: #graphic.elements-group"
    },
    "elements-line.rotation": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-line.x\n[1]: #graphic.elements-line.y\n[2]: #graphic.elements-line.rotation\n[3]: #graphic.elements-line.scaleX\n[4]: #graphic.elements-line.scaleY\n[5]: #graphic.elements-line.originX\n[6]: #graphic.elements-line.originY\n[7]: #graphic.elements-group"
    },
    "elements-line.scaleX": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-line.x\n[1]: #graphic.elements-line.y\n[2]: #graphic.elements-line.rotation\n[3]: #graphic.elements-line.scaleX\n[4]: #graphic.elements-line.scaleY\n[5]: #graphic.elements-line.originX\n[6]: #graphic.elements-line.originY\n[7]: #graphic.elements-group"
    },
    "elements-line.scaleY": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-line.x\n[1]: #graphic.elements-line.y\n[2]: #graphic.elements-line.rotation\n[3]: #graphic.elements-line.scaleX\n[4]: #graphic.elements-line.scaleY\n[5]: #graphic.elements-line.originX\n[6]: #graphic.elements-line.originY\n[7]: #graphic.elements-group"
    },
    "elements-line.originX": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-line.x\n[1]: #graphic.elements-line.y\n[2]: #graphic.elements-line.rotation\n[3]: #graphic.elements-line.scaleX\n[4]: #graphic.elements-line.scaleY\n[5]: #graphic.elements-line.originX\n[6]: #graphic.elements-line.originY\n[7]: #graphic.elements-group"
    },
    "elements-line.originY": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-line.x\n[1]: #graphic.elements-line.y\n[2]: #graphic.elements-line.rotation\n[3]: #graphic.elements-line.scaleX\n[4]: #graphic.elements-line.scaleY\n[5]: #graphic.elements-line.originX\n[6]: #graphic.elements-line.originY\n[7]: #graphic.elements-group"
    },
    "elements-line.left": {
        "desc": " 描述怎么根据父元素进行定位。 『父元素』是指：如果是顶层元素，父元素是 echarts 图表容器。如果是 group 的子元素，父元素就是 group 元素。 值的类型可以是： \n\n* number：表示像素值。\n* 百分比值：如 '33%'，用父元素的高和此百分比计算出最终值。\n* 'center'：表示自动居中。\n\n[left][0] 和 [right][1] 只有一个可以生效。 如果指定 [left][0] 或 [right][1]，则 [shape][2] 里的 x、cx 等定位属性不再生效。\n\n[0]: #graphic.elements-line.left\n[1]: #graphic.elements-line.right\n[2]: #graphic.elements-line.shape"
    },
    "elements-line.right": {
        "desc": " 描述怎么根据父元素进行定位。 『父元素』是指：如果是顶层元素，父元素是 echarts 图表容器。如果是 group 的子元素，父元素就是 group 元素。 值的类型可以是： \n\n* number：表示像素值。\n* 百分比值：如 '33%'，用父元素的高和此百分比计算出最终值。\n* 'center'：表示自动居中。\n\n[left][0] 和 [right][1] 只有一个可以生效。 如果指定 [left][0] 或 [right][1]，则 [shape][2] 里的 x、cx 等定位属性不再生效。\n\n[0]: #graphic.elements-line.left\n[1]: #graphic.elements-line.right\n[2]: #graphic.elements-line.shape"
    },
    "elements-line.top": {
        "desc": " 描述怎么根据父元素进行定位。 『父元素』是指：如果是顶层元素，父元素是 echarts 图表容器。如果是 group 的子元素，父元素就是 group 元素。 值的类型可以是： \n\n* number：表示像素值。\n* 百分比值：如 '33%'，用父元素的宽和此百分比计算出最终值。\n* 'middle'：表示自动居中。\n\n[top][0] 和 [bottom][1] 只有一个可以生效。 如果指定 [top][0] 或 [bottom][1]，则 [shape][2] 里的 y、cy 等定位属性不再生效。\n\n[0]: #graphic.elements-line.top\n[1]: #graphic.elements-line.bottom\n[2]: #graphic.elements-line.shape"
    },
    "elements-line.bottom": {
        "desc": " 描述怎么根据父元素进行定位。 『父元素』是指：如果是顶层元素，父元素是 echarts 图表容器。如果是 group 的子元素，父元素就是 group 元素。 值的类型可以是： \n\n* number：表示像素值。\n* 百分比值：如 '33%'，用父元素的宽和此百分比计算出最终值。\n* 'middle'：表示自动居中。\n\n[top][0] 和 [bottom][1] 只有一个可以生效。 如果指定 [top][0] 或 [bottom][1]，则 [shape][2] 里的 y、cy 等定位属性不再生效。\n\n[0]: #graphic.elements-line.top\n[1]: #graphic.elements-line.bottom\n[2]: #graphic.elements-line.shape"
    },
    "elements-line.bounding": {
        "desc": " 决定此图形元素在定位时，对自身的包围盒计算方式。 参见例子： 暂时无法显示 可取值： \n\n* 'all'：（默认） 表示用自身以及子节点整体的经过 transform 后的包围盒进行定位。 这种方式易于使整体都限制在父元素范围中。\n* 'raw'： 表示仅仅用自身（不包括子节点）的没经过 tranform 的包围盒进行定位。 这种方式易于内容超出父元素范围的定位方式。\n\n"
    },
    "elements-line.z": {
        "desc": " z 方向的高度，决定层叠关系。 "
    },
    "elements-line.zlevel": {
        "desc": " 决定此元素绘制在哪个 canvas 层中。注意，越多 canvas 层会占用越多资源。 "
    },
    "elements-line.info": {
        "desc": " 用户定义的任意数据，可以在 event listener 中访问，如： \n\n    chart.on('click', function (params) {\n        console.log(params.info);\n    });\n    \n\n"
    },
    "elements-line.silent": {
        "desc": " 是否不响应鼠标以及触摸事件。 "
    },
    "elements-line.invisible": {
        "desc": " 节点是否可见。 "
    },
    "elements-line.ignore": {
        "desc": " 节点是否完全被忽略（既不渲染，也不响应事件）。 "
    },
    "elements-line.textContent": {
        "desc": " 这是一个文本定义，附着在一个节点上，会依据 textConfig 配置，相对于节点布局。 里面的属性同于 [text][0]。\n\n[0]: option.html#graphic.elements-text"
    },
    "elements-line.textConfig": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "elements-line.textConfig.position": {
        "desc": " Position of textContent. \n\n* 'left'\n* 'right'\n* 'top'\n* 'bottom'\n* 'inside'\n* 'insideLeft'\n* 'insideRight'\n* 'insideTop'\n* 'insideBottom'\n* 'insideTopLeft'\n* 'insideTopRight'\n* 'insideBottomLeft'\n* 'insideBottomRight'\n* or like [12, 33]\n* or like ['50%', '50%']\n\n"
    },
    "elements-line.textConfig.rotation": {
        "desc": "textContent 的旋转弧度。 "
    },
    "elements-line.textConfig.layoutRect": {
        "desc": "textContent 根据此矩形来布局位置。 默认是节点的包围盒。 \n\n    {\n        x: number\n        y: number\n        width: number\n        height: number\n    }\n    \n\n"
    },
    "elements-line.textConfig.offset": {
        "desc": "textContent 的偏移。 offset 和 position 的区别是，offset 是旋转（rotation）后计算。 "
    },
    "elements-line.textConfig.origin": {
        "desc": "origin 相对于节点的包围盒。 可以是百分数。 如果指定为 'center'，则定位在包围盒中心。 只有当 position and rotation 都设置时，生效。 \n\n* 如 [12, 33]\n* 或如 ['50%', '50%']\n* 'center'\n\n"
    },
    "elements-line.textConfig.distance": {
        "desc": " 距离 layoutRect 的距离。 "
    },
    "elements-line.textConfig.local": {
        "desc": " 如果 true 的话，会采用节点的 transform。 "
    },
    "elements-line.textConfig.insideFill": {
        "desc": "insideFill 可以是一个颜色字符串，或者空着。 如果 textContent 是 \"inside\"，它的 fill 会按这个优先级来选取： textContent.style.fill > textConfig.insideFill > \"auto-calculated-fill\" 在绝大多数场景下，\"auto-calculated-fill\" 是白色。 "
    },
    "elements-line.textConfig.insideStroke": {
        "desc": "insideStroke 可以是一个颜色字符串，或者空着。 如果 textContent 是 \"inside\"，它的 stroke 会按这个优先级来选取： textContent.style.stroke > textConfig.insideStroke > \"auto-calculated-stroke\" \"auto-calculated-stroke\" 的规则是： \n\n* 如果\n  * (A) fill 在 style 中被指定（无论是在 textContent.style 还是 textContent.style.rich 里）\n  * 或者 (B) 需要画文字的背景（无论是定义在 textContent.style 还是 textContent.style.rich 里）\n  * \"auto-calculated-stroke\" 都会为 null。\n* 否则\n  * \"auto-calculated-stroke\" 会和节点的 fill 相同，如果 fill 没有的话则为 null。\n\n"
    },
    "elements-line.textConfig.outsideFill": {
        "desc": "outsideFill 可以是一个颜色字符串，或者空着。 如果 textContent 是 \"inside\"，它的 fill 会按这个优先级来选取： textContent.style.fill > textConfig.outsideFill > #000 "
    },
    "elements-line.textConfig.outsideStroke": {
        "desc": "outsideStroke 可以是一个颜色字符串，或者空着。 如果 textContent 不是 \"inside\"，它的 stroke 会按这个优先级来选取： textContent.style.stroke > textConfig.outsideStroke > \"auto-calculated-stroke\" \"auto-calculated-stroke\" 的规则是： \n\n* 如果\n  * (A) fill 在 style 中被指定（无论是在 textContent.style 还是 textContent.style.rich 里）\n  * 或者 (B) 需要画文字的背景（无论是定义在 textContent.style 还是 textContent.style.rich 里）\n  * \"auto-calculated-stroke\" 都会为 null。\n* 否则\n  * \"auto-calculated-stroke\" 会为一个近似于白色的颜色，来区别于背景。\n\n"
    },
    "elements-line.textConfig.inside": {
        "desc": " 如果确定文本是在节点中的话，则此可设置为 true，避免 echarts 额外猜测。 "
    },
    "elements-line.cursor": {
        "desc": " 鼠标悬浮时在图形元素上时鼠标的样式是什么。同 CSS 的 cursor。 ",
        "uiControl": {
            "type": "enum",
            "options": "auto,pointer,move",
            "default": "pointer"
        }
    },
    "elements-line.draggable": {
        "desc": " 图形元素是否可以被拖拽。 "
    },
    "elements-line.progressive": {
        "desc": " 是否渐进式渲染。当图形元素过多时才使用。 "
    },
    "elements-line.shape": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "elements-line.shape.x1": {
        "desc": " 开始点的 x 值。 "
    },
    "elements-line.shape.y1": {
        "desc": " 开始点的 y 值。 "
    },
    "elements-line.shape.x2": {
        "desc": " 结束点的 x 值。 "
    },
    "elements-line.shape.y2": {
        "desc": " 结束点的 y 值。 "
    },
    "elements-line.shape.percent": {
        "desc": " 线画到百分之多少就不画了。值的范围：[0, 1]。 "
    },
    "elements-line.style": {
        "desc": " 注：关于图形元素中更多的样式设置（例如 [富文本标签][0]），参见 [zrender/graphic/Displayable][1] 中的 style 相关属性。 注意，这里图形元素的样式属性名称直接源于 zrender，和 echarts label、echarts itemStyle 等处同样含义的样式属性名称或有不同。例如，有如下对应： \n\n* [itemStyle.color][2] => style.fill\n* [itemStyle.borderColor][2] => style.stroke\n* [label.color][2] => style.textFill\n* [label.textBorderColor][3] => style.textStroke\n* ...\n\n\n\n[0]: tutorial.html#%E5%AF%8C%E6%96%87%E6%9C%AC%E6%A0%87%E7%AD%BE\n[1]: https://ecomfe.github.io/zrender-doc/public/api.html#zrenderdisplayable\n[2]: #series-scatter.label.color\n[3]: #series-scatter.label.textBorderColor"
    },
    "elements-line.style.fill": {
        "desc": " 填充色。 "
    },
    "elements-line.style.stroke": {
        "desc": " 笔画颜色。 "
    },
    "elements-line.style.lineWidth": {
        "desc": " 笔画宽度。 "
    },
    "elements-line.style.shadowBlur": {
        "desc": " 阴影宽度。 "
    },
    "elements-line.style.shadowOffsetX": {
        "desc": " 阴影 X 方向偏移。 "
    },
    "elements-line.style.shadowOffsetY": {
        "desc": " 阴影 Y 方向偏移。 "
    },
    "elements-line.style.shadowColor": {
        "desc": " 阴影颜色。 "
    },
    "elements-line.focus": {
        "desc": ">  从 > v5.0.0>  开始支持 在高亮图形时，是否淡出其它数据的图形已达到聚焦的效果。支持如下配置： \n\n* 'none' 不淡出其它图形，默认使用该配置。\n* 'self' 只聚焦（不淡出）当前高亮的数据的图形。\n* 'series' 聚焦当前高亮的数据所在的系列的所有图形。\n\n"
    },
    "elements-line.blurScope": {
        "desc": ">  从 > v5.0.0>  开始支持 在开启focus的时候，可以通过blurScope配置淡出的范围。支持如下配置 \n\n* 'coordinateSystem' 淡出范围为坐标系，默认使用该配置。\n* 'series' 淡出范围为系列。\n* 'global' 淡出范围为全局。\n\n"
    },
    "elements-bezierCurve": {
        "desc": " 二次或三次贝塞尔曲线。 "
    },
    "elements-bezierCurve.type": {
        "desc": " 用 setOption 首次设定图形元素时必须指定。 可取值： [image][0], [text][1], [circle][2], [sector][3], [ring][4], [polygon][5], [polyline][6], [rect][7], [line][8], [bezierCurve][9], [arc][10], [group][11],\n\n[0]: #graphic.elements-image\n[1]: #graphic.elements-text\n[2]: #graphic.elements-circle\n[3]: #graphic.elements-sector\n[4]: #graphic.elements-ring\n[5]: #graphic.elements-polygon\n[6]: #graphic.elements-polyline\n[7]: #graphic.elements-rect\n[8]: #graphic.elements-line\n[9]: #graphic.elements-bezierCurve\n[10]: #graphic.elements-arc\n[11]: #graphic.elements-group"
    },
    "elements-bezierCurve.id": {
        "desc": " id 用于在更新或删除图形元素时指定更新哪个图形元素，如果不需要用可以忽略。 "
    },
    "elements-bezierCurve.$action": {
        "desc": " setOption 时指定本次对该图形元素的操作行为。 可取值： \n\n* 'merge'：如果已有元素，则新的配置项和已有的设定进行 merge。如果没有则新建。\n* 'replace'：如果已有元素，删除之，新建元素替代之。\n* 'remove'：删除元素。\n\n"
    },
    "elements-bezierCurve.x": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-bezierCurve.x\n[1]: #graphic.elements-bezierCurve.y\n[2]: #graphic.elements-bezierCurve.rotation\n[3]: #graphic.elements-bezierCurve.scaleX\n[4]: #graphic.elements-bezierCurve.scaleY\n[5]: #graphic.elements-bezierCurve.originX\n[6]: #graphic.elements-bezierCurve.originY\n[7]: #graphic.elements-group"
    },
    "elements-bezierCurve.y": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-bezierCurve.x\n[1]: #graphic.elements-bezierCurve.y\n[2]: #graphic.elements-bezierCurve.rotation\n[3]: #graphic.elements-bezierCurve.scaleX\n[4]: #graphic.elements-bezierCurve.scaleY\n[5]: #graphic.elements-bezierCurve.originX\n[6]: #graphic.elements-bezierCurve.originY\n[7]: #graphic.elements-group"
    },
    "elements-bezierCurve.rotation": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-bezierCurve.x\n[1]: #graphic.elements-bezierCurve.y\n[2]: #graphic.elements-bezierCurve.rotation\n[3]: #graphic.elements-bezierCurve.scaleX\n[4]: #graphic.elements-bezierCurve.scaleY\n[5]: #graphic.elements-bezierCurve.originX\n[6]: #graphic.elements-bezierCurve.originY\n[7]: #graphic.elements-group"
    },
    "elements-bezierCurve.scaleX": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-bezierCurve.x\n[1]: #graphic.elements-bezierCurve.y\n[2]: #graphic.elements-bezierCurve.rotation\n[3]: #graphic.elements-bezierCurve.scaleX\n[4]: #graphic.elements-bezierCurve.scaleY\n[5]: #graphic.elements-bezierCurve.originX\n[6]: #graphic.elements-bezierCurve.originY\n[7]: #graphic.elements-group"
    },
    "elements-bezierCurve.scaleY": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-bezierCurve.x\n[1]: #graphic.elements-bezierCurve.y\n[2]: #graphic.elements-bezierCurve.rotation\n[3]: #graphic.elements-bezierCurve.scaleX\n[4]: #graphic.elements-bezierCurve.scaleY\n[5]: #graphic.elements-bezierCurve.originX\n[6]: #graphic.elements-bezierCurve.originY\n[7]: #graphic.elements-group"
    },
    "elements-bezierCurve.originX": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-bezierCurve.x\n[1]: #graphic.elements-bezierCurve.y\n[2]: #graphic.elements-bezierCurve.rotation\n[3]: #graphic.elements-bezierCurve.scaleX\n[4]: #graphic.elements-bezierCurve.scaleY\n[5]: #graphic.elements-bezierCurve.originX\n[6]: #graphic.elements-bezierCurve.originY\n[7]: #graphic.elements-group"
    },
    "elements-bezierCurve.originY": {
        "desc": " 图形元素可以进行标准的 2D transform，其中包含： \n\n* 平移（依照 [x][0] 和 [y][1]）：默认值都是 0。右和下为正值。\n* 旋转（依照 [rotation][2]）：默认值是 0。表示旋转的弧度值。正值表示逆时针旋转。\n* 缩放（依照 [scaleX][3] 和 [scaleY][4]）：默认值都是 1。这个值表示缩放的倍数。\n\n另外，[originX][5] 和 [originY][6] 指定了旋转和缩放的中心点，默认值都是 0。 注意： \n\n* transform 中设定的坐标，都是相对于图形元素的父元素的（即 [group][7] 元素或者顶层画布）的 [0, 0] 点。也就是说，我们可以使用 [group][7] 来组织多个图形元素，并且 [group][7] 可以嵌套。\n* 对于一个图形元素，transform 执行的顺序是：先缩放（依照 scaleX，scaleY），再旋转（依照 rotation），再平移（依照 x，y）。\n\n\n\n[0]: #graphic.elements-bezierCurve.x\n[1]: #graphic.elements-bezierCurve.y\n[2]: #graphic.elements-bezierCurve.rotation\n[3]: #graphic.elements-bezierCurve.scaleX\n[4]: #graphic.elements-bezierCurve.scaleY\n[5]: #graphic.elements-bezierCurve.originX\n[6]: #graphic.elements-bezierCurve.originY\n[7]: #graphic.elements-group"
    },
    "elements-bezierCurve.left": {
        "desc": " 描述怎么根据父元素进行定位。 『父元素』是指：如果是顶层元素，父元素是 echarts 图表容器。如果是 group 的子元素，父元素就是 group 元素。 值的类型可以是： \n\n* number：表示像素值。\n* 百分比值：如 '33%'，用父元素的高和此百分比计算出最终值。\n* 'center'：表示自动居中。\n\n[left][0] 和 [right][1] 只有一个可以生效。 如果指定 [left][0] 或 [right][1]，则 [shape][2] 里的 x、cx 等定位属性不再生效。\n\n[0]: #graphic.elements-bezierCurve.left\n[1]: #graphic.elements-bezierCurve.right\n[2]: #graphic.elements-bezierCurve.shape"
    },
    "elements-bezierCurve.right": {
        "desc": " 描述怎么根据父元素进行定位。 『父元素』是指：如果是顶层元素，父元素是 echarts 图表容器。如果是 group 的子元素，父元素就是 group 元素。 值的类型可以是： \n\n* number：表示像素值。\n* 百分比值：如 '33%'，用父元素的高和此百分比计算出最终值。\n* 'center'：表示自动居中。\n\n[left][0] 和 [right][1] 只有一个可以生效。 如果指定 [left][0] 或 [right][1]，则 [shape][2] 里的 x、cx 等定位属性不再生效。\n\n[0]: #graphic.elements-bezierCurve.left\n[1]: #graphic.elements-bezierCurve.right\n[2]: #graphic.elements-bezierCurve.shape"
    },
    "elements-bezierCurve.top": {
        "desc": " 描述怎么根据父元素进行定位。 『父元素』是指：如果是顶层元素，父元素是 echarts 图表容器。如果是 group 的子元素，父元素就是 group 元素。 值的类型可以是： \n\n* number：表示像素值。\n* 百分比值：如 '33%'，用父元素的宽和此百分比计算出最终值。\n* 'middle'：表示自动居中。\n\n[top][0] 和 [bottom][1] 只有一个可以生效。 如果指定 [top][0] 或 [bottom][1]，则 [shape][2] 里的 y、cy 等定位属性不再生效。\n\n[0]: #graphic.elements-bezierCurve.top\n[1]: #graphic.elements-bezierCurve.bottom\n[2]: #graphic.elements-bezierCurve.shape"
    },
    "elements-bezierCurve.bottom": {
        "desc": " 描述怎么根据父元素进行定位。 『父元素』是指：如果是顶层元素，父元素是 echarts 图表容器。如果是 group 的子元素，父元素就是 group 元素。 值的类型可以是： \n\n* number：表示像素值。\n* 百分比值：如 '33%'，用父元素的宽和此百分比计算出最终值。\n* 'middle'：表示自动居中。\n\n[top][0] 和 [bottom][1] 只有一个可以生效。 如果指定 [top][0] 或 [bottom][1]，则 [shape][2] 里的 y、cy 等定位属性不再生效。\n\n[0]: #graphic.elements-bezierCurve.top\n[1]: #graphic.elements-bezierCurve.bottom\n[2]: #graphic.elements-bezierCurve.shape"
    },
    "elements-bezierCurve.bounding": {
        "desc": " 决定此图形元素在定位时，对自身的包围盒计算方式。 参见例子： 暂时无法显示 可取值： \n\n* 'all'：（默认） 表示用自身以及子节点整体的经过 transform 后的包围盒进行定位。 这种方式易于使整体都限制在父元素范围中。\n* 'raw'： 表示仅仅用自身（不包括子节点）的没经过 tranform 的包围盒进行定位。 这种方式易于内容超出父元素范围的定位方式。\n\n"
    },
    "elements-bezierCurve.z": {
        "desc": " z 方向的高度，决定层叠关系。 "
    },
    "elements-bezierCurve.zlevel": {
        "desc": " 决定此元素绘制在哪个 canvas 层中。注意，越多 canvas 层会占用越多资源。 "
    },
    "elements-bezierCurve.info": {
        "desc": " 用户定义的任意数据，可以在 event listener 中访问，如： \n\n    chart.on('click', function (params) {\n        console.log(params.info);\n    });\n    \n\n"
    },
    "elements-bezierCurve.silent": {
        "desc": " 是否不响应鼠标以及触摸事件。 "
    },
    "elements-bezierCurve.invisible": {
        "desc": " 节点是否可见。 "
    },
    "elements-bezierCurve.ignore": {
        "desc": " 节点是否完全被忽略（既不渲染，也不响应事件）。 "
    },
    "elements-bezierCurve.textContent": {
        "desc": " 这是一个文本定义，附着在一个节点上，会依据 textConfig 配置，相对于节点布局。 里面的属性同于 [text][0]。\n\n[0]: option.html#graphic.elements-text"
    },
    "elements-bezierCurve.textConfig": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "elements-bezierCurve.textConfig.position": {
        "desc": " Position of textContent. \n\n* 'left'\n* 'right'\n* 'top'\n* 'bottom'\n* 'inside'\n* 'insideLeft'\n* 'insideRight'\n* 'insideTop'\n* 'insideBottom'\n* 'insideTopLeft'\n* 'insideTopRight'\n* 'insideBottomLeft'\n* 'insideBottomRight'\n* or like [12, 33]\n* or like ['50%', '50%']\n\n"
    },
    "elements-bezierCurve.textConfig.rotation": {
        "desc": "textContent 的旋转弧度。 "
    },
    "elements-bezierCurve.textConfig.layoutRect": {
        "desc": "textContent 根据此矩形来布局位置。 默认是节点的包围盒。 \n\n    {\n        x: number\n        y: number\n        width: number\n        height: number\n    }\n    \n\n"
    },
    "elements-bezierCurve.textConfig.offset": {
        "desc": "textContent 的偏移。 offset 和 position 的区别是，offset 是旋转（rotation）后计算。 "
    },
    "elements-bezierCurve.textConfig.origin": {
        "desc": "origin 相对于节点的包围盒。 可以是百分数。 如果指定为 'center'，则定位在包围盒中心。 只有当 position and rotation 都设置时，生效。 \n\n* 如 [12, 33]\n* 或如 ['50%', '50%']\n* 'center'\n\n"
    },
    "elements-bezierCurve.textConfig.distance": {
        "desc": " 距离 layoutRect 的距离。 "
    },
    "elements-bezierCurve.textConfig.local": {
        "desc": " 如果 true 的话，会采用节点的 transform。 "
    },
    "elements-bezierCurve.textConfig.insideFill": {
        "desc": "insideFill 可以是一个颜色字符串，或者空着。 如果 textContent 是 \"inside\"，它的 fill 会按这个优先级来选取： textContent.style.fill > textConfig.insideFill > \"auto-calculated-fill\" 在绝大多数场景下，\"auto-calculated-fill\" 是白色。 "
    },
    "elements-bezierCurve.textConfig.insideStroke": {
        "desc": "insideStroke 可以是一个颜色字符串，或者空着。 如果 textContent 是 \"inside\"，它的 stroke 会按这个优先级来选取： textContent.style.stroke > textConfig.insideStroke > \"auto-calculated-stroke\" \"auto-calculated-stroke\" 的规则是： \n\n* 如果\n  * (A) fill 在 style 中被指定（无论是在 textContent.style 还是 textContent.style.rich 里）\n  * 或者 (B) 需要画文字的背景（无论是定义在 textContent.style 还是 textContent.style.rich 里）\n  * \"auto-calculated-stroke\" 都会为 null。\n* 否则\n  * \"auto-calculated-stroke\" 会和节点的 fill 相同，如果 fill 没有的话则为 null。\n\n"
    },
    "elements-bezierCurve.textConfig.outsideFill": {
        "desc": "outsideFill 可以是一个颜色字符串，或者空着。 如果 textContent 是 \"inside\"，它的 fill 会按这个优先级来选取： textContent.style.fill > textConfig.outsideFill > #000 "
    },
    "elements-bezierCurve.textConfig.outsideStroke": {
        "desc": "outsideStroke 可以是一个颜色字符串，或者空着。 如果 textContent 不是 \"inside\"，它的 stroke 会按这个优先级来选取： textContent.style.stroke > textConfig.outsideStroke > \"auto-calculated-stroke\" \"auto-calculated-stroke\" 的规则是： \n\n* 如果\n  * (A) fill 在 style 中被指定（无论是在 textContent.style 还是 textContent.style.rich 里）\n  * 或者 (B) 需要画文字的背景（无论是定义在 textContent.style 还是 textContent.style.rich 里）\n  * \"auto-calculated-stroke\" 都会为 null。\n* 否则\n  * \"auto-calculated-stroke\" 会为一个近似于白色的颜色，来区别于背景。\n\n"
    },
    "elements-bezierCurve.textConfig.inside": {
        "desc": " 如果确定文本是在节点中的话，则此可设置为 true，避免 echarts 额外猜测。 "
    },
    "elements-bezierCurve.cursor": {
        "desc": " 鼠标悬浮时在图形元素上时鼠标的样式是什么。同 CSS 的 cursor。 ",
        "uiControl": {
            "type": "enum",
            "options": "auto,pointer,move",
            "default": "pointer"
        }
    },
    "elements-bezierCurve.draggable": {
        "desc": " 图形元素是否可以被拖拽。 "
    },
    "elements-bezierCurve.progressive": {
        "desc": " 是否渐进式渲染。当图形元素过多时才使用。 "
    },
    "elements-bezierCurve.shape": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "elements-bezierCurve.shape.x1": {
        "desc": " 开始点的 x 值。 "
    },
    "elements-bezierCurve.shape.y1": {
        "desc": " 开始点的 y 值。 "
    },
    "elements-bezierCurve.shape.x2": {
        "desc": " 结束点的 x 值。 "
    },
    "elements-bezierCurve.shape.y2": {
        "desc": " 结束点的 y 值。 "
    },
    "elements-bezierCurve.shape.cpx1": {
        "desc": " 控制点 x 值。 "
    },
    "elements-bezierCurve.shape.cpy1": {
        "desc": " 控制点 y 值。 "
    },
    "elements-bezierCurve.shape.cpx2": {
        "desc": " 第二个控制点 x 值。如果设置则开启三阶贝塞尔曲线。 "
    },
    "elements-bezierCurve.shape.cpy2": {
        "desc": " 第二个控制点 y 值。如果设置则开启三阶贝塞尔曲线。 "
    },
    "elements-bezierCurve.shape.percent": {
        "desc": " 画到百分之多少就不画了。值的范围：[0, 1]。 "
    },
    "elements-bezierCurve.style": {
        "desc": " 注：关于图形元素中更多的样式设置（例如 [富文本标签][0]），参见 [zrender/graphic/Displayable][1] 中的 style 相关属性。 注意，这里图形元素的样式属性名称直接源于 zrender，和 echarts label、echarts itemStyle 等处同样含义的样式属性名称或有不同。例如，有如下对应： \n\n* [itemStyle.color][2] => style.fill\n* [itemStyle.borderColor][2] => style.stroke\n* [label.color][2] => style.textFill\n* [label.textBorderColor][3] => style.textStroke\n* ...\n\n\n\n[0]: tutorial.html#%E5%AF%8C%E6%96%87%E6%9C%AC%E6%A0%87%E7%AD%BE\n[1]: https://ecomfe.github.io/zrender-doc/public/api.html#zrenderdisplayable\n[2]: #series-scatter.label.color\n[3]: #series-scatter.label.textBorderColor"
    },
    "elements-bezierCurve.style.fill": {
        "desc": " 填充色。 "
    },
    "elements-bezierCurve.style.stroke": {
        "desc": " 笔画颜色。 "
    },
    "elements-bezierCurve.style.lineWidth": {
        "desc": " 笔画宽度。 "
    },
    "elements-bezierCurve.style.shadowBlur": {
        "desc": " 阴影宽度。 "
    },
    "elements-bezierCurve.style.shadowOffsetX": {
        "desc": " 阴影 X 方向偏移。 "
    },
    "elements-bezierCurve.style.shadowOffsetY": {
        "desc": " 阴影 Y 方向偏移。 "
    },
    "elements-bezierCurve.style.shadowColor": {
        "desc": " 阴影颜色。 "
    },
    "elements-bezierCurve.focus": {
        "desc": ">  从 > v5.0.0>  开始支持 在高亮图形时，是否淡出其它数据的图形已达到聚焦的效果。支持如下配置： \n\n* 'none' 不淡出其它图形，默认使用该配置。\n* 'self' 只聚焦（不淡出）当前高亮的数据的图形。\n* 'series' 聚焦当前高亮的数据所在的系列的所有图形。\n\n"
    },
    "elements-bezierCurve.blurScope": {
        "desc": ">  从 > v5.0.0>  开始支持 在开启focus的时候，可以通过blurScope配置淡出的范围。支持如下配置 \n\n* 'coordinateSystem' 淡出范围为坐标系，默认使用该配置。\n* 'series' 淡出范围为系列。\n* 'global' 淡出范围为全局。\n\n"
    }
}