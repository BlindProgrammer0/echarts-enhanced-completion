{
    "id": {
        "desc": " Component ID, not specified by default. If specified, it can be used to refer the component in option or API. ",
        "uiControl": {
            "type": "string"
        }
    },
    "elements": {
        "desc": " A list of all graphic elements. Note, the standard configuration of graphic component is: \n\n    {\n        graphic: {\n            elements: [\n                {type: 'rect', ...}, {type: 'circle', ...}, ...\n            ]\n        }\n    }\n    \n\nBut we always use short patterns for convenience: \n\n    {\n        graphic: { // Declare only one graphic element.\n            type: 'rect',\n            ...\n        }\n    }\n    \n\nOr: \n\n    {\n        graphic: [ // Declare multiple graphic elements.\n            {type: 'rect', ...}, {type: 'circle', ...}, ...\n        ]\n    }\n    \n\n",
        "uiControl": {
            "type": "Array"
        }
    },
    "elements-group": {
        "desc": "group is the only type that can contain children, so that a group of elements can be positioned and transformed together. "
    },
    "elements-group.type": {
        "desc": " Must be specified when define a graphic element at the first time. Optional values: [image][0], [text][1], [circle][2], [sector][3], [ring][4], [polygon][5], [polyline][6], [rect][7], [line][8], [bezierCurve][9], [arc][10], [group][11],\n\n[0]: #graphic.elements-image\n[1]: #graphic.elements-text\n[2]: #graphic.elements-circle\n[3]: #graphic.elements-sector\n[4]: #graphic.elements-ring\n[5]: #graphic.elements-polygon\n[6]: #graphic.elements-polyline\n[7]: #graphic.elements-rect\n[8]: #graphic.elements-line\n[9]: #graphic.elements-bezierCurve\n[10]: #graphic.elements-arc\n[11]: #graphic.elements-group"
    },
    "elements-group.id": {
        "desc": " id is used to specifying element when willing to update it. id can be ignored if you do not need it. "
    },
    "elements-group.$action": {
        "desc": " Specify the operation should be performed to the element when calling setOption. Default value is 'merge', other values can be 'replace' or 'remove'. Optional values: \n\n* 'merge': merge the given option to existing element (if any), otherwise create a new element.\n* 'replace': create a new element according to the given option and replace the existing element (if any).\n* 'remove': delete the existing element (if any).\n\n"
    },
    "elements-group.x": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-group.x\n[1]: #graphic.elements-group.y\n[2]: #graphic.elements-group.rotation\n[3]: #graphic.elements-group.scaleX\n[4]: #graphic.elements-group.scaleY\n[5]: #graphic.elements-group.originX\n[6]: #graphic.elements-group.originY\n[7]: #graphic.elements-group"
    },
    "elements-group.y": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-group.x\n[1]: #graphic.elements-group.y\n[2]: #graphic.elements-group.rotation\n[3]: #graphic.elements-group.scaleX\n[4]: #graphic.elements-group.scaleY\n[5]: #graphic.elements-group.originX\n[6]: #graphic.elements-group.originY\n[7]: #graphic.elements-group"
    },
    "elements-group.rotation": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-group.x\n[1]: #graphic.elements-group.y\n[2]: #graphic.elements-group.rotation\n[3]: #graphic.elements-group.scaleX\n[4]: #graphic.elements-group.scaleY\n[5]: #graphic.elements-group.originX\n[6]: #graphic.elements-group.originY\n[7]: #graphic.elements-group"
    },
    "elements-group.scaleX": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-group.x\n[1]: #graphic.elements-group.y\n[2]: #graphic.elements-group.rotation\n[3]: #graphic.elements-group.scaleX\n[4]: #graphic.elements-group.scaleY\n[5]: #graphic.elements-group.originX\n[6]: #graphic.elements-group.originY\n[7]: #graphic.elements-group"
    },
    "elements-group.scaleY": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-group.x\n[1]: #graphic.elements-group.y\n[2]: #graphic.elements-group.rotation\n[3]: #graphic.elements-group.scaleX\n[4]: #graphic.elements-group.scaleY\n[5]: #graphic.elements-group.originX\n[6]: #graphic.elements-group.originY\n[7]: #graphic.elements-group"
    },
    "elements-group.originX": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-group.x\n[1]: #graphic.elements-group.y\n[2]: #graphic.elements-group.rotation\n[3]: #graphic.elements-group.scaleX\n[4]: #graphic.elements-group.scaleY\n[5]: #graphic.elements-group.originX\n[6]: #graphic.elements-group.originY\n[7]: #graphic.elements-group"
    },
    "elements-group.originY": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-group.x\n[1]: #graphic.elements-group.y\n[2]: #graphic.elements-group.rotation\n[3]: #graphic.elements-group.scaleX\n[4]: #graphic.elements-group.scaleY\n[5]: #graphic.elements-group.originX\n[6]: #graphic.elements-group.originY\n[7]: #graphic.elements-group"
    },
    "elements-group.left": {
        "desc": " Specify how to be positioned in its parent. When the element is at the top level, the parent is the container of the chart instance. Otherwise, the parent is a group element. Optional values: \n\n* Pixel value: For example, can be a number 30, means 30px.\n* Percent value: For example, can be a string '33%', means the final result should be calculated by this value and the height of its parent.\n* 'center': means position the element in the middle of according to its parent.\n\nOnly one between [left][0] and [right][1] can work. If [left][0] or [right][1] is specified, positioning attributes in [shape][2] (like x, cx) will not work.\n\n[0]: #graphic.elements-group.left\n[1]: #graphic.elements-group.right\n[2]: #graphic.elements-group.shape"
    },
    "elements-group.right": {
        "desc": " Specify how to be positioned in its parent. When the element is at the top level, the parent is the container of the chart instance. Otherwise, the parent is a group element. Optional values: \n\n* Pixel value: For example, can be a number 30, means 30px.\n* Percent value: For example, can be a string '33%', means the final result should be calculated by this value and the height of its parent.\n* 'center': means position the element in the middle of according to its parent.\n\nOnly one between [left][0] and [right][1] can work. If [left][0] or [right][1] is specified, positioning attributes in [shape][2] (like x, cx) will not work.\n\n[0]: #graphic.elements-group.left\n[1]: #graphic.elements-group.right\n[2]: #graphic.elements-group.shape"
    },
    "elements-group.top": {
        "desc": " Specify how to be positioned in its parent. When the element is at the top level, the parent is the container of the chart instance. Otherwise, the parent is a group element. Optional values: \n\n* Pixel value: For example, can be a number 30, means 30px.\n* Percent value: For example, can be a string '33%', means the final result should be calculated by this value and the width of its parent.\n* 'middle': means position the element in the middle of according to its parent.\n\nOnly one between [top][0] and [bottom][1] can work. If [top][0] or [bottom][1] is specified, positioning attributes in [shape][2] (like y, cy) will not work.\n\n[0]: #graphic.elements-group.top\n[1]: #graphic.elements-group.bottom\n[2]: #graphic.elements-group.shape"
    },
    "elements-group.bottom": {
        "desc": " Specify how to be positioned in its parent. When the element is at the top level, the parent is the container of the chart instance. Otherwise, the parent is a group element. Optional values: \n\n* Pixel value: For example, can be a number 30, means 30px.\n* Percent value: For example, can be a string '33%', means the final result should be calculated by this value and the width of its parent.\n* 'middle': means position the element in the middle of according to its parent.\n\nOnly one between [top][0] and [bottom][1] can work. If [top][0] or [bottom][1] is specified, positioning attributes in [shape][2] (like y, cy) will not work.\n\n[0]: #graphic.elements-group.top\n[1]: #graphic.elements-group.bottom\n[2]: #graphic.elements-group.shape"
    },
    "elements-group.bounding": {
        "desc": " Used to specify whether the entire transformed element (containing children if is group) is confined in its container. See sample: 暂时无法显示 Optional values: \n\n* 'all': (default) Use the transformed bounding box of itself and its descendants to perform position calculation, which confine the entire body in the boundary of its parent.\n* 'raw': Only use the untransformed bounding box of itself (without its descentant) to perform position calculation, which is suitable when the content in the element need to be overflow its parent.\n\n"
    },
    "elements-group.z": {
        "desc": " z value of the elements, determine the overlap order. "
    },
    "elements-group.zlevel": {
        "desc": " Determine which canvas layer this element should be in. Notice: Multiple canvas layer may affect performance. "
    },
    "elements-group.info": {
        "desc": " User defined data, can be visited in event listeners. \n\n    chart.on('click', function (params) {\n        console.log(params.info);\n    });\n    \n\n"
    },
    "elements-group.silent": {
        "desc": " Whether response to mouse events / touch events. "
    },
    "elements-group.invisible": {
        "desc": " Whether the element is visible. "
    },
    "elements-group.ignore": {
        "desc": " Whether the element is totally ignored (neither render nor listen events). "
    },
    "elements-group.textContent": {
        "desc": " Text block attached to an element and layout based on the element by textConfig. The props the the same as [text][0].\n\n[0]: option.html#graphic.elements-text"
    },
    "elements-group.textConfig": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "elements-group.textConfig.position": {
        "desc": " Position of textContent. \n\n* 'left'\n* 'right'\n* 'top'\n* 'bottom'\n* 'inside'\n* 'insideLeft'\n* 'insideRight'\n* 'insideTop'\n* 'insideBottom'\n* 'insideTopLeft'\n* 'insideTopRight'\n* 'insideBottomLeft'\n* 'insideBottomRight'\n* or like [12, 33]\n* or like ['50%', '50%']\n\n"
    },
    "elements-group.textConfig.rotation": {
        "desc": " Rotation of textContent. In radian. "
    },
    "elements-group.textConfig.layoutRect": {
        "desc": " Rect that textContent will be positioned. Default to be the bounding box of host element. \n\n    {\n        x: number\n        y: number\n        width: number\n        height: number\n    }\n    \n\n"
    },
    "elements-group.textConfig.offset": {
        "desc": " Offset of the textContent. The difference of offset and position is that offset will be applied in the rotation. "
    },
    "elements-group.textConfig.origin": {
        "desc": "origin is relative to the bounding box of the host element. Can be percent value. Relative to the bounding box. If 'center' specified, it will be center of the bounding box. Only available when position and rotation are both set. \n\n* like [12, 33]\n* or like ['50%', '50%']\n* 'center'\n\n"
    },
    "elements-group.textConfig.distance": {
        "desc": " Distance to the layoutRect。 "
    },
    "elements-group.textConfig.local": {
        "desc": " If true, it will apply host's transform. "
    },
    "elements-group.textConfig.insideFill": {
        "desc": "insideFill is a color string or left empty. If a textContent is \"inside\", its final fill will be picked by this priority: textContent.style.fill > textConfig.insideFill > \"auto-calculated-fill\" In most cases, \"auto-calculated-fill\" is white. "
    },
    "elements-group.textConfig.insideStroke": {
        "desc": "insideStroke is a color string or left empty. If a textContent is \"inside\", its final stroke will be picked by this priority: textContent.style.stroke > textConfig.insideStroke > \"auto-calculated-stroke\" The rule of getting \"auto-calculated-stroke\": \n\n* If\n  * (A) the fill is specified in style (either in textContent.style or textContent.style.rich)\n  * or (B) needed to draw text background (either defined in textContent.style or textContent.style.rich)\n  * \"auto-calculated-stroke\" will be null.\n* Otherwise\n  * \"auto-calculated-stroke\" will be the same as fill of this element if possible, or null.\n\n"
    },
    "elements-group.textConfig.outsideFill": {
        "desc": "outsideFill is a color string or left empty. If a textContent is \"inside\", its final fill will be picked by this priority: textContent.style.fill > textConfig.outsideFill > #000 "
    },
    "elements-group.textConfig.outsideStroke": {
        "desc": "outsideStroke is a color string or left empty. If a textContent is not \"inside\", its final stroke will be picked by this priority: textContent.style.stroke > textConfig.outsideStroke > \"auto-calculated-stroke\" The rule of getting \"auto-calculated-stroke\": \n\n* If\n  * (A) the fill is specified in style (either in textContent.style or textContent.style.rich)\n  * or (B) needed to draw text background (either defined in textContent.style or textContent.style.rich)\n  * \"auto-calculated-stroke\" will be null.\n* Otherwise\n  * \"auto-calculated-stroke\" will be a near white color to distinguish \"front end\" label with messy background (like other text label, line or other graphic).\n\n"
    },
    "elements-group.textConfig.inside": {
        "desc": " Tell echarts that I can make sure this text is inside or not. "
    },
    "elements-group.cursor": {
        "desc": " The mouse style when mouse hovers on an element, the same as cursor property in CSS. ",
        "uiControl": {
            "type": "enum",
            "options": "'auto','pointer','move'"
        }
    },
    "elements-group.draggable": {
        "desc": " Can be dragged or not. "
    },
    "elements-group.progressive": {
        "desc": " Whether use progressive render to improve performance. Usually used when number of element is too large. "
    },
    "elements-group.width": {
        "desc": " Specify width of this group. This width is only used for the positioning of its children. When width is 0, children can also be positioned according to its parent using left: 'center'. "
    },
    "elements-group.height": {
        "desc": " Specify height of this group. This height is only used for the positioning of its children. When height is 0, children can also be positioned according to its parent using top: 'middle'. "
    },
    "elements-group.diffChildrenByName": {
        "desc": " In [custom series][0], when diffChildrenByName is set as true, for each [group][1] returned from [renderItem][2], \"diff\" will be performed to its [children][3] according to the [name][4] attribute of each graphic elements. Here \"diff\" means that map the coming graphic elements to the existing graphic elements when repainting according to name, which enables the transition animation if data is modified. But notice that the operation is performance consuming, do not use it for large data amount.\n\n[0]: #series-custom\n[1]: #graphic.elements-group\n[2]: #series-custom.renderItem\n[3]: #graphic.elements-group.children\n[4]: #graphic.elements-polygon.name"
    },
    "elements-group.children": {
        "desc": " A list of children, each item is a declaration of an element. "
    },
    "elements-image": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "elements-image.type": {
        "desc": " Must be specified when define a graphic element at the first time. Optional values: [image][0], [text][1], [circle][2], [sector][3], [ring][4], [polygon][5], [polyline][6], [rect][7], [line][8], [bezierCurve][9], [arc][10], [group][11],\n\n[0]: #graphic.elements-image\n[1]: #graphic.elements-text\n[2]: #graphic.elements-circle\n[3]: #graphic.elements-sector\n[4]: #graphic.elements-ring\n[5]: #graphic.elements-polygon\n[6]: #graphic.elements-polyline\n[7]: #graphic.elements-rect\n[8]: #graphic.elements-line\n[9]: #graphic.elements-bezierCurve\n[10]: #graphic.elements-arc\n[11]: #graphic.elements-group"
    },
    "elements-image.id": {
        "desc": " id is used to specifying element when willing to update it. id can be ignored if you do not need it. "
    },
    "elements-image.$action": {
        "desc": " Specify the operation should be performed to the element when calling setOption. Default value is 'merge', other values can be 'replace' or 'remove'. Optional values: \n\n* 'merge': merge the given option to existing element (if any), otherwise create a new element.\n* 'replace': create a new element according to the given option and replace the existing element (if any).\n* 'remove': delete the existing element (if any).\n\n"
    },
    "elements-image.x": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-image.x\n[1]: #graphic.elements-image.y\n[2]: #graphic.elements-image.rotation\n[3]: #graphic.elements-image.scaleX\n[4]: #graphic.elements-image.scaleY\n[5]: #graphic.elements-image.originX\n[6]: #graphic.elements-image.originY\n[7]: #graphic.elements-group"
    },
    "elements-image.y": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-image.x\n[1]: #graphic.elements-image.y\n[2]: #graphic.elements-image.rotation\n[3]: #graphic.elements-image.scaleX\n[4]: #graphic.elements-image.scaleY\n[5]: #graphic.elements-image.originX\n[6]: #graphic.elements-image.originY\n[7]: #graphic.elements-group"
    },
    "elements-image.rotation": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-image.x\n[1]: #graphic.elements-image.y\n[2]: #graphic.elements-image.rotation\n[3]: #graphic.elements-image.scaleX\n[4]: #graphic.elements-image.scaleY\n[5]: #graphic.elements-image.originX\n[6]: #graphic.elements-image.originY\n[7]: #graphic.elements-group"
    },
    "elements-image.scaleX": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-image.x\n[1]: #graphic.elements-image.y\n[2]: #graphic.elements-image.rotation\n[3]: #graphic.elements-image.scaleX\n[4]: #graphic.elements-image.scaleY\n[5]: #graphic.elements-image.originX\n[6]: #graphic.elements-image.originY\n[7]: #graphic.elements-group"
    },
    "elements-image.scaleY": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-image.x\n[1]: #graphic.elements-image.y\n[2]: #graphic.elements-image.rotation\n[3]: #graphic.elements-image.scaleX\n[4]: #graphic.elements-image.scaleY\n[5]: #graphic.elements-image.originX\n[6]: #graphic.elements-image.originY\n[7]: #graphic.elements-group"
    },
    "elements-image.originX": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-image.x\n[1]: #graphic.elements-image.y\n[2]: #graphic.elements-image.rotation\n[3]: #graphic.elements-image.scaleX\n[4]: #graphic.elements-image.scaleY\n[5]: #graphic.elements-image.originX\n[6]: #graphic.elements-image.originY\n[7]: #graphic.elements-group"
    },
    "elements-image.originY": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-image.x\n[1]: #graphic.elements-image.y\n[2]: #graphic.elements-image.rotation\n[3]: #graphic.elements-image.scaleX\n[4]: #graphic.elements-image.scaleY\n[5]: #graphic.elements-image.originX\n[6]: #graphic.elements-image.originY\n[7]: #graphic.elements-group"
    },
    "elements-image.left": {
        "desc": " Specify how to be positioned in its parent. When the element is at the top level, the parent is the container of the chart instance. Otherwise, the parent is a group element. Optional values: \n\n* Pixel value: For example, can be a number 30, means 30px.\n* Percent value: For example, can be a string '33%', means the final result should be calculated by this value and the height of its parent.\n* 'center': means position the element in the middle of according to its parent.\n\nOnly one between [left][0] and [right][1] can work. If [left][0] or [right][1] is specified, positioning attributes in [shape][2] (like x, cx) will not work.\n\n[0]: #graphic.elements-image.left\n[1]: #graphic.elements-image.right\n[2]: #graphic.elements-image.shape"
    },
    "elements-image.right": {
        "desc": " Specify how to be positioned in its parent. When the element is at the top level, the parent is the container of the chart instance. Otherwise, the parent is a group element. Optional values: \n\n* Pixel value: For example, can be a number 30, means 30px.\n* Percent value: For example, can be a string '33%', means the final result should be calculated by this value and the height of its parent.\n* 'center': means position the element in the middle of according to its parent.\n\nOnly one between [left][0] and [right][1] can work. If [left][0] or [right][1] is specified, positioning attributes in [shape][2] (like x, cx) will not work.\n\n[0]: #graphic.elements-image.left\n[1]: #graphic.elements-image.right\n[2]: #graphic.elements-image.shape"
    },
    "elements-image.top": {
        "desc": " Specify how to be positioned in its parent. When the element is at the top level, the parent is the container of the chart instance. Otherwise, the parent is a group element. Optional values: \n\n* Pixel value: For example, can be a number 30, means 30px.\n* Percent value: For example, can be a string '33%', means the final result should be calculated by this value and the width of its parent.\n* 'middle': means position the element in the middle of according to its parent.\n\nOnly one between [top][0] and [bottom][1] can work. If [top][0] or [bottom][1] is specified, positioning attributes in [shape][2] (like y, cy) will not work.\n\n[0]: #graphic.elements-image.top\n[1]: #graphic.elements-image.bottom\n[2]: #graphic.elements-image.shape"
    },
    "elements-image.bottom": {
        "desc": " Specify how to be positioned in its parent. When the element is at the top level, the parent is the container of the chart instance. Otherwise, the parent is a group element. Optional values: \n\n* Pixel value: For example, can be a number 30, means 30px.\n* Percent value: For example, can be a string '33%', means the final result should be calculated by this value and the width of its parent.\n* 'middle': means position the element in the middle of according to its parent.\n\nOnly one between [top][0] and [bottom][1] can work. If [top][0] or [bottom][1] is specified, positioning attributes in [shape][2] (like y, cy) will not work.\n\n[0]: #graphic.elements-image.top\n[1]: #graphic.elements-image.bottom\n[2]: #graphic.elements-image.shape"
    },
    "elements-image.bounding": {
        "desc": " Used to specify whether the entire transformed element (containing children if is group) is confined in its container. See sample: 暂时无法显示 Optional values: \n\n* 'all': (default) Use the transformed bounding box of itself and its descendants to perform position calculation, which confine the entire body in the boundary of its parent.\n* 'raw': Only use the untransformed bounding box of itself (without its descentant) to perform position calculation, which is suitable when the content in the element need to be overflow its parent.\n\n"
    },
    "elements-image.z": {
        "desc": " z value of the elements, determine the overlap order. "
    },
    "elements-image.zlevel": {
        "desc": " Determine which canvas layer this element should be in. Notice: Multiple canvas layer may affect performance. "
    },
    "elements-image.info": {
        "desc": " User defined data, can be visited in event listeners. \n\n    chart.on('click', function (params) {\n        console.log(params.info);\n    });\n    \n\n"
    },
    "elements-image.silent": {
        "desc": " Whether response to mouse events / touch events. "
    },
    "elements-image.invisible": {
        "desc": " Whether the element is visible. "
    },
    "elements-image.ignore": {
        "desc": " Whether the element is totally ignored (neither render nor listen events). "
    },
    "elements-image.textContent": {
        "desc": " Text block attached to an element and layout based on the element by textConfig. The props the the same as [text][0].\n\n[0]: option.html#graphic.elements-text"
    },
    "elements-image.textConfig": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "elements-image.textConfig.position": {
        "desc": " Position of textContent. \n\n* 'left'\n* 'right'\n* 'top'\n* 'bottom'\n* 'inside'\n* 'insideLeft'\n* 'insideRight'\n* 'insideTop'\n* 'insideBottom'\n* 'insideTopLeft'\n* 'insideTopRight'\n* 'insideBottomLeft'\n* 'insideBottomRight'\n* or like [12, 33]\n* or like ['50%', '50%']\n\n"
    },
    "elements-image.textConfig.rotation": {
        "desc": " Rotation of textContent. In radian. "
    },
    "elements-image.textConfig.layoutRect": {
        "desc": " Rect that textContent will be positioned. Default to be the bounding box of host element. \n\n    {\n        x: number\n        y: number\n        width: number\n        height: number\n    }\n    \n\n"
    },
    "elements-image.textConfig.offset": {
        "desc": " Offset of the textContent. The difference of offset and position is that offset will be applied in the rotation. "
    },
    "elements-image.textConfig.origin": {
        "desc": "origin is relative to the bounding box of the host element. Can be percent value. Relative to the bounding box. If 'center' specified, it will be center of the bounding box. Only available when position and rotation are both set. \n\n* like [12, 33]\n* or like ['50%', '50%']\n* 'center'\n\n"
    },
    "elements-image.textConfig.distance": {
        "desc": " Distance to the layoutRect。 "
    },
    "elements-image.textConfig.local": {
        "desc": " If true, it will apply host's transform. "
    },
    "elements-image.textConfig.insideFill": {
        "desc": "insideFill is a color string or left empty. If a textContent is \"inside\", its final fill will be picked by this priority: textContent.style.fill > textConfig.insideFill > \"auto-calculated-fill\" In most cases, \"auto-calculated-fill\" is white. "
    },
    "elements-image.textConfig.insideStroke": {
        "desc": "insideStroke is a color string or left empty. If a textContent is \"inside\", its final stroke will be picked by this priority: textContent.style.stroke > textConfig.insideStroke > \"auto-calculated-stroke\" The rule of getting \"auto-calculated-stroke\": \n\n* If\n  * (A) the fill is specified in style (either in textContent.style or textContent.style.rich)\n  * or (B) needed to draw text background (either defined in textContent.style or textContent.style.rich)\n  * \"auto-calculated-stroke\" will be null.\n* Otherwise\n  * \"auto-calculated-stroke\" will be the same as fill of this element if possible, or null.\n\n"
    },
    "elements-image.textConfig.outsideFill": {
        "desc": "outsideFill is a color string or left empty. If a textContent is \"inside\", its final fill will be picked by this priority: textContent.style.fill > textConfig.outsideFill > #000 "
    },
    "elements-image.textConfig.outsideStroke": {
        "desc": "outsideStroke is a color string or left empty. If a textContent is not \"inside\", its final stroke will be picked by this priority: textContent.style.stroke > textConfig.outsideStroke > \"auto-calculated-stroke\" The rule of getting \"auto-calculated-stroke\": \n\n* If\n  * (A) the fill is specified in style (either in textContent.style or textContent.style.rich)\n  * or (B) needed to draw text background (either defined in textContent.style or textContent.style.rich)\n  * \"auto-calculated-stroke\" will be null.\n* Otherwise\n  * \"auto-calculated-stroke\" will be a near white color to distinguish \"front end\" label with messy background (like other text label, line or other graphic).\n\n"
    },
    "elements-image.textConfig.inside": {
        "desc": " Tell echarts that I can make sure this text is inside or not. "
    },
    "elements-image.cursor": {
        "desc": " The mouse style when mouse hovers on an element, the same as cursor property in CSS. ",
        "uiControl": {
            "type": "enum",
            "options": "'auto','pointer','move'"
        }
    },
    "elements-image.draggable": {
        "desc": " Can be dragged or not. "
    },
    "elements-image.progressive": {
        "desc": " Whether use progressive render to improve performance. Usually used when number of element is too large. "
    },
    "elements-image.style": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "elements-image.style.image": {
        "desc": " Specify content of the image, can be a URL, or [dataURI][0].\n\n[0]: https://tools.ietf.org/html/rfc2397"
    },
    "elements-image.style.x": {
        "desc": " The x value of the left-top corner of the element in the coordinate system of its parent. "
    },
    "elements-image.style.y": {
        "desc": " The y value of the left-top corner of the element in the coordinate system of its parent. "
    },
    "elements-image.style.width": {
        "desc": " The width of the shape of the element. "
    },
    "elements-image.style.height": {
        "desc": " The height of the shape of the element. More attributes in style (for example, [rich text][0]), see the style related attributes in [zrender/graphic/Displayable][1]. Notice, the attribute names of the style of graphic elements is derived from zrender, which may be different from the attribute names in echarts label, echarts itemStyle, etc., although they have the same meaning. For example: \n\n* [itemStyle.color][2] => style.fill\n* [itemStyle.borderColor][2] => style.stroke\n* [label.color][2] => style.textFill\n* [label.textBorderColor][3] => style.textStroke\n* ...\n\n\n\n[0]: tutorial.html#Rich%20Text\n[1]: https://ecomfe.github.io/zrender-doc/public/api.html#zrenderdisplayable\n[2]: #series-scatter.label.color\n[3]: #series-scatter.label.textBorderColor"
    },
    "elements-image.style.fill": {
        "desc": " Color filled in this element. "
    },
    "elements-image.style.stroke": {
        "desc": " Color of stroke. "
    },
    "elements-image.style.lineWidth": {
        "desc": " Width of stroke. "
    },
    "elements-image.style.shadowBlur": {
        "desc": " Width of shadow. "
    },
    "elements-image.style.shadowOffsetX": {
        "desc": " X offset of shadow. "
    },
    "elements-image.style.shadowOffsetY": {
        "desc": " Y offset of shadow. "
    },
    "elements-image.style.shadowColor": {
        "desc": " color of shadow. "
    },
    "elements-image.focus": {
        "desc": ">  Since > v5.0.0 When it's highlighted, whether to fade out of other data to focus the highlighted. The following configurations are supported: \n\n* 'none' Do not fade out other data, it's by default.\n* 'self' Only focus (not fade out) the element of the currently highlighted data.\n* 'series' Focus on all elements of the series which the currently highlighted data belongs to.\n\n"
    },
    "elements-image.blurScope": {
        "desc": ">  Since > v5.0.0 The range of fade out when focus is enabled. Support the following configurations \n\n* 'coordinateSystem'\n* 'series'\n* 'global'\n\n"
    },
    "elements-text": {
        "desc": " Text block. "
    },
    "elements-text.type": {
        "desc": " Must be specified when define a graphic element at the first time. Optional values: [image][0], [text][1], [circle][2], [sector][3], [ring][4], [polygon][5], [polyline][6], [rect][7], [line][8], [bezierCurve][9], [arc][10], [group][11],\n\n[0]: #graphic.elements-image\n[1]: #graphic.elements-text\n[2]: #graphic.elements-circle\n[3]: #graphic.elements-sector\n[4]: #graphic.elements-ring\n[5]: #graphic.elements-polygon\n[6]: #graphic.elements-polyline\n[7]: #graphic.elements-rect\n[8]: #graphic.elements-line\n[9]: #graphic.elements-bezierCurve\n[10]: #graphic.elements-arc\n[11]: #graphic.elements-group"
    },
    "elements-text.id": {
        "desc": " id is used to specifying element when willing to update it. id can be ignored if you do not need it. "
    },
    "elements-text.$action": {
        "desc": " Specify the operation should be performed to the element when calling setOption. Default value is 'merge', other values can be 'replace' or 'remove'. Optional values: \n\n* 'merge': merge the given option to existing element (if any), otherwise create a new element.\n* 'replace': create a new element according to the given option and replace the existing element (if any).\n* 'remove': delete the existing element (if any).\n\n"
    },
    "elements-text.x": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-text.x\n[1]: #graphic.elements-text.y\n[2]: #graphic.elements-text.rotation\n[3]: #graphic.elements-text.scaleX\n[4]: #graphic.elements-text.scaleY\n[5]: #graphic.elements-text.originX\n[6]: #graphic.elements-text.originY\n[7]: #graphic.elements-group"
    },
    "elements-text.y": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-text.x\n[1]: #graphic.elements-text.y\n[2]: #graphic.elements-text.rotation\n[3]: #graphic.elements-text.scaleX\n[4]: #graphic.elements-text.scaleY\n[5]: #graphic.elements-text.originX\n[6]: #graphic.elements-text.originY\n[7]: #graphic.elements-group"
    },
    "elements-text.rotation": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-text.x\n[1]: #graphic.elements-text.y\n[2]: #graphic.elements-text.rotation\n[3]: #graphic.elements-text.scaleX\n[4]: #graphic.elements-text.scaleY\n[5]: #graphic.elements-text.originX\n[6]: #graphic.elements-text.originY\n[7]: #graphic.elements-group"
    },
    "elements-text.scaleX": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-text.x\n[1]: #graphic.elements-text.y\n[2]: #graphic.elements-text.rotation\n[3]: #graphic.elements-text.scaleX\n[4]: #graphic.elements-text.scaleY\n[5]: #graphic.elements-text.originX\n[6]: #graphic.elements-text.originY\n[7]: #graphic.elements-group"
    },
    "elements-text.scaleY": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-text.x\n[1]: #graphic.elements-text.y\n[2]: #graphic.elements-text.rotation\n[3]: #graphic.elements-text.scaleX\n[4]: #graphic.elements-text.scaleY\n[5]: #graphic.elements-text.originX\n[6]: #graphic.elements-text.originY\n[7]: #graphic.elements-group"
    },
    "elements-text.originX": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-text.x\n[1]: #graphic.elements-text.y\n[2]: #graphic.elements-text.rotation\n[3]: #graphic.elements-text.scaleX\n[4]: #graphic.elements-text.scaleY\n[5]: #graphic.elements-text.originX\n[6]: #graphic.elements-text.originY\n[7]: #graphic.elements-group"
    },
    "elements-text.originY": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-text.x\n[1]: #graphic.elements-text.y\n[2]: #graphic.elements-text.rotation\n[3]: #graphic.elements-text.scaleX\n[4]: #graphic.elements-text.scaleY\n[5]: #graphic.elements-text.originX\n[6]: #graphic.elements-text.originY\n[7]: #graphic.elements-group"
    },
    "elements-text.left": {
        "desc": " Specify how to be positioned in its parent. When the element is at the top level, the parent is the container of the chart instance. Otherwise, the parent is a group element. Optional values: \n\n* Pixel value: For example, can be a number 30, means 30px.\n* Percent value: For example, can be a string '33%', means the final result should be calculated by this value and the height of its parent.\n* 'center': means position the element in the middle of according to its parent.\n\nOnly one between [left][0] and [right][1] can work. If [left][0] or [right][1] is specified, positioning attributes in [shape][2] (like x, cx) will not work.\n\n[0]: #graphic.elements-text.left\n[1]: #graphic.elements-text.right\n[2]: #graphic.elements-text.shape"
    },
    "elements-text.right": {
        "desc": " Specify how to be positioned in its parent. When the element is at the top level, the parent is the container of the chart instance. Otherwise, the parent is a group element. Optional values: \n\n* Pixel value: For example, can be a number 30, means 30px.\n* Percent value: For example, can be a string '33%', means the final result should be calculated by this value and the height of its parent.\n* 'center': means position the element in the middle of according to its parent.\n\nOnly one between [left][0] and [right][1] can work. If [left][0] or [right][1] is specified, positioning attributes in [shape][2] (like x, cx) will not work.\n\n[0]: #graphic.elements-text.left\n[1]: #graphic.elements-text.right\n[2]: #graphic.elements-text.shape"
    },
    "elements-text.top": {
        "desc": " Specify how to be positioned in its parent. When the element is at the top level, the parent is the container of the chart instance. Otherwise, the parent is a group element. Optional values: \n\n* Pixel value: For example, can be a number 30, means 30px.\n* Percent value: For example, can be a string '33%', means the final result should be calculated by this value and the width of its parent.\n* 'middle': means position the element in the middle of according to its parent.\n\nOnly one between [top][0] and [bottom][1] can work. If [top][0] or [bottom][1] is specified, positioning attributes in [shape][2] (like y, cy) will not work.\n\n[0]: #graphic.elements-text.top\n[1]: #graphic.elements-text.bottom\n[2]: #graphic.elements-text.shape"
    },
    "elements-text.bottom": {
        "desc": " Specify how to be positioned in its parent. When the element is at the top level, the parent is the container of the chart instance. Otherwise, the parent is a group element. Optional values: \n\n* Pixel value: For example, can be a number 30, means 30px.\n* Percent value: For example, can be a string '33%', means the final result should be calculated by this value and the width of its parent.\n* 'middle': means position the element in the middle of according to its parent.\n\nOnly one between [top][0] and [bottom][1] can work. If [top][0] or [bottom][1] is specified, positioning attributes in [shape][2] (like y, cy) will not work.\n\n[0]: #graphic.elements-text.top\n[1]: #graphic.elements-text.bottom\n[2]: #graphic.elements-text.shape"
    },
    "elements-text.bounding": {
        "desc": " Used to specify whether the entire transformed element (containing children if is group) is confined in its container. See sample: 暂时无法显示 Optional values: \n\n* 'all': (default) Use the transformed bounding box of itself and its descendants to perform position calculation, which confine the entire body in the boundary of its parent.\n* 'raw': Only use the untransformed bounding box of itself (without its descentant) to perform position calculation, which is suitable when the content in the element need to be overflow its parent.\n\n"
    },
    "elements-text.z": {
        "desc": " z value of the elements, determine the overlap order. "
    },
    "elements-text.zlevel": {
        "desc": " Determine which canvas layer this element should be in. Notice: Multiple canvas layer may affect performance. "
    },
    "elements-text.info": {
        "desc": " User defined data, can be visited in event listeners. \n\n    chart.on('click', function (params) {\n        console.log(params.info);\n    });\n    \n\n"
    },
    "elements-text.silent": {
        "desc": " Whether response to mouse events / touch events. "
    },
    "elements-text.invisible": {
        "desc": " Whether the element is visible. "
    },
    "elements-text.ignore": {
        "desc": " Whether the element is totally ignored (neither render nor listen events). "
    },
    "elements-text.textContent": {
        "desc": " Text block attached to an element and layout based on the element by textConfig. The props the the same as [text][0].\n\n[0]: option.html#graphic.elements-text"
    },
    "elements-text.textConfig": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "elements-text.textConfig.position": {
        "desc": " Position of textContent. \n\n* 'left'\n* 'right'\n* 'top'\n* 'bottom'\n* 'inside'\n* 'insideLeft'\n* 'insideRight'\n* 'insideTop'\n* 'insideBottom'\n* 'insideTopLeft'\n* 'insideTopRight'\n* 'insideBottomLeft'\n* 'insideBottomRight'\n* or like [12, 33]\n* or like ['50%', '50%']\n\n"
    },
    "elements-text.textConfig.rotation": {
        "desc": " Rotation of textContent. In radian. "
    },
    "elements-text.textConfig.layoutRect": {
        "desc": " Rect that textContent will be positioned. Default to be the bounding box of host element. \n\n    {\n        x: number\n        y: number\n        width: number\n        height: number\n    }\n    \n\n"
    },
    "elements-text.textConfig.offset": {
        "desc": " Offset of the textContent. The difference of offset and position is that offset will be applied in the rotation. "
    },
    "elements-text.textConfig.origin": {
        "desc": "origin is relative to the bounding box of the host element. Can be percent value. Relative to the bounding box. If 'center' specified, it will be center of the bounding box. Only available when position and rotation are both set. \n\n* like [12, 33]\n* or like ['50%', '50%']\n* 'center'\n\n"
    },
    "elements-text.textConfig.distance": {
        "desc": " Distance to the layoutRect。 "
    },
    "elements-text.textConfig.local": {
        "desc": " If true, it will apply host's transform. "
    },
    "elements-text.textConfig.insideFill": {
        "desc": "insideFill is a color string or left empty. If a textContent is \"inside\", its final fill will be picked by this priority: textContent.style.fill > textConfig.insideFill > \"auto-calculated-fill\" In most cases, \"auto-calculated-fill\" is white. "
    },
    "elements-text.textConfig.insideStroke": {
        "desc": "insideStroke is a color string or left empty. If a textContent is \"inside\", its final stroke will be picked by this priority: textContent.style.stroke > textConfig.insideStroke > \"auto-calculated-stroke\" The rule of getting \"auto-calculated-stroke\": \n\n* If\n  * (A) the fill is specified in style (either in textContent.style or textContent.style.rich)\n  * or (B) needed to draw text background (either defined in textContent.style or textContent.style.rich)\n  * \"auto-calculated-stroke\" will be null.\n* Otherwise\n  * \"auto-calculated-stroke\" will be the same as fill of this element if possible, or null.\n\n"
    },
    "elements-text.textConfig.outsideFill": {
        "desc": "outsideFill is a color string or left empty. If a textContent is \"inside\", its final fill will be picked by this priority: textContent.style.fill > textConfig.outsideFill > #000 "
    },
    "elements-text.textConfig.outsideStroke": {
        "desc": "outsideStroke is a color string or left empty. If a textContent is not \"inside\", its final stroke will be picked by this priority: textContent.style.stroke > textConfig.outsideStroke > \"auto-calculated-stroke\" The rule of getting \"auto-calculated-stroke\": \n\n* If\n  * (A) the fill is specified in style (either in textContent.style or textContent.style.rich)\n  * or (B) needed to draw text background (either defined in textContent.style or textContent.style.rich)\n  * \"auto-calculated-stroke\" will be null.\n* Otherwise\n  * \"auto-calculated-stroke\" will be a near white color to distinguish \"front end\" label with messy background (like other text label, line or other graphic).\n\n"
    },
    "elements-text.textConfig.inside": {
        "desc": " Tell echarts that I can make sure this text is inside or not. "
    },
    "elements-text.cursor": {
        "desc": " The mouse style when mouse hovers on an element, the same as cursor property in CSS. ",
        "uiControl": {
            "type": "enum",
            "options": "'auto','pointer','move'"
        }
    },
    "elements-text.draggable": {
        "desc": " Can be dragged or not. "
    },
    "elements-text.progressive": {
        "desc": " Whether use progressive render to improve performance. Usually used when number of element is too large. "
    },
    "elements-text.style": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "elements-text.style.text": {
        "desc": " Text content. \\n can be used as a line break. "
    },
    "elements-text.style.x": {
        "desc": " The x value of the left-top corner of the element in the coordinate system of its parent. "
    },
    "elements-text.style.y": {
        "desc": " The y value of the left-top corner of the element in the coordinate system of its parent. "
    },
    "elements-text.style.font": {
        "desc": " Font size, font type, font weight, font color, follow the form of [css font][0]. For example: \n\n    // size | family\n    font: '2em \"STHeiti\", sans-serif'\n    \n    // style | weight | size | family\n    font: 'italic bolder 16px cursive'\n    \n    // weight | size | family\n    font: 'bolder 2em \"Microsoft YaHei\", sans-serif'\n    \n\n[0]: https://developer.mozilla.org/en-US/docs/Web/CSS/font"
    },
    "elements-text.style.textAlign": {
        "desc": " Text horizontal alignment. Optional values: 'left', 'center', 'right'. 'left' means the left side of the text block is specified by the [style.x][0], while 'right' means the right side of the text block is specified by [style.y][1].\n\n[0]: #graphic.elements-text.style.x\n[1]: #graphic.elements-text.style.y"
    },
    "elements-text.style.textVerticalAlign": {
        "desc": " Text vertical alignment. Optional values: 'top', 'middle', 'bottom'. More attributes in style (for example, [rich text][0]), see the style related attributes in [zrender/graphic/Displayable][1]. Notice, the attribute names of the style of graphic elements is derived from zrender, which may be different from the attribute names in echarts label, echarts itemStyle, etc., although they have the same meaning. For example: \n\n* [itemStyle.color][2] => style.fill\n* [itemStyle.borderColor][2] => style.stroke\n* [label.color][2] => style.textFill\n* [label.textBorderColor][3] => style.textStroke\n* ...\n\n\n\n[0]: tutorial.html#Rich%20Text\n[1]: https://ecomfe.github.io/zrender-doc/public/api.html#zrenderdisplayable\n[2]: #series-scatter.label.color\n[3]: #series-scatter.label.textBorderColor"
    },
    "elements-text.style.fill": {
        "desc": " Color filled in this element. "
    },
    "elements-text.style.stroke": {
        "desc": " Color of stroke. "
    },
    "elements-text.style.lineWidth": {
        "desc": " Width of stroke. "
    },
    "elements-text.style.shadowBlur": {
        "desc": " Width of shadow. "
    },
    "elements-text.style.shadowOffsetX": {
        "desc": " X offset of shadow. "
    },
    "elements-text.style.shadowOffsetY": {
        "desc": " Y offset of shadow. "
    },
    "elements-text.style.shadowColor": {
        "desc": " color of shadow. "
    },
    "elements-text.focus": {
        "desc": ">  Since > v5.0.0 When it's highlighted, whether to fade out of other data to focus the highlighted. The following configurations are supported: \n\n* 'none' Do not fade out other data, it's by default.\n* 'self' Only focus (not fade out) the element of the currently highlighted data.\n* 'series' Focus on all elements of the series which the currently highlighted data belongs to.\n\n"
    },
    "elements-text.blurScope": {
        "desc": ">  Since > v5.0.0 The range of fade out when focus is enabled. Support the following configurations \n\n* 'coordinateSystem'\n* 'series'\n* 'global'\n\n"
    },
    "elements-rect": {
        "desc": " Rectangle element. "
    },
    "elements-rect.type": {
        "desc": " Must be specified when define a graphic element at the first time. Optional values: [image][0], [text][1], [circle][2], [sector][3], [ring][4], [polygon][5], [polyline][6], [rect][7], [line][8], [bezierCurve][9], [arc][10], [group][11],\n\n[0]: #graphic.elements-image\n[1]: #graphic.elements-text\n[2]: #graphic.elements-circle\n[3]: #graphic.elements-sector\n[4]: #graphic.elements-ring\n[5]: #graphic.elements-polygon\n[6]: #graphic.elements-polyline\n[7]: #graphic.elements-rect\n[8]: #graphic.elements-line\n[9]: #graphic.elements-bezierCurve\n[10]: #graphic.elements-arc\n[11]: #graphic.elements-group"
    },
    "elements-rect.id": {
        "desc": " id is used to specifying element when willing to update it. id can be ignored if you do not need it. "
    },
    "elements-rect.$action": {
        "desc": " Specify the operation should be performed to the element when calling setOption. Default value is 'merge', other values can be 'replace' or 'remove'. Optional values: \n\n* 'merge': merge the given option to existing element (if any), otherwise create a new element.\n* 'replace': create a new element according to the given option and replace the existing element (if any).\n* 'remove': delete the existing element (if any).\n\n"
    },
    "elements-rect.x": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-rect.x\n[1]: #graphic.elements-rect.y\n[2]: #graphic.elements-rect.rotation\n[3]: #graphic.elements-rect.scaleX\n[4]: #graphic.elements-rect.scaleY\n[5]: #graphic.elements-rect.originX\n[6]: #graphic.elements-rect.originY\n[7]: #graphic.elements-group"
    },
    "elements-rect.y": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-rect.x\n[1]: #graphic.elements-rect.y\n[2]: #graphic.elements-rect.rotation\n[3]: #graphic.elements-rect.scaleX\n[4]: #graphic.elements-rect.scaleY\n[5]: #graphic.elements-rect.originX\n[6]: #graphic.elements-rect.originY\n[7]: #graphic.elements-group"
    },
    "elements-rect.rotation": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-rect.x\n[1]: #graphic.elements-rect.y\n[2]: #graphic.elements-rect.rotation\n[3]: #graphic.elements-rect.scaleX\n[4]: #graphic.elements-rect.scaleY\n[5]: #graphic.elements-rect.originX\n[6]: #graphic.elements-rect.originY\n[7]: #graphic.elements-group"
    },
    "elements-rect.scaleX": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-rect.x\n[1]: #graphic.elements-rect.y\n[2]: #graphic.elements-rect.rotation\n[3]: #graphic.elements-rect.scaleX\n[4]: #graphic.elements-rect.scaleY\n[5]: #graphic.elements-rect.originX\n[6]: #graphic.elements-rect.originY\n[7]: #graphic.elements-group"
    },
    "elements-rect.scaleY": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-rect.x\n[1]: #graphic.elements-rect.y\n[2]: #graphic.elements-rect.rotation\n[3]: #graphic.elements-rect.scaleX\n[4]: #graphic.elements-rect.scaleY\n[5]: #graphic.elements-rect.originX\n[6]: #graphic.elements-rect.originY\n[7]: #graphic.elements-group"
    },
    "elements-rect.originX": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-rect.x\n[1]: #graphic.elements-rect.y\n[2]: #graphic.elements-rect.rotation\n[3]: #graphic.elements-rect.scaleX\n[4]: #graphic.elements-rect.scaleY\n[5]: #graphic.elements-rect.originX\n[6]: #graphic.elements-rect.originY\n[7]: #graphic.elements-group"
    },
    "elements-rect.originY": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-rect.x\n[1]: #graphic.elements-rect.y\n[2]: #graphic.elements-rect.rotation\n[3]: #graphic.elements-rect.scaleX\n[4]: #graphic.elements-rect.scaleY\n[5]: #graphic.elements-rect.originX\n[6]: #graphic.elements-rect.originY\n[7]: #graphic.elements-group"
    },
    "elements-rect.left": {
        "desc": " Specify how to be positioned in its parent. When the element is at the top level, the parent is the container of the chart instance. Otherwise, the parent is a group element. Optional values: \n\n* Pixel value: For example, can be a number 30, means 30px.\n* Percent value: For example, can be a string '33%', means the final result should be calculated by this value and the height of its parent.\n* 'center': means position the element in the middle of according to its parent.\n\nOnly one between [left][0] and [right][1] can work. If [left][0] or [right][1] is specified, positioning attributes in [shape][2] (like x, cx) will not work.\n\n[0]: #graphic.elements-rect.left\n[1]: #graphic.elements-rect.right\n[2]: #graphic.elements-rect.shape"
    },
    "elements-rect.right": {
        "desc": " Specify how to be positioned in its parent. When the element is at the top level, the parent is the container of the chart instance. Otherwise, the parent is a group element. Optional values: \n\n* Pixel value: For example, can be a number 30, means 30px.\n* Percent value: For example, can be a string '33%', means the final result should be calculated by this value and the height of its parent.\n* 'center': means position the element in the middle of according to its parent.\n\nOnly one between [left][0] and [right][1] can work. If [left][0] or [right][1] is specified, positioning attributes in [shape][2] (like x, cx) will not work.\n\n[0]: #graphic.elements-rect.left\n[1]: #graphic.elements-rect.right\n[2]: #graphic.elements-rect.shape"
    },
    "elements-rect.top": {
        "desc": " Specify how to be positioned in its parent. When the element is at the top level, the parent is the container of the chart instance. Otherwise, the parent is a group element. Optional values: \n\n* Pixel value: For example, can be a number 30, means 30px.\n* Percent value: For example, can be a string '33%', means the final result should be calculated by this value and the width of its parent.\n* 'middle': means position the element in the middle of according to its parent.\n\nOnly one between [top][0] and [bottom][1] can work. If [top][0] or [bottom][1] is specified, positioning attributes in [shape][2] (like y, cy) will not work.\n\n[0]: #graphic.elements-rect.top\n[1]: #graphic.elements-rect.bottom\n[2]: #graphic.elements-rect.shape"
    },
    "elements-rect.bottom": {
        "desc": " Specify how to be positioned in its parent. When the element is at the top level, the parent is the container of the chart instance. Otherwise, the parent is a group element. Optional values: \n\n* Pixel value: For example, can be a number 30, means 30px.\n* Percent value: For example, can be a string '33%', means the final result should be calculated by this value and the width of its parent.\n* 'middle': means position the element in the middle of according to its parent.\n\nOnly one between [top][0] and [bottom][1] can work. If [top][0] or [bottom][1] is specified, positioning attributes in [shape][2] (like y, cy) will not work.\n\n[0]: #graphic.elements-rect.top\n[1]: #graphic.elements-rect.bottom\n[2]: #graphic.elements-rect.shape"
    },
    "elements-rect.bounding": {
        "desc": " Used to specify whether the entire transformed element (containing children if is group) is confined in its container. See sample: 暂时无法显示 Optional values: \n\n* 'all': (default) Use the transformed bounding box of itself and its descendants to perform position calculation, which confine the entire body in the boundary of its parent.\n* 'raw': Only use the untransformed bounding box of itself (without its descentant) to perform position calculation, which is suitable when the content in the element need to be overflow its parent.\n\n"
    },
    "elements-rect.z": {
        "desc": " z value of the elements, determine the overlap order. "
    },
    "elements-rect.zlevel": {
        "desc": " Determine which canvas layer this element should be in. Notice: Multiple canvas layer may affect performance. "
    },
    "elements-rect.info": {
        "desc": " User defined data, can be visited in event listeners. \n\n    chart.on('click', function (params) {\n        console.log(params.info);\n    });\n    \n\n"
    },
    "elements-rect.silent": {
        "desc": " Whether response to mouse events / touch events. "
    },
    "elements-rect.invisible": {
        "desc": " Whether the element is visible. "
    },
    "elements-rect.ignore": {
        "desc": " Whether the element is totally ignored (neither render nor listen events). "
    },
    "elements-rect.textContent": {
        "desc": " Text block attached to an element and layout based on the element by textConfig. The props the the same as [text][0].\n\n[0]: option.html#graphic.elements-text"
    },
    "elements-rect.textConfig": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "elements-rect.textConfig.position": {
        "desc": " Position of textContent. \n\n* 'left'\n* 'right'\n* 'top'\n* 'bottom'\n* 'inside'\n* 'insideLeft'\n* 'insideRight'\n* 'insideTop'\n* 'insideBottom'\n* 'insideTopLeft'\n* 'insideTopRight'\n* 'insideBottomLeft'\n* 'insideBottomRight'\n* or like [12, 33]\n* or like ['50%', '50%']\n\n"
    },
    "elements-rect.textConfig.rotation": {
        "desc": " Rotation of textContent. In radian. "
    },
    "elements-rect.textConfig.layoutRect": {
        "desc": " Rect that textContent will be positioned. Default to be the bounding box of host element. \n\n    {\n        x: number\n        y: number\n        width: number\n        height: number\n    }\n    \n\n"
    },
    "elements-rect.textConfig.offset": {
        "desc": " Offset of the textContent. The difference of offset and position is that offset will be applied in the rotation. "
    },
    "elements-rect.textConfig.origin": {
        "desc": "origin is relative to the bounding box of the host element. Can be percent value. Relative to the bounding box. If 'center' specified, it will be center of the bounding box. Only available when position and rotation are both set. \n\n* like [12, 33]\n* or like ['50%', '50%']\n* 'center'\n\n"
    },
    "elements-rect.textConfig.distance": {
        "desc": " Distance to the layoutRect。 "
    },
    "elements-rect.textConfig.local": {
        "desc": " If true, it will apply host's transform. "
    },
    "elements-rect.textConfig.insideFill": {
        "desc": "insideFill is a color string or left empty. If a textContent is \"inside\", its final fill will be picked by this priority: textContent.style.fill > textConfig.insideFill > \"auto-calculated-fill\" In most cases, \"auto-calculated-fill\" is white. "
    },
    "elements-rect.textConfig.insideStroke": {
        "desc": "insideStroke is a color string or left empty. If a textContent is \"inside\", its final stroke will be picked by this priority: textContent.style.stroke > textConfig.insideStroke > \"auto-calculated-stroke\" The rule of getting \"auto-calculated-stroke\": \n\n* If\n  * (A) the fill is specified in style (either in textContent.style or textContent.style.rich)\n  * or (B) needed to draw text background (either defined in textContent.style or textContent.style.rich)\n  * \"auto-calculated-stroke\" will be null.\n* Otherwise\n  * \"auto-calculated-stroke\" will be the same as fill of this element if possible, or null.\n\n"
    },
    "elements-rect.textConfig.outsideFill": {
        "desc": "outsideFill is a color string or left empty. If a textContent is \"inside\", its final fill will be picked by this priority: textContent.style.fill > textConfig.outsideFill > #000 "
    },
    "elements-rect.textConfig.outsideStroke": {
        "desc": "outsideStroke is a color string or left empty. If a textContent is not \"inside\", its final stroke will be picked by this priority: textContent.style.stroke > textConfig.outsideStroke > \"auto-calculated-stroke\" The rule of getting \"auto-calculated-stroke\": \n\n* If\n  * (A) the fill is specified in style (either in textContent.style or textContent.style.rich)\n  * or (B) needed to draw text background (either defined in textContent.style or textContent.style.rich)\n  * \"auto-calculated-stroke\" will be null.\n* Otherwise\n  * \"auto-calculated-stroke\" will be a near white color to distinguish \"front end\" label with messy background (like other text label, line or other graphic).\n\n"
    },
    "elements-rect.textConfig.inside": {
        "desc": " Tell echarts that I can make sure this text is inside or not. "
    },
    "elements-rect.cursor": {
        "desc": " The mouse style when mouse hovers on an element, the same as cursor property in CSS. ",
        "uiControl": {
            "type": "enum",
            "options": "'auto','pointer','move'"
        }
    },
    "elements-rect.draggable": {
        "desc": " Can be dragged or not. "
    },
    "elements-rect.progressive": {
        "desc": " Whether use progressive render to improve performance. Usually used when number of element is too large. "
    },
    "elements-rect.shape": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "elements-rect.shape.x": {
        "desc": " The x value of the left-top corner of the element in the coordinate system of its parent. "
    },
    "elements-rect.shape.y": {
        "desc": " The y value of the left-top corner of the element in the coordinate system of its parent. "
    },
    "elements-rect.shape.width": {
        "desc": " The width of the shape of the element. "
    },
    "elements-rect.shape.height": {
        "desc": " The height of the shape of the element. "
    },
    "elements-rect.shape.r": {
        "desc": " Specify border radius of the rectangular here. Generally, r should be [topLeftRadius, topRightRadius, BottomRightRadius, bottomLeftRadius], where each item is a number. Abbreviation is enabled, for example: \n\n* r: 1 means [1, 1, 1, 1]\n* r: [1] means [1, 1, 1, 1]\n* r: [1, 2] means [1, 2, 1, 2]\n* r: [1, 2, 3] means [1, 2, 3, 2]\n\n"
    },
    "elements-rect.style": {
        "desc": " More attributes in style (for example, [rich text][0]), see the style related attributes in [zrender/graphic/Displayable][1]. Notice, the attribute names of the style of graphic elements is derived from zrender, which may be different from the attribute names in echarts label, echarts itemStyle, etc., although they have the same meaning. For example: \n\n* [itemStyle.color][2] => style.fill\n* [itemStyle.borderColor][2] => style.stroke\n* [label.color][2] => style.textFill\n* [label.textBorderColor][3] => style.textStroke\n* ...\n\n\n\n[0]: tutorial.html#Rich%20Text\n[1]: https://ecomfe.github.io/zrender-doc/public/api.html#zrenderdisplayable\n[2]: #series-scatter.label.color\n[3]: #series-scatter.label.textBorderColor"
    },
    "elements-rect.style.fill": {
        "desc": " Color filled in this element. "
    },
    "elements-rect.style.stroke": {
        "desc": " Color of stroke. "
    },
    "elements-rect.style.lineWidth": {
        "desc": " Width of stroke. "
    },
    "elements-rect.style.shadowBlur": {
        "desc": " Width of shadow. "
    },
    "elements-rect.style.shadowOffsetX": {
        "desc": " X offset of shadow. "
    },
    "elements-rect.style.shadowOffsetY": {
        "desc": " Y offset of shadow. "
    },
    "elements-rect.style.shadowColor": {
        "desc": " color of shadow. "
    },
    "elements-rect.focus": {
        "desc": ">  Since > v5.0.0 When it's highlighted, whether to fade out of other data to focus the highlighted. The following configurations are supported: \n\n* 'none' Do not fade out other data, it's by default.\n* 'self' Only focus (not fade out) the element of the currently highlighted data.\n* 'series' Focus on all elements of the series which the currently highlighted data belongs to.\n\n"
    },
    "elements-rect.blurScope": {
        "desc": ">  Since > v5.0.0 The range of fade out when focus is enabled. Support the following configurations \n\n* 'coordinateSystem'\n* 'series'\n* 'global'\n\n"
    },
    "elements-circle": {
        "desc": " Circle element. "
    },
    "elements-circle.type": {
        "desc": " Must be specified when define a graphic element at the first time. Optional values: [image][0], [text][1], [circle][2], [sector][3], [ring][4], [polygon][5], [polyline][6], [rect][7], [line][8], [bezierCurve][9], [arc][10], [group][11],\n\n[0]: #graphic.elements-image\n[1]: #graphic.elements-text\n[2]: #graphic.elements-circle\n[3]: #graphic.elements-sector\n[4]: #graphic.elements-ring\n[5]: #graphic.elements-polygon\n[6]: #graphic.elements-polyline\n[7]: #graphic.elements-rect\n[8]: #graphic.elements-line\n[9]: #graphic.elements-bezierCurve\n[10]: #graphic.elements-arc\n[11]: #graphic.elements-group"
    },
    "elements-circle.id": {
        "desc": " id is used to specifying element when willing to update it. id can be ignored if you do not need it. "
    },
    "elements-circle.$action": {
        "desc": " Specify the operation should be performed to the element when calling setOption. Default value is 'merge', other values can be 'replace' or 'remove'. Optional values: \n\n* 'merge': merge the given option to existing element (if any), otherwise create a new element.\n* 'replace': create a new element according to the given option and replace the existing element (if any).\n* 'remove': delete the existing element (if any).\n\n"
    },
    "elements-circle.x": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-circle.x\n[1]: #graphic.elements-circle.y\n[2]: #graphic.elements-circle.rotation\n[3]: #graphic.elements-circle.scaleX\n[4]: #graphic.elements-circle.scaleY\n[5]: #graphic.elements-circle.originX\n[6]: #graphic.elements-circle.originY\n[7]: #graphic.elements-group"
    },
    "elements-circle.y": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-circle.x\n[1]: #graphic.elements-circle.y\n[2]: #graphic.elements-circle.rotation\n[3]: #graphic.elements-circle.scaleX\n[4]: #graphic.elements-circle.scaleY\n[5]: #graphic.elements-circle.originX\n[6]: #graphic.elements-circle.originY\n[7]: #graphic.elements-group"
    },
    "elements-circle.rotation": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-circle.x\n[1]: #graphic.elements-circle.y\n[2]: #graphic.elements-circle.rotation\n[3]: #graphic.elements-circle.scaleX\n[4]: #graphic.elements-circle.scaleY\n[5]: #graphic.elements-circle.originX\n[6]: #graphic.elements-circle.originY\n[7]: #graphic.elements-group"
    },
    "elements-circle.scaleX": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-circle.x\n[1]: #graphic.elements-circle.y\n[2]: #graphic.elements-circle.rotation\n[3]: #graphic.elements-circle.scaleX\n[4]: #graphic.elements-circle.scaleY\n[5]: #graphic.elements-circle.originX\n[6]: #graphic.elements-circle.originY\n[7]: #graphic.elements-group"
    },
    "elements-circle.scaleY": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-circle.x\n[1]: #graphic.elements-circle.y\n[2]: #graphic.elements-circle.rotation\n[3]: #graphic.elements-circle.scaleX\n[4]: #graphic.elements-circle.scaleY\n[5]: #graphic.elements-circle.originX\n[6]: #graphic.elements-circle.originY\n[7]: #graphic.elements-group"
    },
    "elements-circle.originX": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-circle.x\n[1]: #graphic.elements-circle.y\n[2]: #graphic.elements-circle.rotation\n[3]: #graphic.elements-circle.scaleX\n[4]: #graphic.elements-circle.scaleY\n[5]: #graphic.elements-circle.originX\n[6]: #graphic.elements-circle.originY\n[7]: #graphic.elements-group"
    },
    "elements-circle.originY": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-circle.x\n[1]: #graphic.elements-circle.y\n[2]: #graphic.elements-circle.rotation\n[3]: #graphic.elements-circle.scaleX\n[4]: #graphic.elements-circle.scaleY\n[5]: #graphic.elements-circle.originX\n[6]: #graphic.elements-circle.originY\n[7]: #graphic.elements-group"
    },
    "elements-circle.left": {
        "desc": " Specify how to be positioned in its parent. When the element is at the top level, the parent is the container of the chart instance. Otherwise, the parent is a group element. Optional values: \n\n* Pixel value: For example, can be a number 30, means 30px.\n* Percent value: For example, can be a string '33%', means the final result should be calculated by this value and the height of its parent.\n* 'center': means position the element in the middle of according to its parent.\n\nOnly one between [left][0] and [right][1] can work. If [left][0] or [right][1] is specified, positioning attributes in [shape][2] (like x, cx) will not work.\n\n[0]: #graphic.elements-circle.left\n[1]: #graphic.elements-circle.right\n[2]: #graphic.elements-circle.shape"
    },
    "elements-circle.right": {
        "desc": " Specify how to be positioned in its parent. When the element is at the top level, the parent is the container of the chart instance. Otherwise, the parent is a group element. Optional values: \n\n* Pixel value: For example, can be a number 30, means 30px.\n* Percent value: For example, can be a string '33%', means the final result should be calculated by this value and the height of its parent.\n* 'center': means position the element in the middle of according to its parent.\n\nOnly one between [left][0] and [right][1] can work. If [left][0] or [right][1] is specified, positioning attributes in [shape][2] (like x, cx) will not work.\n\n[0]: #graphic.elements-circle.left\n[1]: #graphic.elements-circle.right\n[2]: #graphic.elements-circle.shape"
    },
    "elements-circle.top": {
        "desc": " Specify how to be positioned in its parent. When the element is at the top level, the parent is the container of the chart instance. Otherwise, the parent is a group element. Optional values: \n\n* Pixel value: For example, can be a number 30, means 30px.\n* Percent value: For example, can be a string '33%', means the final result should be calculated by this value and the width of its parent.\n* 'middle': means position the element in the middle of according to its parent.\n\nOnly one between [top][0] and [bottom][1] can work. If [top][0] or [bottom][1] is specified, positioning attributes in [shape][2] (like y, cy) will not work.\n\n[0]: #graphic.elements-circle.top\n[1]: #graphic.elements-circle.bottom\n[2]: #graphic.elements-circle.shape"
    },
    "elements-circle.bottom": {
        "desc": " Specify how to be positioned in its parent. When the element is at the top level, the parent is the container of the chart instance. Otherwise, the parent is a group element. Optional values: \n\n* Pixel value: For example, can be a number 30, means 30px.\n* Percent value: For example, can be a string '33%', means the final result should be calculated by this value and the width of its parent.\n* 'middle': means position the element in the middle of according to its parent.\n\nOnly one between [top][0] and [bottom][1] can work. If [top][0] or [bottom][1] is specified, positioning attributes in [shape][2] (like y, cy) will not work.\n\n[0]: #graphic.elements-circle.top\n[1]: #graphic.elements-circle.bottom\n[2]: #graphic.elements-circle.shape"
    },
    "elements-circle.bounding": {
        "desc": " Used to specify whether the entire transformed element (containing children if is group) is confined in its container. See sample: 暂时无法显示 Optional values: \n\n* 'all': (default) Use the transformed bounding box of itself and its descendants to perform position calculation, which confine the entire body in the boundary of its parent.\n* 'raw': Only use the untransformed bounding box of itself (without its descentant) to perform position calculation, which is suitable when the content in the element need to be overflow its parent.\n\n"
    },
    "elements-circle.z": {
        "desc": " z value of the elements, determine the overlap order. "
    },
    "elements-circle.zlevel": {
        "desc": " Determine which canvas layer this element should be in. Notice: Multiple canvas layer may affect performance. "
    },
    "elements-circle.info": {
        "desc": " User defined data, can be visited in event listeners. \n\n    chart.on('click', function (params) {\n        console.log(params.info);\n    });\n    \n\n"
    },
    "elements-circle.silent": {
        "desc": " Whether response to mouse events / touch events. "
    },
    "elements-circle.invisible": {
        "desc": " Whether the element is visible. "
    },
    "elements-circle.ignore": {
        "desc": " Whether the element is totally ignored (neither render nor listen events). "
    },
    "elements-circle.textContent": {
        "desc": " Text block attached to an element and layout based on the element by textConfig. The props the the same as [text][0].\n\n[0]: option.html#graphic.elements-text"
    },
    "elements-circle.textConfig": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "elements-circle.textConfig.position": {
        "desc": " Position of textContent. \n\n* 'left'\n* 'right'\n* 'top'\n* 'bottom'\n* 'inside'\n* 'insideLeft'\n* 'insideRight'\n* 'insideTop'\n* 'insideBottom'\n* 'insideTopLeft'\n* 'insideTopRight'\n* 'insideBottomLeft'\n* 'insideBottomRight'\n* or like [12, 33]\n* or like ['50%', '50%']\n\n"
    },
    "elements-circle.textConfig.rotation": {
        "desc": " Rotation of textContent. In radian. "
    },
    "elements-circle.textConfig.layoutRect": {
        "desc": " Rect that textContent will be positioned. Default to be the bounding box of host element. \n\n    {\n        x: number\n        y: number\n        width: number\n        height: number\n    }\n    \n\n"
    },
    "elements-circle.textConfig.offset": {
        "desc": " Offset of the textContent. The difference of offset and position is that offset will be applied in the rotation. "
    },
    "elements-circle.textConfig.origin": {
        "desc": "origin is relative to the bounding box of the host element. Can be percent value. Relative to the bounding box. If 'center' specified, it will be center of the bounding box. Only available when position and rotation are both set. \n\n* like [12, 33]\n* or like ['50%', '50%']\n* 'center'\n\n"
    },
    "elements-circle.textConfig.distance": {
        "desc": " Distance to the layoutRect。 "
    },
    "elements-circle.textConfig.local": {
        "desc": " If true, it will apply host's transform. "
    },
    "elements-circle.textConfig.insideFill": {
        "desc": "insideFill is a color string or left empty. If a textContent is \"inside\", its final fill will be picked by this priority: textContent.style.fill > textConfig.insideFill > \"auto-calculated-fill\" In most cases, \"auto-calculated-fill\" is white. "
    },
    "elements-circle.textConfig.insideStroke": {
        "desc": "insideStroke is a color string or left empty. If a textContent is \"inside\", its final stroke will be picked by this priority: textContent.style.stroke > textConfig.insideStroke > \"auto-calculated-stroke\" The rule of getting \"auto-calculated-stroke\": \n\n* If\n  * (A) the fill is specified in style (either in textContent.style or textContent.style.rich)\n  * or (B) needed to draw text background (either defined in textContent.style or textContent.style.rich)\n  * \"auto-calculated-stroke\" will be null.\n* Otherwise\n  * \"auto-calculated-stroke\" will be the same as fill of this element if possible, or null.\n\n"
    },
    "elements-circle.textConfig.outsideFill": {
        "desc": "outsideFill is a color string or left empty. If a textContent is \"inside\", its final fill will be picked by this priority: textContent.style.fill > textConfig.outsideFill > #000 "
    },
    "elements-circle.textConfig.outsideStroke": {
        "desc": "outsideStroke is a color string or left empty. If a textContent is not \"inside\", its final stroke will be picked by this priority: textContent.style.stroke > textConfig.outsideStroke > \"auto-calculated-stroke\" The rule of getting \"auto-calculated-stroke\": \n\n* If\n  * (A) the fill is specified in style (either in textContent.style or textContent.style.rich)\n  * or (B) needed to draw text background (either defined in textContent.style or textContent.style.rich)\n  * \"auto-calculated-stroke\" will be null.\n* Otherwise\n  * \"auto-calculated-stroke\" will be a near white color to distinguish \"front end\" label with messy background (like other text label, line or other graphic).\n\n"
    },
    "elements-circle.textConfig.inside": {
        "desc": " Tell echarts that I can make sure this text is inside or not. "
    },
    "elements-circle.cursor": {
        "desc": " The mouse style when mouse hovers on an element, the same as cursor property in CSS. ",
        "uiControl": {
            "type": "enum",
            "options": "'auto','pointer','move'"
        }
    },
    "elements-circle.draggable": {
        "desc": " Can be dragged or not. "
    },
    "elements-circle.progressive": {
        "desc": " Whether use progressive render to improve performance. Usually used when number of element is too large. "
    },
    "elements-circle.shape": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "elements-circle.shape.cx": {
        "desc": " The x value of the center of the element in the coordinate system of its parent. "
    },
    "elements-circle.shape.cy": {
        "desc": " The y value of the center of the element in the coordinate system of its parent. "
    },
    "elements-circle.shape.r": {
        "desc": " Outside radius. "
    },
    "elements-circle.style": {
        "desc": " More attributes in style (for example, [rich text][0]), see the style related attributes in [zrender/graphic/Displayable][1]. Notice, the attribute names of the style of graphic elements is derived from zrender, which may be different from the attribute names in echarts label, echarts itemStyle, etc., although they have the same meaning. For example: \n\n* [itemStyle.color][2] => style.fill\n* [itemStyle.borderColor][2] => style.stroke\n* [label.color][2] => style.textFill\n* [label.textBorderColor][3] => style.textStroke\n* ...\n\n\n\n[0]: tutorial.html#Rich%20Text\n[1]: https://ecomfe.github.io/zrender-doc/public/api.html#zrenderdisplayable\n[2]: #series-scatter.label.color\n[3]: #series-scatter.label.textBorderColor"
    },
    "elements-circle.style.fill": {
        "desc": " Color filled in this element. "
    },
    "elements-circle.style.stroke": {
        "desc": " Color of stroke. "
    },
    "elements-circle.style.lineWidth": {
        "desc": " Width of stroke. "
    },
    "elements-circle.style.shadowBlur": {
        "desc": " Width of shadow. "
    },
    "elements-circle.style.shadowOffsetX": {
        "desc": " X offset of shadow. "
    },
    "elements-circle.style.shadowOffsetY": {
        "desc": " Y offset of shadow. "
    },
    "elements-circle.style.shadowColor": {
        "desc": " color of shadow. "
    },
    "elements-circle.focus": {
        "desc": ">  Since > v5.0.0 When it's highlighted, whether to fade out of other data to focus the highlighted. The following configurations are supported: \n\n* 'none' Do not fade out other data, it's by default.\n* 'self' Only focus (not fade out) the element of the currently highlighted data.\n* 'series' Focus on all elements of the series which the currently highlighted data belongs to.\n\n"
    },
    "elements-circle.blurScope": {
        "desc": ">  Since > v5.0.0 The range of fade out when focus is enabled. Support the following configurations \n\n* 'coordinateSystem'\n* 'series'\n* 'global'\n\n"
    },
    "elements-ring": {
        "desc": " Ring element. "
    },
    "elements-ring.type": {
        "desc": " Must be specified when define a graphic element at the first time. Optional values: [image][0], [text][1], [circle][2], [sector][3], [ring][4], [polygon][5], [polyline][6], [rect][7], [line][8], [bezierCurve][9], [arc][10], [group][11],\n\n[0]: #graphic.elements-image\n[1]: #graphic.elements-text\n[2]: #graphic.elements-circle\n[3]: #graphic.elements-sector\n[4]: #graphic.elements-ring\n[5]: #graphic.elements-polygon\n[6]: #graphic.elements-polyline\n[7]: #graphic.elements-rect\n[8]: #graphic.elements-line\n[9]: #graphic.elements-bezierCurve\n[10]: #graphic.elements-arc\n[11]: #graphic.elements-group"
    },
    "elements-ring.id": {
        "desc": " id is used to specifying element when willing to update it. id can be ignored if you do not need it. "
    },
    "elements-ring.$action": {
        "desc": " Specify the operation should be performed to the element when calling setOption. Default value is 'merge', other values can be 'replace' or 'remove'. Optional values: \n\n* 'merge': merge the given option to existing element (if any), otherwise create a new element.\n* 'replace': create a new element according to the given option and replace the existing element (if any).\n* 'remove': delete the existing element (if any).\n\n"
    },
    "elements-ring.x": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-ring.x\n[1]: #graphic.elements-ring.y\n[2]: #graphic.elements-ring.rotation\n[3]: #graphic.elements-ring.scaleX\n[4]: #graphic.elements-ring.scaleY\n[5]: #graphic.elements-ring.originX\n[6]: #graphic.elements-ring.originY\n[7]: #graphic.elements-group"
    },
    "elements-ring.y": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-ring.x\n[1]: #graphic.elements-ring.y\n[2]: #graphic.elements-ring.rotation\n[3]: #graphic.elements-ring.scaleX\n[4]: #graphic.elements-ring.scaleY\n[5]: #graphic.elements-ring.originX\n[6]: #graphic.elements-ring.originY\n[7]: #graphic.elements-group"
    },
    "elements-ring.rotation": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-ring.x\n[1]: #graphic.elements-ring.y\n[2]: #graphic.elements-ring.rotation\n[3]: #graphic.elements-ring.scaleX\n[4]: #graphic.elements-ring.scaleY\n[5]: #graphic.elements-ring.originX\n[6]: #graphic.elements-ring.originY\n[7]: #graphic.elements-group"
    },
    "elements-ring.scaleX": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-ring.x\n[1]: #graphic.elements-ring.y\n[2]: #graphic.elements-ring.rotation\n[3]: #graphic.elements-ring.scaleX\n[4]: #graphic.elements-ring.scaleY\n[5]: #graphic.elements-ring.originX\n[6]: #graphic.elements-ring.originY\n[7]: #graphic.elements-group"
    },
    "elements-ring.scaleY": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-ring.x\n[1]: #graphic.elements-ring.y\n[2]: #graphic.elements-ring.rotation\n[3]: #graphic.elements-ring.scaleX\n[4]: #graphic.elements-ring.scaleY\n[5]: #graphic.elements-ring.originX\n[6]: #graphic.elements-ring.originY\n[7]: #graphic.elements-group"
    },
    "elements-ring.originX": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-ring.x\n[1]: #graphic.elements-ring.y\n[2]: #graphic.elements-ring.rotation\n[3]: #graphic.elements-ring.scaleX\n[4]: #graphic.elements-ring.scaleY\n[5]: #graphic.elements-ring.originX\n[6]: #graphic.elements-ring.originY\n[7]: #graphic.elements-group"
    },
    "elements-ring.originY": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-ring.x\n[1]: #graphic.elements-ring.y\n[2]: #graphic.elements-ring.rotation\n[3]: #graphic.elements-ring.scaleX\n[4]: #graphic.elements-ring.scaleY\n[5]: #graphic.elements-ring.originX\n[6]: #graphic.elements-ring.originY\n[7]: #graphic.elements-group"
    },
    "elements-ring.left": {
        "desc": " Specify how to be positioned in its parent. When the element is at the top level, the parent is the container of the chart instance. Otherwise, the parent is a group element. Optional values: \n\n* Pixel value: For example, can be a number 30, means 30px.\n* Percent value: For example, can be a string '33%', means the final result should be calculated by this value and the height of its parent.\n* 'center': means position the element in the middle of according to its parent.\n\nOnly one between [left][0] and [right][1] can work. If [left][0] or [right][1] is specified, positioning attributes in [shape][2] (like x, cx) will not work.\n\n[0]: #graphic.elements-ring.left\n[1]: #graphic.elements-ring.right\n[2]: #graphic.elements-ring.shape"
    },
    "elements-ring.right": {
        "desc": " Specify how to be positioned in its parent. When the element is at the top level, the parent is the container of the chart instance. Otherwise, the parent is a group element. Optional values: \n\n* Pixel value: For example, can be a number 30, means 30px.\n* Percent value: For example, can be a string '33%', means the final result should be calculated by this value and the height of its parent.\n* 'center': means position the element in the middle of according to its parent.\n\nOnly one between [left][0] and [right][1] can work. If [left][0] or [right][1] is specified, positioning attributes in [shape][2] (like x, cx) will not work.\n\n[0]: #graphic.elements-ring.left\n[1]: #graphic.elements-ring.right\n[2]: #graphic.elements-ring.shape"
    },
    "elements-ring.top": {
        "desc": " Specify how to be positioned in its parent. When the element is at the top level, the parent is the container of the chart instance. Otherwise, the parent is a group element. Optional values: \n\n* Pixel value: For example, can be a number 30, means 30px.\n* Percent value: For example, can be a string '33%', means the final result should be calculated by this value and the width of its parent.\n* 'middle': means position the element in the middle of according to its parent.\n\nOnly one between [top][0] and [bottom][1] can work. If [top][0] or [bottom][1] is specified, positioning attributes in [shape][2] (like y, cy) will not work.\n\n[0]: #graphic.elements-ring.top\n[1]: #graphic.elements-ring.bottom\n[2]: #graphic.elements-ring.shape"
    },
    "elements-ring.bottom": {
        "desc": " Specify how to be positioned in its parent. When the element is at the top level, the parent is the container of the chart instance. Otherwise, the parent is a group element. Optional values: \n\n* Pixel value: For example, can be a number 30, means 30px.\n* Percent value: For example, can be a string '33%', means the final result should be calculated by this value and the width of its parent.\n* 'middle': means position the element in the middle of according to its parent.\n\nOnly one between [top][0] and [bottom][1] can work. If [top][0] or [bottom][1] is specified, positioning attributes in [shape][2] (like y, cy) will not work.\n\n[0]: #graphic.elements-ring.top\n[1]: #graphic.elements-ring.bottom\n[2]: #graphic.elements-ring.shape"
    },
    "elements-ring.bounding": {
        "desc": " Used to specify whether the entire transformed element (containing children if is group) is confined in its container. See sample: 暂时无法显示 Optional values: \n\n* 'all': (default) Use the transformed bounding box of itself and its descendants to perform position calculation, which confine the entire body in the boundary of its parent.\n* 'raw': Only use the untransformed bounding box of itself (without its descentant) to perform position calculation, which is suitable when the content in the element need to be overflow its parent.\n\n"
    },
    "elements-ring.z": {
        "desc": " z value of the elements, determine the overlap order. "
    },
    "elements-ring.zlevel": {
        "desc": " Determine which canvas layer this element should be in. Notice: Multiple canvas layer may affect performance. "
    },
    "elements-ring.info": {
        "desc": " User defined data, can be visited in event listeners. \n\n    chart.on('click', function (params) {\n        console.log(params.info);\n    });\n    \n\n"
    },
    "elements-ring.silent": {
        "desc": " Whether response to mouse events / touch events. "
    },
    "elements-ring.invisible": {
        "desc": " Whether the element is visible. "
    },
    "elements-ring.ignore": {
        "desc": " Whether the element is totally ignored (neither render nor listen events). "
    },
    "elements-ring.textContent": {
        "desc": " Text block attached to an element and layout based on the element by textConfig. The props the the same as [text][0].\n\n[0]: option.html#graphic.elements-text"
    },
    "elements-ring.textConfig": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "elements-ring.textConfig.position": {
        "desc": " Position of textContent. \n\n* 'left'\n* 'right'\n* 'top'\n* 'bottom'\n* 'inside'\n* 'insideLeft'\n* 'insideRight'\n* 'insideTop'\n* 'insideBottom'\n* 'insideTopLeft'\n* 'insideTopRight'\n* 'insideBottomLeft'\n* 'insideBottomRight'\n* or like [12, 33]\n* or like ['50%', '50%']\n\n"
    },
    "elements-ring.textConfig.rotation": {
        "desc": " Rotation of textContent. In radian. "
    },
    "elements-ring.textConfig.layoutRect": {
        "desc": " Rect that textContent will be positioned. Default to be the bounding box of host element. \n\n    {\n        x: number\n        y: number\n        width: number\n        height: number\n    }\n    \n\n"
    },
    "elements-ring.textConfig.offset": {
        "desc": " Offset of the textContent. The difference of offset and position is that offset will be applied in the rotation. "
    },
    "elements-ring.textConfig.origin": {
        "desc": "origin is relative to the bounding box of the host element. Can be percent value. Relative to the bounding box. If 'center' specified, it will be center of the bounding box. Only available when position and rotation are both set. \n\n* like [12, 33]\n* or like ['50%', '50%']\n* 'center'\n\n"
    },
    "elements-ring.textConfig.distance": {
        "desc": " Distance to the layoutRect。 "
    },
    "elements-ring.textConfig.local": {
        "desc": " If true, it will apply host's transform. "
    },
    "elements-ring.textConfig.insideFill": {
        "desc": "insideFill is a color string or left empty. If a textContent is \"inside\", its final fill will be picked by this priority: textContent.style.fill > textConfig.insideFill > \"auto-calculated-fill\" In most cases, \"auto-calculated-fill\" is white. "
    },
    "elements-ring.textConfig.insideStroke": {
        "desc": "insideStroke is a color string or left empty. If a textContent is \"inside\", its final stroke will be picked by this priority: textContent.style.stroke > textConfig.insideStroke > \"auto-calculated-stroke\" The rule of getting \"auto-calculated-stroke\": \n\n* If\n  * (A) the fill is specified in style (either in textContent.style or textContent.style.rich)\n  * or (B) needed to draw text background (either defined in textContent.style or textContent.style.rich)\n  * \"auto-calculated-stroke\" will be null.\n* Otherwise\n  * \"auto-calculated-stroke\" will be the same as fill of this element if possible, or null.\n\n"
    },
    "elements-ring.textConfig.outsideFill": {
        "desc": "outsideFill is a color string or left empty. If a textContent is \"inside\", its final fill will be picked by this priority: textContent.style.fill > textConfig.outsideFill > #000 "
    },
    "elements-ring.textConfig.outsideStroke": {
        "desc": "outsideStroke is a color string or left empty. If a textContent is not \"inside\", its final stroke will be picked by this priority: textContent.style.stroke > textConfig.outsideStroke > \"auto-calculated-stroke\" The rule of getting \"auto-calculated-stroke\": \n\n* If\n  * (A) the fill is specified in style (either in textContent.style or textContent.style.rich)\n  * or (B) needed to draw text background (either defined in textContent.style or textContent.style.rich)\n  * \"auto-calculated-stroke\" will be null.\n* Otherwise\n  * \"auto-calculated-stroke\" will be a near white color to distinguish \"front end\" label with messy background (like other text label, line or other graphic).\n\n"
    },
    "elements-ring.textConfig.inside": {
        "desc": " Tell echarts that I can make sure this text is inside or not. "
    },
    "elements-ring.cursor": {
        "desc": " The mouse style when mouse hovers on an element, the same as cursor property in CSS. ",
        "uiControl": {
            "type": "enum",
            "options": "'auto','pointer','move'"
        }
    },
    "elements-ring.draggable": {
        "desc": " Can be dragged or not. "
    },
    "elements-ring.progressive": {
        "desc": " Whether use progressive render to improve performance. Usually used when number of element is too large. "
    },
    "elements-ring.shape": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "elements-ring.shape.cx": {
        "desc": " The x value of the center of the element in the coordinate system of its parent. "
    },
    "elements-ring.shape.cy": {
        "desc": " The y value of the center of the element in the coordinate system of its parent. "
    },
    "elements-ring.shape.r": {
        "desc": " Outside radius. "
    },
    "elements-ring.shape.r0": {
        "desc": " Inside radius. "
    },
    "elements-ring.style": {
        "desc": " More attributes in style (for example, [rich text][0]), see the style related attributes in [zrender/graphic/Displayable][1]. Notice, the attribute names of the style of graphic elements is derived from zrender, which may be different from the attribute names in echarts label, echarts itemStyle, etc., although they have the same meaning. For example: \n\n* [itemStyle.color][2] => style.fill\n* [itemStyle.borderColor][2] => style.stroke\n* [label.color][2] => style.textFill\n* [label.textBorderColor][3] => style.textStroke\n* ...\n\n\n\n[0]: tutorial.html#Rich%20Text\n[1]: https://ecomfe.github.io/zrender-doc/public/api.html#zrenderdisplayable\n[2]: #series-scatter.label.color\n[3]: #series-scatter.label.textBorderColor"
    },
    "elements-ring.style.fill": {
        "desc": " Color filled in this element. "
    },
    "elements-ring.style.stroke": {
        "desc": " Color of stroke. "
    },
    "elements-ring.style.lineWidth": {
        "desc": " Width of stroke. "
    },
    "elements-ring.style.shadowBlur": {
        "desc": " Width of shadow. "
    },
    "elements-ring.style.shadowOffsetX": {
        "desc": " X offset of shadow. "
    },
    "elements-ring.style.shadowOffsetY": {
        "desc": " Y offset of shadow. "
    },
    "elements-ring.style.shadowColor": {
        "desc": " color of shadow. "
    },
    "elements-ring.focus": {
        "desc": ">  Since > v5.0.0 When it's highlighted, whether to fade out of other data to focus the highlighted. The following configurations are supported: \n\n* 'none' Do not fade out other data, it's by default.\n* 'self' Only focus (not fade out) the element of the currently highlighted data.\n* 'series' Focus on all elements of the series which the currently highlighted data belongs to.\n\n"
    },
    "elements-ring.blurScope": {
        "desc": ">  Since > v5.0.0 The range of fade out when focus is enabled. Support the following configurations \n\n* 'coordinateSystem'\n* 'series'\n* 'global'\n\n"
    },
    "elements-sector": {
        "desc": " Sector element. "
    },
    "elements-sector.type": {
        "desc": " Must be specified when define a graphic element at the first time. Optional values: [image][0], [text][1], [circle][2], [sector][3], [ring][4], [polygon][5], [polyline][6], [rect][7], [line][8], [bezierCurve][9], [arc][10], [group][11],\n\n[0]: #graphic.elements-image\n[1]: #graphic.elements-text\n[2]: #graphic.elements-circle\n[3]: #graphic.elements-sector\n[4]: #graphic.elements-ring\n[5]: #graphic.elements-polygon\n[6]: #graphic.elements-polyline\n[7]: #graphic.elements-rect\n[8]: #graphic.elements-line\n[9]: #graphic.elements-bezierCurve\n[10]: #graphic.elements-arc\n[11]: #graphic.elements-group"
    },
    "elements-sector.id": {
        "desc": " id is used to specifying element when willing to update it. id can be ignored if you do not need it. "
    },
    "elements-sector.$action": {
        "desc": " Specify the operation should be performed to the element when calling setOption. Default value is 'merge', other values can be 'replace' or 'remove'. Optional values: \n\n* 'merge': merge the given option to existing element (if any), otherwise create a new element.\n* 'replace': create a new element according to the given option and replace the existing element (if any).\n* 'remove': delete the existing element (if any).\n\n"
    },
    "elements-sector.x": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-sector.x\n[1]: #graphic.elements-sector.y\n[2]: #graphic.elements-sector.rotation\n[3]: #graphic.elements-sector.scaleX\n[4]: #graphic.elements-sector.scaleY\n[5]: #graphic.elements-sector.originX\n[6]: #graphic.elements-sector.originY\n[7]: #graphic.elements-group"
    },
    "elements-sector.y": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-sector.x\n[1]: #graphic.elements-sector.y\n[2]: #graphic.elements-sector.rotation\n[3]: #graphic.elements-sector.scaleX\n[4]: #graphic.elements-sector.scaleY\n[5]: #graphic.elements-sector.originX\n[6]: #graphic.elements-sector.originY\n[7]: #graphic.elements-group"
    },
    "elements-sector.rotation": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-sector.x\n[1]: #graphic.elements-sector.y\n[2]: #graphic.elements-sector.rotation\n[3]: #graphic.elements-sector.scaleX\n[4]: #graphic.elements-sector.scaleY\n[5]: #graphic.elements-sector.originX\n[6]: #graphic.elements-sector.originY\n[7]: #graphic.elements-group"
    },
    "elements-sector.scaleX": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-sector.x\n[1]: #graphic.elements-sector.y\n[2]: #graphic.elements-sector.rotation\n[3]: #graphic.elements-sector.scaleX\n[4]: #graphic.elements-sector.scaleY\n[5]: #graphic.elements-sector.originX\n[6]: #graphic.elements-sector.originY\n[7]: #graphic.elements-group"
    },
    "elements-sector.scaleY": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-sector.x\n[1]: #graphic.elements-sector.y\n[2]: #graphic.elements-sector.rotation\n[3]: #graphic.elements-sector.scaleX\n[4]: #graphic.elements-sector.scaleY\n[5]: #graphic.elements-sector.originX\n[6]: #graphic.elements-sector.originY\n[7]: #graphic.elements-group"
    },
    "elements-sector.originX": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-sector.x\n[1]: #graphic.elements-sector.y\n[2]: #graphic.elements-sector.rotation\n[3]: #graphic.elements-sector.scaleX\n[4]: #graphic.elements-sector.scaleY\n[5]: #graphic.elements-sector.originX\n[6]: #graphic.elements-sector.originY\n[7]: #graphic.elements-group"
    },
    "elements-sector.originY": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-sector.x\n[1]: #graphic.elements-sector.y\n[2]: #graphic.elements-sector.rotation\n[3]: #graphic.elements-sector.scaleX\n[4]: #graphic.elements-sector.scaleY\n[5]: #graphic.elements-sector.originX\n[6]: #graphic.elements-sector.originY\n[7]: #graphic.elements-group"
    },
    "elements-sector.left": {
        "desc": " Specify how to be positioned in its parent. When the element is at the top level, the parent is the container of the chart instance. Otherwise, the parent is a group element. Optional values: \n\n* Pixel value: For example, can be a number 30, means 30px.\n* Percent value: For example, can be a string '33%', means the final result should be calculated by this value and the height of its parent.\n* 'center': means position the element in the middle of according to its parent.\n\nOnly one between [left][0] and [right][1] can work. If [left][0] or [right][1] is specified, positioning attributes in [shape][2] (like x, cx) will not work.\n\n[0]: #graphic.elements-sector.left\n[1]: #graphic.elements-sector.right\n[2]: #graphic.elements-sector.shape"
    },
    "elements-sector.right": {
        "desc": " Specify how to be positioned in its parent. When the element is at the top level, the parent is the container of the chart instance. Otherwise, the parent is a group element. Optional values: \n\n* Pixel value: For example, can be a number 30, means 30px.\n* Percent value: For example, can be a string '33%', means the final result should be calculated by this value and the height of its parent.\n* 'center': means position the element in the middle of according to its parent.\n\nOnly one between [left][0] and [right][1] can work. If [left][0] or [right][1] is specified, positioning attributes in [shape][2] (like x, cx) will not work.\n\n[0]: #graphic.elements-sector.left\n[1]: #graphic.elements-sector.right\n[2]: #graphic.elements-sector.shape"
    },
    "elements-sector.top": {
        "desc": " Specify how to be positioned in its parent. When the element is at the top level, the parent is the container of the chart instance. Otherwise, the parent is a group element. Optional values: \n\n* Pixel value: For example, can be a number 30, means 30px.\n* Percent value: For example, can be a string '33%', means the final result should be calculated by this value and the width of its parent.\n* 'middle': means position the element in the middle of according to its parent.\n\nOnly one between [top][0] and [bottom][1] can work. If [top][0] or [bottom][1] is specified, positioning attributes in [shape][2] (like y, cy) will not work.\n\n[0]: #graphic.elements-sector.top\n[1]: #graphic.elements-sector.bottom\n[2]: #graphic.elements-sector.shape"
    },
    "elements-sector.bottom": {
        "desc": " Specify how to be positioned in its parent. When the element is at the top level, the parent is the container of the chart instance. Otherwise, the parent is a group element. Optional values: \n\n* Pixel value: For example, can be a number 30, means 30px.\n* Percent value: For example, can be a string '33%', means the final result should be calculated by this value and the width of its parent.\n* 'middle': means position the element in the middle of according to its parent.\n\nOnly one between [top][0] and [bottom][1] can work. If [top][0] or [bottom][1] is specified, positioning attributes in [shape][2] (like y, cy) will not work.\n\n[0]: #graphic.elements-sector.top\n[1]: #graphic.elements-sector.bottom\n[2]: #graphic.elements-sector.shape"
    },
    "elements-sector.bounding": {
        "desc": " Used to specify whether the entire transformed element (containing children if is group) is confined in its container. See sample: 暂时无法显示 Optional values: \n\n* 'all': (default) Use the transformed bounding box of itself and its descendants to perform position calculation, which confine the entire body in the boundary of its parent.\n* 'raw': Only use the untransformed bounding box of itself (without its descentant) to perform position calculation, which is suitable when the content in the element need to be overflow its parent.\n\n"
    },
    "elements-sector.z": {
        "desc": " z value of the elements, determine the overlap order. "
    },
    "elements-sector.zlevel": {
        "desc": " Determine which canvas layer this element should be in. Notice: Multiple canvas layer may affect performance. "
    },
    "elements-sector.info": {
        "desc": " User defined data, can be visited in event listeners. \n\n    chart.on('click', function (params) {\n        console.log(params.info);\n    });\n    \n\n"
    },
    "elements-sector.silent": {
        "desc": " Whether response to mouse events / touch events. "
    },
    "elements-sector.invisible": {
        "desc": " Whether the element is visible. "
    },
    "elements-sector.ignore": {
        "desc": " Whether the element is totally ignored (neither render nor listen events). "
    },
    "elements-sector.textContent": {
        "desc": " Text block attached to an element and layout based on the element by textConfig. The props the the same as [text][0].\n\n[0]: option.html#graphic.elements-text"
    },
    "elements-sector.textConfig": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "elements-sector.textConfig.position": {
        "desc": " Position of textContent. \n\n* 'left'\n* 'right'\n* 'top'\n* 'bottom'\n* 'inside'\n* 'insideLeft'\n* 'insideRight'\n* 'insideTop'\n* 'insideBottom'\n* 'insideTopLeft'\n* 'insideTopRight'\n* 'insideBottomLeft'\n* 'insideBottomRight'\n* or like [12, 33]\n* or like ['50%', '50%']\n\n"
    },
    "elements-sector.textConfig.rotation": {
        "desc": " Rotation of textContent. In radian. "
    },
    "elements-sector.textConfig.layoutRect": {
        "desc": " Rect that textContent will be positioned. Default to be the bounding box of host element. \n\n    {\n        x: number\n        y: number\n        width: number\n        height: number\n    }\n    \n\n"
    },
    "elements-sector.textConfig.offset": {
        "desc": " Offset of the textContent. The difference of offset and position is that offset will be applied in the rotation. "
    },
    "elements-sector.textConfig.origin": {
        "desc": "origin is relative to the bounding box of the host element. Can be percent value. Relative to the bounding box. If 'center' specified, it will be center of the bounding box. Only available when position and rotation are both set. \n\n* like [12, 33]\n* or like ['50%', '50%']\n* 'center'\n\n"
    },
    "elements-sector.textConfig.distance": {
        "desc": " Distance to the layoutRect。 "
    },
    "elements-sector.textConfig.local": {
        "desc": " If true, it will apply host's transform. "
    },
    "elements-sector.textConfig.insideFill": {
        "desc": "insideFill is a color string or left empty. If a textContent is \"inside\", its final fill will be picked by this priority: textContent.style.fill > textConfig.insideFill > \"auto-calculated-fill\" In most cases, \"auto-calculated-fill\" is white. "
    },
    "elements-sector.textConfig.insideStroke": {
        "desc": "insideStroke is a color string or left empty. If a textContent is \"inside\", its final stroke will be picked by this priority: textContent.style.stroke > textConfig.insideStroke > \"auto-calculated-stroke\" The rule of getting \"auto-calculated-stroke\": \n\n* If\n  * (A) the fill is specified in style (either in textContent.style or textContent.style.rich)\n  * or (B) needed to draw text background (either defined in textContent.style or textContent.style.rich)\n  * \"auto-calculated-stroke\" will be null.\n* Otherwise\n  * \"auto-calculated-stroke\" will be the same as fill of this element if possible, or null.\n\n"
    },
    "elements-sector.textConfig.outsideFill": {
        "desc": "outsideFill is a color string or left empty. If a textContent is \"inside\", its final fill will be picked by this priority: textContent.style.fill > textConfig.outsideFill > #000 "
    },
    "elements-sector.textConfig.outsideStroke": {
        "desc": "outsideStroke is a color string or left empty. If a textContent is not \"inside\", its final stroke will be picked by this priority: textContent.style.stroke > textConfig.outsideStroke > \"auto-calculated-stroke\" The rule of getting \"auto-calculated-stroke\": \n\n* If\n  * (A) the fill is specified in style (either in textContent.style or textContent.style.rich)\n  * or (B) needed to draw text background (either defined in textContent.style or textContent.style.rich)\n  * \"auto-calculated-stroke\" will be null.\n* Otherwise\n  * \"auto-calculated-stroke\" will be a near white color to distinguish \"front end\" label with messy background (like other text label, line or other graphic).\n\n"
    },
    "elements-sector.textConfig.inside": {
        "desc": " Tell echarts that I can make sure this text is inside or not. "
    },
    "elements-sector.cursor": {
        "desc": " The mouse style when mouse hovers on an element, the same as cursor property in CSS. ",
        "uiControl": {
            "type": "enum",
            "options": "'auto','pointer','move'"
        }
    },
    "elements-sector.draggable": {
        "desc": " Can be dragged or not. "
    },
    "elements-sector.progressive": {
        "desc": " Whether use progressive render to improve performance. Usually used when number of element is too large. "
    },
    "elements-sector.shape": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "elements-sector.shape.cx": {
        "desc": " The x value of the center of the element in the coordinate system of its parent. "
    },
    "elements-sector.shape.cy": {
        "desc": " The y value of the center of the element in the coordinate system of its parent. "
    },
    "elements-sector.shape.r": {
        "desc": " Outside radius. "
    },
    "elements-sector.shape.r0": {
        "desc": " Inside radius. "
    },
    "elements-sector.shape.startAngle": {
        "desc": " start angle, in radian. "
    },
    "elements-sector.shape.endAngle": {
        "desc": " end angle, in radian. "
    },
    "elements-sector.shape.clockwise": {
        "desc": " Whether draw clockwise. "
    },
    "elements-sector.style": {
        "desc": " More attributes in style (for example, [rich text][0]), see the style related attributes in [zrender/graphic/Displayable][1]. Notice, the attribute names of the style of graphic elements is derived from zrender, which may be different from the attribute names in echarts label, echarts itemStyle, etc., although they have the same meaning. For example: \n\n* [itemStyle.color][2] => style.fill\n* [itemStyle.borderColor][2] => style.stroke\n* [label.color][2] => style.textFill\n* [label.textBorderColor][3] => style.textStroke\n* ...\n\n\n\n[0]: tutorial.html#Rich%20Text\n[1]: https://ecomfe.github.io/zrender-doc/public/api.html#zrenderdisplayable\n[2]: #series-scatter.label.color\n[3]: #series-scatter.label.textBorderColor"
    },
    "elements-sector.style.fill": {
        "desc": " Color filled in this element. "
    },
    "elements-sector.style.stroke": {
        "desc": " Color of stroke. "
    },
    "elements-sector.style.lineWidth": {
        "desc": " Width of stroke. "
    },
    "elements-sector.style.shadowBlur": {
        "desc": " Width of shadow. "
    },
    "elements-sector.style.shadowOffsetX": {
        "desc": " X offset of shadow. "
    },
    "elements-sector.style.shadowOffsetY": {
        "desc": " Y offset of shadow. "
    },
    "elements-sector.style.shadowColor": {
        "desc": " color of shadow. "
    },
    "elements-sector.focus": {
        "desc": ">  Since > v5.0.0 When it's highlighted, whether to fade out of other data to focus the highlighted. The following configurations are supported: \n\n* 'none' Do not fade out other data, it's by default.\n* 'self' Only focus (not fade out) the element of the currently highlighted data.\n* 'series' Focus on all elements of the series which the currently highlighted data belongs to.\n\n"
    },
    "elements-sector.blurScope": {
        "desc": ">  Since > v5.0.0 The range of fade out when focus is enabled. Support the following configurations \n\n* 'coordinateSystem'\n* 'series'\n* 'global'\n\n"
    },
    "elements-arc": {
        "desc": " Arc element. "
    },
    "elements-arc.type": {
        "desc": " Must be specified when define a graphic element at the first time. Optional values: [image][0], [text][1], [circle][2], [sector][3], [ring][4], [polygon][5], [polyline][6], [rect][7], [line][8], [bezierCurve][9], [arc][10], [group][11],\n\n[0]: #graphic.elements-image\n[1]: #graphic.elements-text\n[2]: #graphic.elements-circle\n[3]: #graphic.elements-sector\n[4]: #graphic.elements-ring\n[5]: #graphic.elements-polygon\n[6]: #graphic.elements-polyline\n[7]: #graphic.elements-rect\n[8]: #graphic.elements-line\n[9]: #graphic.elements-bezierCurve\n[10]: #graphic.elements-arc\n[11]: #graphic.elements-group"
    },
    "elements-arc.id": {
        "desc": " id is used to specifying element when willing to update it. id can be ignored if you do not need it. "
    },
    "elements-arc.$action": {
        "desc": " Specify the operation should be performed to the element when calling setOption. Default value is 'merge', other values can be 'replace' or 'remove'. Optional values: \n\n* 'merge': merge the given option to existing element (if any), otherwise create a new element.\n* 'replace': create a new element according to the given option and replace the existing element (if any).\n* 'remove': delete the existing element (if any).\n\n"
    },
    "elements-arc.x": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-arc.x\n[1]: #graphic.elements-arc.y\n[2]: #graphic.elements-arc.rotation\n[3]: #graphic.elements-arc.scaleX\n[4]: #graphic.elements-arc.scaleY\n[5]: #graphic.elements-arc.originX\n[6]: #graphic.elements-arc.originY\n[7]: #graphic.elements-group"
    },
    "elements-arc.y": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-arc.x\n[1]: #graphic.elements-arc.y\n[2]: #graphic.elements-arc.rotation\n[3]: #graphic.elements-arc.scaleX\n[4]: #graphic.elements-arc.scaleY\n[5]: #graphic.elements-arc.originX\n[6]: #graphic.elements-arc.originY\n[7]: #graphic.elements-group"
    },
    "elements-arc.rotation": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-arc.x\n[1]: #graphic.elements-arc.y\n[2]: #graphic.elements-arc.rotation\n[3]: #graphic.elements-arc.scaleX\n[4]: #graphic.elements-arc.scaleY\n[5]: #graphic.elements-arc.originX\n[6]: #graphic.elements-arc.originY\n[7]: #graphic.elements-group"
    },
    "elements-arc.scaleX": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-arc.x\n[1]: #graphic.elements-arc.y\n[2]: #graphic.elements-arc.rotation\n[3]: #graphic.elements-arc.scaleX\n[4]: #graphic.elements-arc.scaleY\n[5]: #graphic.elements-arc.originX\n[6]: #graphic.elements-arc.originY\n[7]: #graphic.elements-group"
    },
    "elements-arc.scaleY": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-arc.x\n[1]: #graphic.elements-arc.y\n[2]: #graphic.elements-arc.rotation\n[3]: #graphic.elements-arc.scaleX\n[4]: #graphic.elements-arc.scaleY\n[5]: #graphic.elements-arc.originX\n[6]: #graphic.elements-arc.originY\n[7]: #graphic.elements-group"
    },
    "elements-arc.originX": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-arc.x\n[1]: #graphic.elements-arc.y\n[2]: #graphic.elements-arc.rotation\n[3]: #graphic.elements-arc.scaleX\n[4]: #graphic.elements-arc.scaleY\n[5]: #graphic.elements-arc.originX\n[6]: #graphic.elements-arc.originY\n[7]: #graphic.elements-group"
    },
    "elements-arc.originY": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-arc.x\n[1]: #graphic.elements-arc.y\n[2]: #graphic.elements-arc.rotation\n[3]: #graphic.elements-arc.scaleX\n[4]: #graphic.elements-arc.scaleY\n[5]: #graphic.elements-arc.originX\n[6]: #graphic.elements-arc.originY\n[7]: #graphic.elements-group"
    },
    "elements-arc.left": {
        "desc": " Specify how to be positioned in its parent. When the element is at the top level, the parent is the container of the chart instance. Otherwise, the parent is a group element. Optional values: \n\n* Pixel value: For example, can be a number 30, means 30px.\n* Percent value: For example, can be a string '33%', means the final result should be calculated by this value and the height of its parent.\n* 'center': means position the element in the middle of according to its parent.\n\nOnly one between [left][0] and [right][1] can work. If [left][0] or [right][1] is specified, positioning attributes in [shape][2] (like x, cx) will not work.\n\n[0]: #graphic.elements-arc.left\n[1]: #graphic.elements-arc.right\n[2]: #graphic.elements-arc.shape"
    },
    "elements-arc.right": {
        "desc": " Specify how to be positioned in its parent. When the element is at the top level, the parent is the container of the chart instance. Otherwise, the parent is a group element. Optional values: \n\n* Pixel value: For example, can be a number 30, means 30px.\n* Percent value: For example, can be a string '33%', means the final result should be calculated by this value and the height of its parent.\n* 'center': means position the element in the middle of according to its parent.\n\nOnly one between [left][0] and [right][1] can work. If [left][0] or [right][1] is specified, positioning attributes in [shape][2] (like x, cx) will not work.\n\n[0]: #graphic.elements-arc.left\n[1]: #graphic.elements-arc.right\n[2]: #graphic.elements-arc.shape"
    },
    "elements-arc.top": {
        "desc": " Specify how to be positioned in its parent. When the element is at the top level, the parent is the container of the chart instance. Otherwise, the parent is a group element. Optional values: \n\n* Pixel value: For example, can be a number 30, means 30px.\n* Percent value: For example, can be a string '33%', means the final result should be calculated by this value and the width of its parent.\n* 'middle': means position the element in the middle of according to its parent.\n\nOnly one between [top][0] and [bottom][1] can work. If [top][0] or [bottom][1] is specified, positioning attributes in [shape][2] (like y, cy) will not work.\n\n[0]: #graphic.elements-arc.top\n[1]: #graphic.elements-arc.bottom\n[2]: #graphic.elements-arc.shape"
    },
    "elements-arc.bottom": {
        "desc": " Specify how to be positioned in its parent. When the element is at the top level, the parent is the container of the chart instance. Otherwise, the parent is a group element. Optional values: \n\n* Pixel value: For example, can be a number 30, means 30px.\n* Percent value: For example, can be a string '33%', means the final result should be calculated by this value and the width of its parent.\n* 'middle': means position the element in the middle of according to its parent.\n\nOnly one between [top][0] and [bottom][1] can work. If [top][0] or [bottom][1] is specified, positioning attributes in [shape][2] (like y, cy) will not work.\n\n[0]: #graphic.elements-arc.top\n[1]: #graphic.elements-arc.bottom\n[2]: #graphic.elements-arc.shape"
    },
    "elements-arc.bounding": {
        "desc": " Used to specify whether the entire transformed element (containing children if is group) is confined in its container. See sample: 暂时无法显示 Optional values: \n\n* 'all': (default) Use the transformed bounding box of itself and its descendants to perform position calculation, which confine the entire body in the boundary of its parent.\n* 'raw': Only use the untransformed bounding box of itself (without its descentant) to perform position calculation, which is suitable when the content in the element need to be overflow its parent.\n\n"
    },
    "elements-arc.z": {
        "desc": " z value of the elements, determine the overlap order. "
    },
    "elements-arc.zlevel": {
        "desc": " Determine which canvas layer this element should be in. Notice: Multiple canvas layer may affect performance. "
    },
    "elements-arc.info": {
        "desc": " User defined data, can be visited in event listeners. \n\n    chart.on('click', function (params) {\n        console.log(params.info);\n    });\n    \n\n"
    },
    "elements-arc.silent": {
        "desc": " Whether response to mouse events / touch events. "
    },
    "elements-arc.invisible": {
        "desc": " Whether the element is visible. "
    },
    "elements-arc.ignore": {
        "desc": " Whether the element is totally ignored (neither render nor listen events). "
    },
    "elements-arc.textContent": {
        "desc": " Text block attached to an element and layout based on the element by textConfig. The props the the same as [text][0].\n\n[0]: option.html#graphic.elements-text"
    },
    "elements-arc.textConfig": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "elements-arc.textConfig.position": {
        "desc": " Position of textContent. \n\n* 'left'\n* 'right'\n* 'top'\n* 'bottom'\n* 'inside'\n* 'insideLeft'\n* 'insideRight'\n* 'insideTop'\n* 'insideBottom'\n* 'insideTopLeft'\n* 'insideTopRight'\n* 'insideBottomLeft'\n* 'insideBottomRight'\n* or like [12, 33]\n* or like ['50%', '50%']\n\n"
    },
    "elements-arc.textConfig.rotation": {
        "desc": " Rotation of textContent. In radian. "
    },
    "elements-arc.textConfig.layoutRect": {
        "desc": " Rect that textContent will be positioned. Default to be the bounding box of host element. \n\n    {\n        x: number\n        y: number\n        width: number\n        height: number\n    }\n    \n\n"
    },
    "elements-arc.textConfig.offset": {
        "desc": " Offset of the textContent. The difference of offset and position is that offset will be applied in the rotation. "
    },
    "elements-arc.textConfig.origin": {
        "desc": "origin is relative to the bounding box of the host element. Can be percent value. Relative to the bounding box. If 'center' specified, it will be center of the bounding box. Only available when position and rotation are both set. \n\n* like [12, 33]\n* or like ['50%', '50%']\n* 'center'\n\n"
    },
    "elements-arc.textConfig.distance": {
        "desc": " Distance to the layoutRect。 "
    },
    "elements-arc.textConfig.local": {
        "desc": " If true, it will apply host's transform. "
    },
    "elements-arc.textConfig.insideFill": {
        "desc": "insideFill is a color string or left empty. If a textContent is \"inside\", its final fill will be picked by this priority: textContent.style.fill > textConfig.insideFill > \"auto-calculated-fill\" In most cases, \"auto-calculated-fill\" is white. "
    },
    "elements-arc.textConfig.insideStroke": {
        "desc": "insideStroke is a color string or left empty. If a textContent is \"inside\", its final stroke will be picked by this priority: textContent.style.stroke > textConfig.insideStroke > \"auto-calculated-stroke\" The rule of getting \"auto-calculated-stroke\": \n\n* If\n  * (A) the fill is specified in style (either in textContent.style or textContent.style.rich)\n  * or (B) needed to draw text background (either defined in textContent.style or textContent.style.rich)\n  * \"auto-calculated-stroke\" will be null.\n* Otherwise\n  * \"auto-calculated-stroke\" will be the same as fill of this element if possible, or null.\n\n"
    },
    "elements-arc.textConfig.outsideFill": {
        "desc": "outsideFill is a color string or left empty. If a textContent is \"inside\", its final fill will be picked by this priority: textContent.style.fill > textConfig.outsideFill > #000 "
    },
    "elements-arc.textConfig.outsideStroke": {
        "desc": "outsideStroke is a color string or left empty. If a textContent is not \"inside\", its final stroke will be picked by this priority: textContent.style.stroke > textConfig.outsideStroke > \"auto-calculated-stroke\" The rule of getting \"auto-calculated-stroke\": \n\n* If\n  * (A) the fill is specified in style (either in textContent.style or textContent.style.rich)\n  * or (B) needed to draw text background (either defined in textContent.style or textContent.style.rich)\n  * \"auto-calculated-stroke\" will be null.\n* Otherwise\n  * \"auto-calculated-stroke\" will be a near white color to distinguish \"front end\" label with messy background (like other text label, line or other graphic).\n\n"
    },
    "elements-arc.textConfig.inside": {
        "desc": " Tell echarts that I can make sure this text is inside or not. "
    },
    "elements-arc.cursor": {
        "desc": " The mouse style when mouse hovers on an element, the same as cursor property in CSS. ",
        "uiControl": {
            "type": "enum",
            "options": "'auto','pointer','move'"
        }
    },
    "elements-arc.draggable": {
        "desc": " Can be dragged or not. "
    },
    "elements-arc.progressive": {
        "desc": " Whether use progressive render to improve performance. Usually used when number of element is too large. "
    },
    "elements-arc.shape": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "elements-arc.shape.cx": {
        "desc": " The x value of the center of the element in the coordinate system of its parent. "
    },
    "elements-arc.shape.cy": {
        "desc": " The y value of the center of the element in the coordinate system of its parent. "
    },
    "elements-arc.shape.r": {
        "desc": " Outside radius. "
    },
    "elements-arc.shape.r0": {
        "desc": " Inside radius. "
    },
    "elements-arc.shape.startAngle": {
        "desc": " start angle, in radian. "
    },
    "elements-arc.shape.endAngle": {
        "desc": " end angle, in radian. "
    },
    "elements-arc.shape.clockwise": {
        "desc": " Whether draw clockwise. "
    },
    "elements-arc.style": {
        "desc": " More attributes in style (for example, [rich text][0]), see the style related attributes in [zrender/graphic/Displayable][1]. Notice, the attribute names of the style of graphic elements is derived from zrender, which may be different from the attribute names in echarts label, echarts itemStyle, etc., although they have the same meaning. For example: \n\n* [itemStyle.color][2] => style.fill\n* [itemStyle.borderColor][2] => style.stroke\n* [label.color][2] => style.textFill\n* [label.textBorderColor][3] => style.textStroke\n* ...\n\n\n\n[0]: tutorial.html#Rich%20Text\n[1]: https://ecomfe.github.io/zrender-doc/public/api.html#zrenderdisplayable\n[2]: #series-scatter.label.color\n[3]: #series-scatter.label.textBorderColor"
    },
    "elements-arc.style.fill": {
        "desc": " Color filled in this element. "
    },
    "elements-arc.style.stroke": {
        "desc": " Color of stroke. "
    },
    "elements-arc.style.lineWidth": {
        "desc": " Width of stroke. "
    },
    "elements-arc.style.shadowBlur": {
        "desc": " Width of shadow. "
    },
    "elements-arc.style.shadowOffsetX": {
        "desc": " X offset of shadow. "
    },
    "elements-arc.style.shadowOffsetY": {
        "desc": " Y offset of shadow. "
    },
    "elements-arc.style.shadowColor": {
        "desc": " color of shadow. "
    },
    "elements-arc.focus": {
        "desc": ">  Since > v5.0.0 When it's highlighted, whether to fade out of other data to focus the highlighted. The following configurations are supported: \n\n* 'none' Do not fade out other data, it's by default.\n* 'self' Only focus (not fade out) the element of the currently highlighted data.\n* 'series' Focus on all elements of the series which the currently highlighted data belongs to.\n\n"
    },
    "elements-arc.blurScope": {
        "desc": ">  Since > v5.0.0 The range of fade out when focus is enabled. Support the following configurations \n\n* 'coordinateSystem'\n* 'series'\n* 'global'\n\n"
    },
    "elements-polygon": {
        "desc": " Polygon element. "
    },
    "elements-polygon.type": {
        "desc": " Must be specified when define a graphic element at the first time. Optional values: [image][0], [text][1], [circle][2], [sector][3], [ring][4], [polygon][5], [polyline][6], [rect][7], [line][8], [bezierCurve][9], [arc][10], [group][11],\n\n[0]: #graphic.elements-image\n[1]: #graphic.elements-text\n[2]: #graphic.elements-circle\n[3]: #graphic.elements-sector\n[4]: #graphic.elements-ring\n[5]: #graphic.elements-polygon\n[6]: #graphic.elements-polyline\n[7]: #graphic.elements-rect\n[8]: #graphic.elements-line\n[9]: #graphic.elements-bezierCurve\n[10]: #graphic.elements-arc\n[11]: #graphic.elements-group"
    },
    "elements-polygon.id": {
        "desc": " id is used to specifying element when willing to update it. id can be ignored if you do not need it. "
    },
    "elements-polygon.$action": {
        "desc": " Specify the operation should be performed to the element when calling setOption. Default value is 'merge', other values can be 'replace' or 'remove'. Optional values: \n\n* 'merge': merge the given option to existing element (if any), otherwise create a new element.\n* 'replace': create a new element according to the given option and replace the existing element (if any).\n* 'remove': delete the existing element (if any).\n\n"
    },
    "elements-polygon.x": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-polygon.x\n[1]: #graphic.elements-polygon.y\n[2]: #graphic.elements-polygon.rotation\n[3]: #graphic.elements-polygon.scaleX\n[4]: #graphic.elements-polygon.scaleY\n[5]: #graphic.elements-polygon.originX\n[6]: #graphic.elements-polygon.originY\n[7]: #graphic.elements-group"
    },
    "elements-polygon.y": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-polygon.x\n[1]: #graphic.elements-polygon.y\n[2]: #graphic.elements-polygon.rotation\n[3]: #graphic.elements-polygon.scaleX\n[4]: #graphic.elements-polygon.scaleY\n[5]: #graphic.elements-polygon.originX\n[6]: #graphic.elements-polygon.originY\n[7]: #graphic.elements-group"
    },
    "elements-polygon.rotation": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-polygon.x\n[1]: #graphic.elements-polygon.y\n[2]: #graphic.elements-polygon.rotation\n[3]: #graphic.elements-polygon.scaleX\n[4]: #graphic.elements-polygon.scaleY\n[5]: #graphic.elements-polygon.originX\n[6]: #graphic.elements-polygon.originY\n[7]: #graphic.elements-group"
    },
    "elements-polygon.scaleX": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-polygon.x\n[1]: #graphic.elements-polygon.y\n[2]: #graphic.elements-polygon.rotation\n[3]: #graphic.elements-polygon.scaleX\n[4]: #graphic.elements-polygon.scaleY\n[5]: #graphic.elements-polygon.originX\n[6]: #graphic.elements-polygon.originY\n[7]: #graphic.elements-group"
    },
    "elements-polygon.scaleY": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-polygon.x\n[1]: #graphic.elements-polygon.y\n[2]: #graphic.elements-polygon.rotation\n[3]: #graphic.elements-polygon.scaleX\n[4]: #graphic.elements-polygon.scaleY\n[5]: #graphic.elements-polygon.originX\n[6]: #graphic.elements-polygon.originY\n[7]: #graphic.elements-group"
    },
    "elements-polygon.originX": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-polygon.x\n[1]: #graphic.elements-polygon.y\n[2]: #graphic.elements-polygon.rotation\n[3]: #graphic.elements-polygon.scaleX\n[4]: #graphic.elements-polygon.scaleY\n[5]: #graphic.elements-polygon.originX\n[6]: #graphic.elements-polygon.originY\n[7]: #graphic.elements-group"
    },
    "elements-polygon.originY": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-polygon.x\n[1]: #graphic.elements-polygon.y\n[2]: #graphic.elements-polygon.rotation\n[3]: #graphic.elements-polygon.scaleX\n[4]: #graphic.elements-polygon.scaleY\n[5]: #graphic.elements-polygon.originX\n[6]: #graphic.elements-polygon.originY\n[7]: #graphic.elements-group"
    },
    "elements-polygon.left": {
        "desc": " Specify how to be positioned in its parent. When the element is at the top level, the parent is the container of the chart instance. Otherwise, the parent is a group element. Optional values: \n\n* Pixel value: For example, can be a number 30, means 30px.\n* Percent value: For example, can be a string '33%', means the final result should be calculated by this value and the height of its parent.\n* 'center': means position the element in the middle of according to its parent.\n\nOnly one between [left][0] and [right][1] can work. If [left][0] or [right][1] is specified, positioning attributes in [shape][2] (like x, cx) will not work.\n\n[0]: #graphic.elements-polygon.left\n[1]: #graphic.elements-polygon.right\n[2]: #graphic.elements-polygon.shape"
    },
    "elements-polygon.right": {
        "desc": " Specify how to be positioned in its parent. When the element is at the top level, the parent is the container of the chart instance. Otherwise, the parent is a group element. Optional values: \n\n* Pixel value: For example, can be a number 30, means 30px.\n* Percent value: For example, can be a string '33%', means the final result should be calculated by this value and the height of its parent.\n* 'center': means position the element in the middle of according to its parent.\n\nOnly one between [left][0] and [right][1] can work. If [left][0] or [right][1] is specified, positioning attributes in [shape][2] (like x, cx) will not work.\n\n[0]: #graphic.elements-polygon.left\n[1]: #graphic.elements-polygon.right\n[2]: #graphic.elements-polygon.shape"
    },
    "elements-polygon.top": {
        "desc": " Specify how to be positioned in its parent. When the element is at the top level, the parent is the container of the chart instance. Otherwise, the parent is a group element. Optional values: \n\n* Pixel value: For example, can be a number 30, means 30px.\n* Percent value: For example, can be a string '33%', means the final result should be calculated by this value and the width of its parent.\n* 'middle': means position the element in the middle of according to its parent.\n\nOnly one between [top][0] and [bottom][1] can work. If [top][0] or [bottom][1] is specified, positioning attributes in [shape][2] (like y, cy) will not work.\n\n[0]: #graphic.elements-polygon.top\n[1]: #graphic.elements-polygon.bottom\n[2]: #graphic.elements-polygon.shape"
    },
    "elements-polygon.bottom": {
        "desc": " Specify how to be positioned in its parent. When the element is at the top level, the parent is the container of the chart instance. Otherwise, the parent is a group element. Optional values: \n\n* Pixel value: For example, can be a number 30, means 30px.\n* Percent value: For example, can be a string '33%', means the final result should be calculated by this value and the width of its parent.\n* 'middle': means position the element in the middle of according to its parent.\n\nOnly one between [top][0] and [bottom][1] can work. If [top][0] or [bottom][1] is specified, positioning attributes in [shape][2] (like y, cy) will not work.\n\n[0]: #graphic.elements-polygon.top\n[1]: #graphic.elements-polygon.bottom\n[2]: #graphic.elements-polygon.shape"
    },
    "elements-polygon.bounding": {
        "desc": " Used to specify whether the entire transformed element (containing children if is group) is confined in its container. See sample: 暂时无法显示 Optional values: \n\n* 'all': (default) Use the transformed bounding box of itself and its descendants to perform position calculation, which confine the entire body in the boundary of its parent.\n* 'raw': Only use the untransformed bounding box of itself (without its descentant) to perform position calculation, which is suitable when the content in the element need to be overflow its parent.\n\n"
    },
    "elements-polygon.z": {
        "desc": " z value of the elements, determine the overlap order. "
    },
    "elements-polygon.zlevel": {
        "desc": " Determine which canvas layer this element should be in. Notice: Multiple canvas layer may affect performance. "
    },
    "elements-polygon.info": {
        "desc": " User defined data, can be visited in event listeners. \n\n    chart.on('click', function (params) {\n        console.log(params.info);\n    });\n    \n\n"
    },
    "elements-polygon.silent": {
        "desc": " Whether response to mouse events / touch events. "
    },
    "elements-polygon.invisible": {
        "desc": " Whether the element is visible. "
    },
    "elements-polygon.ignore": {
        "desc": " Whether the element is totally ignored (neither render nor listen events). "
    },
    "elements-polygon.textContent": {
        "desc": " Text block attached to an element and layout based on the element by textConfig. The props the the same as [text][0].\n\n[0]: option.html#graphic.elements-text"
    },
    "elements-polygon.textConfig": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "elements-polygon.textConfig.position": {
        "desc": " Position of textContent. \n\n* 'left'\n* 'right'\n* 'top'\n* 'bottom'\n* 'inside'\n* 'insideLeft'\n* 'insideRight'\n* 'insideTop'\n* 'insideBottom'\n* 'insideTopLeft'\n* 'insideTopRight'\n* 'insideBottomLeft'\n* 'insideBottomRight'\n* or like [12, 33]\n* or like ['50%', '50%']\n\n"
    },
    "elements-polygon.textConfig.rotation": {
        "desc": " Rotation of textContent. In radian. "
    },
    "elements-polygon.textConfig.layoutRect": {
        "desc": " Rect that textContent will be positioned. Default to be the bounding box of host element. \n\n    {\n        x: number\n        y: number\n        width: number\n        height: number\n    }\n    \n\n"
    },
    "elements-polygon.textConfig.offset": {
        "desc": " Offset of the textContent. The difference of offset and position is that offset will be applied in the rotation. "
    },
    "elements-polygon.textConfig.origin": {
        "desc": "origin is relative to the bounding box of the host element. Can be percent value. Relative to the bounding box. If 'center' specified, it will be center of the bounding box. Only available when position and rotation are both set. \n\n* like [12, 33]\n* or like ['50%', '50%']\n* 'center'\n\n"
    },
    "elements-polygon.textConfig.distance": {
        "desc": " Distance to the layoutRect。 "
    },
    "elements-polygon.textConfig.local": {
        "desc": " If true, it will apply host's transform. "
    },
    "elements-polygon.textConfig.insideFill": {
        "desc": "insideFill is a color string or left empty. If a textContent is \"inside\", its final fill will be picked by this priority: textContent.style.fill > textConfig.insideFill > \"auto-calculated-fill\" In most cases, \"auto-calculated-fill\" is white. "
    },
    "elements-polygon.textConfig.insideStroke": {
        "desc": "insideStroke is a color string or left empty. If a textContent is \"inside\", its final stroke will be picked by this priority: textContent.style.stroke > textConfig.insideStroke > \"auto-calculated-stroke\" The rule of getting \"auto-calculated-stroke\": \n\n* If\n  * (A) the fill is specified in style (either in textContent.style or textContent.style.rich)\n  * or (B) needed to draw text background (either defined in textContent.style or textContent.style.rich)\n  * \"auto-calculated-stroke\" will be null.\n* Otherwise\n  * \"auto-calculated-stroke\" will be the same as fill of this element if possible, or null.\n\n"
    },
    "elements-polygon.textConfig.outsideFill": {
        "desc": "outsideFill is a color string or left empty. If a textContent is \"inside\", its final fill will be picked by this priority: textContent.style.fill > textConfig.outsideFill > #000 "
    },
    "elements-polygon.textConfig.outsideStroke": {
        "desc": "outsideStroke is a color string or left empty. If a textContent is not \"inside\", its final stroke will be picked by this priority: textContent.style.stroke > textConfig.outsideStroke > \"auto-calculated-stroke\" The rule of getting \"auto-calculated-stroke\": \n\n* If\n  * (A) the fill is specified in style (either in textContent.style or textContent.style.rich)\n  * or (B) needed to draw text background (either defined in textContent.style or textContent.style.rich)\n  * \"auto-calculated-stroke\" will be null.\n* Otherwise\n  * \"auto-calculated-stroke\" will be a near white color to distinguish \"front end\" label with messy background (like other text label, line or other graphic).\n\n"
    },
    "elements-polygon.textConfig.inside": {
        "desc": " Tell echarts that I can make sure this text is inside or not. "
    },
    "elements-polygon.cursor": {
        "desc": " The mouse style when mouse hovers on an element, the same as cursor property in CSS. ",
        "uiControl": {
            "type": "enum",
            "options": "'auto','pointer','move'"
        }
    },
    "elements-polygon.draggable": {
        "desc": " Can be dragged or not. "
    },
    "elements-polygon.progressive": {
        "desc": " Whether use progressive render to improve performance. Usually used when number of element is too large. "
    },
    "elements-polygon.shape": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "elements-polygon.shape.points": {
        "desc": " A list of points, which defines the shape, like [[22, 44], [44, 55], [11, 44], ...]. "
    },
    "elements-polygon.shape.smooth": {
        "desc": " Whether smooth the line. \n\n* If the value is number, bezier interpolation is used, and the value specified the level of smooth, which is in the range of [0, 1].\n* If the value is 'spline', Catmull-Rom spline interpolation is used.\n\n"
    },
    "elements-polygon.shape.smoothConstraint": {
        "desc": " Whether prevent the smooth process cause the line out of the bounding box. Only works when smooth is number (bezier smooth). "
    },
    "elements-polygon.style": {
        "desc": " More attributes in style (for example, [rich text][0]), see the style related attributes in [zrender/graphic/Displayable][1]. Notice, the attribute names of the style of graphic elements is derived from zrender, which may be different from the attribute names in echarts label, echarts itemStyle, etc., although they have the same meaning. For example: \n\n* [itemStyle.color][2] => style.fill\n* [itemStyle.borderColor][2] => style.stroke\n* [label.color][2] => style.textFill\n* [label.textBorderColor][3] => style.textStroke\n* ...\n\n\n\n[0]: tutorial.html#Rich%20Text\n[1]: https://ecomfe.github.io/zrender-doc/public/api.html#zrenderdisplayable\n[2]: #series-scatter.label.color\n[3]: #series-scatter.label.textBorderColor"
    },
    "elements-polygon.style.fill": {
        "desc": " Color filled in this element. "
    },
    "elements-polygon.style.stroke": {
        "desc": " Color of stroke. "
    },
    "elements-polygon.style.lineWidth": {
        "desc": " Width of stroke. "
    },
    "elements-polygon.style.shadowBlur": {
        "desc": " Width of shadow. "
    },
    "elements-polygon.style.shadowOffsetX": {
        "desc": " X offset of shadow. "
    },
    "elements-polygon.style.shadowOffsetY": {
        "desc": " Y offset of shadow. "
    },
    "elements-polygon.style.shadowColor": {
        "desc": " color of shadow. "
    },
    "elements-polygon.focus": {
        "desc": ">  Since > v5.0.0 When it's highlighted, whether to fade out of other data to focus the highlighted. The following configurations are supported: \n\n* 'none' Do not fade out other data, it's by default.\n* 'self' Only focus (not fade out) the element of the currently highlighted data.\n* 'series' Focus on all elements of the series which the currently highlighted data belongs to.\n\n"
    },
    "elements-polygon.blurScope": {
        "desc": ">  Since > v5.0.0 The range of fade out when focus is enabled. Support the following configurations \n\n* 'coordinateSystem'\n* 'series'\n* 'global'\n\n"
    },
    "elements-polyline": {
        "desc": " Polyline element. "
    },
    "elements-polyline.type": {
        "desc": " Must be specified when define a graphic element at the first time. Optional values: [image][0], [text][1], [circle][2], [sector][3], [ring][4], [polygon][5], [polyline][6], [rect][7], [line][8], [bezierCurve][9], [arc][10], [group][11],\n\n[0]: #graphic.elements-image\n[1]: #graphic.elements-text\n[2]: #graphic.elements-circle\n[3]: #graphic.elements-sector\n[4]: #graphic.elements-ring\n[5]: #graphic.elements-polygon\n[6]: #graphic.elements-polyline\n[7]: #graphic.elements-rect\n[8]: #graphic.elements-line\n[9]: #graphic.elements-bezierCurve\n[10]: #graphic.elements-arc\n[11]: #graphic.elements-group"
    },
    "elements-polyline.id": {
        "desc": " id is used to specifying element when willing to update it. id can be ignored if you do not need it. "
    },
    "elements-polyline.$action": {
        "desc": " Specify the operation should be performed to the element when calling setOption. Default value is 'merge', other values can be 'replace' or 'remove'. Optional values: \n\n* 'merge': merge the given option to existing element (if any), otherwise create a new element.\n* 'replace': create a new element according to the given option and replace the existing element (if any).\n* 'remove': delete the existing element (if any).\n\n"
    },
    "elements-polyline.x": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-polyline.x\n[1]: #graphic.elements-polyline.y\n[2]: #graphic.elements-polyline.rotation\n[3]: #graphic.elements-polyline.scaleX\n[4]: #graphic.elements-polyline.scaleY\n[5]: #graphic.elements-polyline.originX\n[6]: #graphic.elements-polyline.originY\n[7]: #graphic.elements-group"
    },
    "elements-polyline.y": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-polyline.x\n[1]: #graphic.elements-polyline.y\n[2]: #graphic.elements-polyline.rotation\n[3]: #graphic.elements-polyline.scaleX\n[4]: #graphic.elements-polyline.scaleY\n[5]: #graphic.elements-polyline.originX\n[6]: #graphic.elements-polyline.originY\n[7]: #graphic.elements-group"
    },
    "elements-polyline.rotation": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-polyline.x\n[1]: #graphic.elements-polyline.y\n[2]: #graphic.elements-polyline.rotation\n[3]: #graphic.elements-polyline.scaleX\n[4]: #graphic.elements-polyline.scaleY\n[5]: #graphic.elements-polyline.originX\n[6]: #graphic.elements-polyline.originY\n[7]: #graphic.elements-group"
    },
    "elements-polyline.scaleX": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-polyline.x\n[1]: #graphic.elements-polyline.y\n[2]: #graphic.elements-polyline.rotation\n[3]: #graphic.elements-polyline.scaleX\n[4]: #graphic.elements-polyline.scaleY\n[5]: #graphic.elements-polyline.originX\n[6]: #graphic.elements-polyline.originY\n[7]: #graphic.elements-group"
    },
    "elements-polyline.scaleY": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-polyline.x\n[1]: #graphic.elements-polyline.y\n[2]: #graphic.elements-polyline.rotation\n[3]: #graphic.elements-polyline.scaleX\n[4]: #graphic.elements-polyline.scaleY\n[5]: #graphic.elements-polyline.originX\n[6]: #graphic.elements-polyline.originY\n[7]: #graphic.elements-group"
    },
    "elements-polyline.originX": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-polyline.x\n[1]: #graphic.elements-polyline.y\n[2]: #graphic.elements-polyline.rotation\n[3]: #graphic.elements-polyline.scaleX\n[4]: #graphic.elements-polyline.scaleY\n[5]: #graphic.elements-polyline.originX\n[6]: #graphic.elements-polyline.originY\n[7]: #graphic.elements-group"
    },
    "elements-polyline.originY": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-polyline.x\n[1]: #graphic.elements-polyline.y\n[2]: #graphic.elements-polyline.rotation\n[3]: #graphic.elements-polyline.scaleX\n[4]: #graphic.elements-polyline.scaleY\n[5]: #graphic.elements-polyline.originX\n[6]: #graphic.elements-polyline.originY\n[7]: #graphic.elements-group"
    },
    "elements-polyline.left": {
        "desc": " Specify how to be positioned in its parent. When the element is at the top level, the parent is the container of the chart instance. Otherwise, the parent is a group element. Optional values: \n\n* Pixel value: For example, can be a number 30, means 30px.\n* Percent value: For example, can be a string '33%', means the final result should be calculated by this value and the height of its parent.\n* 'center': means position the element in the middle of according to its parent.\n\nOnly one between [left][0] and [right][1] can work. If [left][0] or [right][1] is specified, positioning attributes in [shape][2] (like x, cx) will not work.\n\n[0]: #graphic.elements-polyline.left\n[1]: #graphic.elements-polyline.right\n[2]: #graphic.elements-polyline.shape"
    },
    "elements-polyline.right": {
        "desc": " Specify how to be positioned in its parent. When the element is at the top level, the parent is the container of the chart instance. Otherwise, the parent is a group element. Optional values: \n\n* Pixel value: For example, can be a number 30, means 30px.\n* Percent value: For example, can be a string '33%', means the final result should be calculated by this value and the height of its parent.\n* 'center': means position the element in the middle of according to its parent.\n\nOnly one between [left][0] and [right][1] can work. If [left][0] or [right][1] is specified, positioning attributes in [shape][2] (like x, cx) will not work.\n\n[0]: #graphic.elements-polyline.left\n[1]: #graphic.elements-polyline.right\n[2]: #graphic.elements-polyline.shape"
    },
    "elements-polyline.top": {
        "desc": " Specify how to be positioned in its parent. When the element is at the top level, the parent is the container of the chart instance. Otherwise, the parent is a group element. Optional values: \n\n* Pixel value: For example, can be a number 30, means 30px.\n* Percent value: For example, can be a string '33%', means the final result should be calculated by this value and the width of its parent.\n* 'middle': means position the element in the middle of according to its parent.\n\nOnly one between [top][0] and [bottom][1] can work. If [top][0] or [bottom][1] is specified, positioning attributes in [shape][2] (like y, cy) will not work.\n\n[0]: #graphic.elements-polyline.top\n[1]: #graphic.elements-polyline.bottom\n[2]: #graphic.elements-polyline.shape"
    },
    "elements-polyline.bottom": {
        "desc": " Specify how to be positioned in its parent. When the element is at the top level, the parent is the container of the chart instance. Otherwise, the parent is a group element. Optional values: \n\n* Pixel value: For example, can be a number 30, means 30px.\n* Percent value: For example, can be a string '33%', means the final result should be calculated by this value and the width of its parent.\n* 'middle': means position the element in the middle of according to its parent.\n\nOnly one between [top][0] and [bottom][1] can work. If [top][0] or [bottom][1] is specified, positioning attributes in [shape][2] (like y, cy) will not work.\n\n[0]: #graphic.elements-polyline.top\n[1]: #graphic.elements-polyline.bottom\n[2]: #graphic.elements-polyline.shape"
    },
    "elements-polyline.bounding": {
        "desc": " Used to specify whether the entire transformed element (containing children if is group) is confined in its container. See sample: 暂时无法显示 Optional values: \n\n* 'all': (default) Use the transformed bounding box of itself and its descendants to perform position calculation, which confine the entire body in the boundary of its parent.\n* 'raw': Only use the untransformed bounding box of itself (without its descentant) to perform position calculation, which is suitable when the content in the element need to be overflow its parent.\n\n"
    },
    "elements-polyline.z": {
        "desc": " z value of the elements, determine the overlap order. "
    },
    "elements-polyline.zlevel": {
        "desc": " Determine which canvas layer this element should be in. Notice: Multiple canvas layer may affect performance. "
    },
    "elements-polyline.info": {
        "desc": " User defined data, can be visited in event listeners. \n\n    chart.on('click', function (params) {\n        console.log(params.info);\n    });\n    \n\n"
    },
    "elements-polyline.silent": {
        "desc": " Whether response to mouse events / touch events. "
    },
    "elements-polyline.invisible": {
        "desc": " Whether the element is visible. "
    },
    "elements-polyline.ignore": {
        "desc": " Whether the element is totally ignored (neither render nor listen events). "
    },
    "elements-polyline.textContent": {
        "desc": " Text block attached to an element and layout based on the element by textConfig. The props the the same as [text][0].\n\n[0]: option.html#graphic.elements-text"
    },
    "elements-polyline.textConfig": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "elements-polyline.textConfig.position": {
        "desc": " Position of textContent. \n\n* 'left'\n* 'right'\n* 'top'\n* 'bottom'\n* 'inside'\n* 'insideLeft'\n* 'insideRight'\n* 'insideTop'\n* 'insideBottom'\n* 'insideTopLeft'\n* 'insideTopRight'\n* 'insideBottomLeft'\n* 'insideBottomRight'\n* or like [12, 33]\n* or like ['50%', '50%']\n\n"
    },
    "elements-polyline.textConfig.rotation": {
        "desc": " Rotation of textContent. In radian. "
    },
    "elements-polyline.textConfig.layoutRect": {
        "desc": " Rect that textContent will be positioned. Default to be the bounding box of host element. \n\n    {\n        x: number\n        y: number\n        width: number\n        height: number\n    }\n    \n\n"
    },
    "elements-polyline.textConfig.offset": {
        "desc": " Offset of the textContent. The difference of offset and position is that offset will be applied in the rotation. "
    },
    "elements-polyline.textConfig.origin": {
        "desc": "origin is relative to the bounding box of the host element. Can be percent value. Relative to the bounding box. If 'center' specified, it will be center of the bounding box. Only available when position and rotation are both set. \n\n* like [12, 33]\n* or like ['50%', '50%']\n* 'center'\n\n"
    },
    "elements-polyline.textConfig.distance": {
        "desc": " Distance to the layoutRect。 "
    },
    "elements-polyline.textConfig.local": {
        "desc": " If true, it will apply host's transform. "
    },
    "elements-polyline.textConfig.insideFill": {
        "desc": "insideFill is a color string or left empty. If a textContent is \"inside\", its final fill will be picked by this priority: textContent.style.fill > textConfig.insideFill > \"auto-calculated-fill\" In most cases, \"auto-calculated-fill\" is white. "
    },
    "elements-polyline.textConfig.insideStroke": {
        "desc": "insideStroke is a color string or left empty. If a textContent is \"inside\", its final stroke will be picked by this priority: textContent.style.stroke > textConfig.insideStroke > \"auto-calculated-stroke\" The rule of getting \"auto-calculated-stroke\": \n\n* If\n  * (A) the fill is specified in style (either in textContent.style or textContent.style.rich)\n  * or (B) needed to draw text background (either defined in textContent.style or textContent.style.rich)\n  * \"auto-calculated-stroke\" will be null.\n* Otherwise\n  * \"auto-calculated-stroke\" will be the same as fill of this element if possible, or null.\n\n"
    },
    "elements-polyline.textConfig.outsideFill": {
        "desc": "outsideFill is a color string or left empty. If a textContent is \"inside\", its final fill will be picked by this priority: textContent.style.fill > textConfig.outsideFill > #000 "
    },
    "elements-polyline.textConfig.outsideStroke": {
        "desc": "outsideStroke is a color string or left empty. If a textContent is not \"inside\", its final stroke will be picked by this priority: textContent.style.stroke > textConfig.outsideStroke > \"auto-calculated-stroke\" The rule of getting \"auto-calculated-stroke\": \n\n* If\n  * (A) the fill is specified in style (either in textContent.style or textContent.style.rich)\n  * or (B) needed to draw text background (either defined in textContent.style or textContent.style.rich)\n  * \"auto-calculated-stroke\" will be null.\n* Otherwise\n  * \"auto-calculated-stroke\" will be a near white color to distinguish \"front end\" label with messy background (like other text label, line or other graphic).\n\n"
    },
    "elements-polyline.textConfig.inside": {
        "desc": " Tell echarts that I can make sure this text is inside or not. "
    },
    "elements-polyline.cursor": {
        "desc": " The mouse style when mouse hovers on an element, the same as cursor property in CSS. ",
        "uiControl": {
            "type": "enum",
            "options": "'auto','pointer','move'"
        }
    },
    "elements-polyline.draggable": {
        "desc": " Can be dragged or not. "
    },
    "elements-polyline.progressive": {
        "desc": " Whether use progressive render to improve performance. Usually used when number of element is too large. "
    },
    "elements-polyline.shape": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "elements-polyline.shape.points": {
        "desc": " A list of points, which defines the shape, like [[22, 44], [44, 55], [11, 44], ...]. "
    },
    "elements-polyline.shape.smooth": {
        "desc": " Whether smooth the line. \n\n* If the value is number, bezier interpolation is used, and the value specified the level of smooth, which is in the range of [0, 1].\n* If the value is 'spline', Catmull-Rom spline interpolation is used.\n\n"
    },
    "elements-polyline.shape.smoothConstraint": {
        "desc": " Whether prevent the smooth process cause the line out of the bounding box. Only works when smooth is number (bezier smooth). "
    },
    "elements-polyline.style": {
        "desc": " More attributes in style (for example, [rich text][0]), see the style related attributes in [zrender/graphic/Displayable][1]. Notice, the attribute names of the style of graphic elements is derived from zrender, which may be different from the attribute names in echarts label, echarts itemStyle, etc., although they have the same meaning. For example: \n\n* [itemStyle.color][2] => style.fill\n* [itemStyle.borderColor][2] => style.stroke\n* [label.color][2] => style.textFill\n* [label.textBorderColor][3] => style.textStroke\n* ...\n\n\n\n[0]: tutorial.html#Rich%20Text\n[1]: https://ecomfe.github.io/zrender-doc/public/api.html#zrenderdisplayable\n[2]: #series-scatter.label.color\n[3]: #series-scatter.label.textBorderColor"
    },
    "elements-polyline.style.fill": {
        "desc": " Color filled in this element. "
    },
    "elements-polyline.style.stroke": {
        "desc": " Color of stroke. "
    },
    "elements-polyline.style.lineWidth": {
        "desc": " Width of stroke. "
    },
    "elements-polyline.style.shadowBlur": {
        "desc": " Width of shadow. "
    },
    "elements-polyline.style.shadowOffsetX": {
        "desc": " X offset of shadow. "
    },
    "elements-polyline.style.shadowOffsetY": {
        "desc": " Y offset of shadow. "
    },
    "elements-polyline.style.shadowColor": {
        "desc": " color of shadow. "
    },
    "elements-polyline.focus": {
        "desc": ">  Since > v5.0.0 When it's highlighted, whether to fade out of other data to focus the highlighted. The following configurations are supported: \n\n* 'none' Do not fade out other data, it's by default.\n* 'self' Only focus (not fade out) the element of the currently highlighted data.\n* 'series' Focus on all elements of the series which the currently highlighted data belongs to.\n\n"
    },
    "elements-polyline.blurScope": {
        "desc": ">  Since > v5.0.0 The range of fade out when focus is enabled. Support the following configurations \n\n* 'coordinateSystem'\n* 'series'\n* 'global'\n\n"
    },
    "elements-line": {
        "desc": " Line element. "
    },
    "elements-line.type": {
        "desc": " Must be specified when define a graphic element at the first time. Optional values: [image][0], [text][1], [circle][2], [sector][3], [ring][4], [polygon][5], [polyline][6], [rect][7], [line][8], [bezierCurve][9], [arc][10], [group][11],\n\n[0]: #graphic.elements-image\n[1]: #graphic.elements-text\n[2]: #graphic.elements-circle\n[3]: #graphic.elements-sector\n[4]: #graphic.elements-ring\n[5]: #graphic.elements-polygon\n[6]: #graphic.elements-polyline\n[7]: #graphic.elements-rect\n[8]: #graphic.elements-line\n[9]: #graphic.elements-bezierCurve\n[10]: #graphic.elements-arc\n[11]: #graphic.elements-group"
    },
    "elements-line.id": {
        "desc": " id is used to specifying element when willing to update it. id can be ignored if you do not need it. "
    },
    "elements-line.$action": {
        "desc": " Specify the operation should be performed to the element when calling setOption. Default value is 'merge', other values can be 'replace' or 'remove'. Optional values: \n\n* 'merge': merge the given option to existing element (if any), otherwise create a new element.\n* 'replace': create a new element according to the given option and replace the existing element (if any).\n* 'remove': delete the existing element (if any).\n\n"
    },
    "elements-line.x": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-line.x\n[1]: #graphic.elements-line.y\n[2]: #graphic.elements-line.rotation\n[3]: #graphic.elements-line.scaleX\n[4]: #graphic.elements-line.scaleY\n[5]: #graphic.elements-line.originX\n[6]: #graphic.elements-line.originY\n[7]: #graphic.elements-group"
    },
    "elements-line.y": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-line.x\n[1]: #graphic.elements-line.y\n[2]: #graphic.elements-line.rotation\n[3]: #graphic.elements-line.scaleX\n[4]: #graphic.elements-line.scaleY\n[5]: #graphic.elements-line.originX\n[6]: #graphic.elements-line.originY\n[7]: #graphic.elements-group"
    },
    "elements-line.rotation": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-line.x\n[1]: #graphic.elements-line.y\n[2]: #graphic.elements-line.rotation\n[3]: #graphic.elements-line.scaleX\n[4]: #graphic.elements-line.scaleY\n[5]: #graphic.elements-line.originX\n[6]: #graphic.elements-line.originY\n[7]: #graphic.elements-group"
    },
    "elements-line.scaleX": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-line.x\n[1]: #graphic.elements-line.y\n[2]: #graphic.elements-line.rotation\n[3]: #graphic.elements-line.scaleX\n[4]: #graphic.elements-line.scaleY\n[5]: #graphic.elements-line.originX\n[6]: #graphic.elements-line.originY\n[7]: #graphic.elements-group"
    },
    "elements-line.scaleY": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-line.x\n[1]: #graphic.elements-line.y\n[2]: #graphic.elements-line.rotation\n[3]: #graphic.elements-line.scaleX\n[4]: #graphic.elements-line.scaleY\n[5]: #graphic.elements-line.originX\n[6]: #graphic.elements-line.originY\n[7]: #graphic.elements-group"
    },
    "elements-line.originX": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-line.x\n[1]: #graphic.elements-line.y\n[2]: #graphic.elements-line.rotation\n[3]: #graphic.elements-line.scaleX\n[4]: #graphic.elements-line.scaleY\n[5]: #graphic.elements-line.originX\n[6]: #graphic.elements-line.originY\n[7]: #graphic.elements-group"
    },
    "elements-line.originY": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-line.x\n[1]: #graphic.elements-line.y\n[2]: #graphic.elements-line.rotation\n[3]: #graphic.elements-line.scaleX\n[4]: #graphic.elements-line.scaleY\n[5]: #graphic.elements-line.originX\n[6]: #graphic.elements-line.originY\n[7]: #graphic.elements-group"
    },
    "elements-line.left": {
        "desc": " Specify how to be positioned in its parent. When the element is at the top level, the parent is the container of the chart instance. Otherwise, the parent is a group element. Optional values: \n\n* Pixel value: For example, can be a number 30, means 30px.\n* Percent value: For example, can be a string '33%', means the final result should be calculated by this value and the height of its parent.\n* 'center': means position the element in the middle of according to its parent.\n\nOnly one between [left][0] and [right][1] can work. If [left][0] or [right][1] is specified, positioning attributes in [shape][2] (like x, cx) will not work.\n\n[0]: #graphic.elements-line.left\n[1]: #graphic.elements-line.right\n[2]: #graphic.elements-line.shape"
    },
    "elements-line.right": {
        "desc": " Specify how to be positioned in its parent. When the element is at the top level, the parent is the container of the chart instance. Otherwise, the parent is a group element. Optional values: \n\n* Pixel value: For example, can be a number 30, means 30px.\n* Percent value: For example, can be a string '33%', means the final result should be calculated by this value and the height of its parent.\n* 'center': means position the element in the middle of according to its parent.\n\nOnly one between [left][0] and [right][1] can work. If [left][0] or [right][1] is specified, positioning attributes in [shape][2] (like x, cx) will not work.\n\n[0]: #graphic.elements-line.left\n[1]: #graphic.elements-line.right\n[2]: #graphic.elements-line.shape"
    },
    "elements-line.top": {
        "desc": " Specify how to be positioned in its parent. When the element is at the top level, the parent is the container of the chart instance. Otherwise, the parent is a group element. Optional values: \n\n* Pixel value: For example, can be a number 30, means 30px.\n* Percent value: For example, can be a string '33%', means the final result should be calculated by this value and the width of its parent.\n* 'middle': means position the element in the middle of according to its parent.\n\nOnly one between [top][0] and [bottom][1] can work. If [top][0] or [bottom][1] is specified, positioning attributes in [shape][2] (like y, cy) will not work.\n\n[0]: #graphic.elements-line.top\n[1]: #graphic.elements-line.bottom\n[2]: #graphic.elements-line.shape"
    },
    "elements-line.bottom": {
        "desc": " Specify how to be positioned in its parent. When the element is at the top level, the parent is the container of the chart instance. Otherwise, the parent is a group element. Optional values: \n\n* Pixel value: For example, can be a number 30, means 30px.\n* Percent value: For example, can be a string '33%', means the final result should be calculated by this value and the width of its parent.\n* 'middle': means position the element in the middle of according to its parent.\n\nOnly one between [top][0] and [bottom][1] can work. If [top][0] or [bottom][1] is specified, positioning attributes in [shape][2] (like y, cy) will not work.\n\n[0]: #graphic.elements-line.top\n[1]: #graphic.elements-line.bottom\n[2]: #graphic.elements-line.shape"
    },
    "elements-line.bounding": {
        "desc": " Used to specify whether the entire transformed element (containing children if is group) is confined in its container. See sample: 暂时无法显示 Optional values: \n\n* 'all': (default) Use the transformed bounding box of itself and its descendants to perform position calculation, which confine the entire body in the boundary of its parent.\n* 'raw': Only use the untransformed bounding box of itself (without its descentant) to perform position calculation, which is suitable when the content in the element need to be overflow its parent.\n\n"
    },
    "elements-line.z": {
        "desc": " z value of the elements, determine the overlap order. "
    },
    "elements-line.zlevel": {
        "desc": " Determine which canvas layer this element should be in. Notice: Multiple canvas layer may affect performance. "
    },
    "elements-line.info": {
        "desc": " User defined data, can be visited in event listeners. \n\n    chart.on('click', function (params) {\n        console.log(params.info);\n    });\n    \n\n"
    },
    "elements-line.silent": {
        "desc": " Whether response to mouse events / touch events. "
    },
    "elements-line.invisible": {
        "desc": " Whether the element is visible. "
    },
    "elements-line.ignore": {
        "desc": " Whether the element is totally ignored (neither render nor listen events). "
    },
    "elements-line.textContent": {
        "desc": " Text block attached to an element and layout based on the element by textConfig. The props the the same as [text][0].\n\n[0]: option.html#graphic.elements-text"
    },
    "elements-line.textConfig": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "elements-line.textConfig.position": {
        "desc": " Position of textContent. \n\n* 'left'\n* 'right'\n* 'top'\n* 'bottom'\n* 'inside'\n* 'insideLeft'\n* 'insideRight'\n* 'insideTop'\n* 'insideBottom'\n* 'insideTopLeft'\n* 'insideTopRight'\n* 'insideBottomLeft'\n* 'insideBottomRight'\n* or like [12, 33]\n* or like ['50%', '50%']\n\n"
    },
    "elements-line.textConfig.rotation": {
        "desc": " Rotation of textContent. In radian. "
    },
    "elements-line.textConfig.layoutRect": {
        "desc": " Rect that textContent will be positioned. Default to be the bounding box of host element. \n\n    {\n        x: number\n        y: number\n        width: number\n        height: number\n    }\n    \n\n"
    },
    "elements-line.textConfig.offset": {
        "desc": " Offset of the textContent. The difference of offset and position is that offset will be applied in the rotation. "
    },
    "elements-line.textConfig.origin": {
        "desc": "origin is relative to the bounding box of the host element. Can be percent value. Relative to the bounding box. If 'center' specified, it will be center of the bounding box. Only available when position and rotation are both set. \n\n* like [12, 33]\n* or like ['50%', '50%']\n* 'center'\n\n"
    },
    "elements-line.textConfig.distance": {
        "desc": " Distance to the layoutRect。 "
    },
    "elements-line.textConfig.local": {
        "desc": " If true, it will apply host's transform. "
    },
    "elements-line.textConfig.insideFill": {
        "desc": "insideFill is a color string or left empty. If a textContent is \"inside\", its final fill will be picked by this priority: textContent.style.fill > textConfig.insideFill > \"auto-calculated-fill\" In most cases, \"auto-calculated-fill\" is white. "
    },
    "elements-line.textConfig.insideStroke": {
        "desc": "insideStroke is a color string or left empty. If a textContent is \"inside\", its final stroke will be picked by this priority: textContent.style.stroke > textConfig.insideStroke > \"auto-calculated-stroke\" The rule of getting \"auto-calculated-stroke\": \n\n* If\n  * (A) the fill is specified in style (either in textContent.style or textContent.style.rich)\n  * or (B) needed to draw text background (either defined in textContent.style or textContent.style.rich)\n  * \"auto-calculated-stroke\" will be null.\n* Otherwise\n  * \"auto-calculated-stroke\" will be the same as fill of this element if possible, or null.\n\n"
    },
    "elements-line.textConfig.outsideFill": {
        "desc": "outsideFill is a color string or left empty. If a textContent is \"inside\", its final fill will be picked by this priority: textContent.style.fill > textConfig.outsideFill > #000 "
    },
    "elements-line.textConfig.outsideStroke": {
        "desc": "outsideStroke is a color string or left empty. If a textContent is not \"inside\", its final stroke will be picked by this priority: textContent.style.stroke > textConfig.outsideStroke > \"auto-calculated-stroke\" The rule of getting \"auto-calculated-stroke\": \n\n* If\n  * (A) the fill is specified in style (either in textContent.style or textContent.style.rich)\n  * or (B) needed to draw text background (either defined in textContent.style or textContent.style.rich)\n  * \"auto-calculated-stroke\" will be null.\n* Otherwise\n  * \"auto-calculated-stroke\" will be a near white color to distinguish \"front end\" label with messy background (like other text label, line or other graphic).\n\n"
    },
    "elements-line.textConfig.inside": {
        "desc": " Tell echarts that I can make sure this text is inside or not. "
    },
    "elements-line.cursor": {
        "desc": " The mouse style when mouse hovers on an element, the same as cursor property in CSS. ",
        "uiControl": {
            "type": "enum",
            "options": "'auto','pointer','move'"
        }
    },
    "elements-line.draggable": {
        "desc": " Can be dragged or not. "
    },
    "elements-line.progressive": {
        "desc": " Whether use progressive render to improve performance. Usually used when number of element is too large. "
    },
    "elements-line.shape": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "elements-line.shape.x1": {
        "desc": " x value of the start point. "
    },
    "elements-line.shape.y1": {
        "desc": " y value of the start point. "
    },
    "elements-line.shape.x2": {
        "desc": " x value of the end point. "
    },
    "elements-line.shape.y2": {
        "desc": " y value of the end point. "
    },
    "elements-line.shape.percent": {
        "desc": " Specify the percentage of drawing, useful in animation. Value range: [0, 1]. "
    },
    "elements-line.style": {
        "desc": " More attributes in style (for example, [rich text][0]), see the style related attributes in [zrender/graphic/Displayable][1]. Notice, the attribute names of the style of graphic elements is derived from zrender, which may be different from the attribute names in echarts label, echarts itemStyle, etc., although they have the same meaning. For example: \n\n* [itemStyle.color][2] => style.fill\n* [itemStyle.borderColor][2] => style.stroke\n* [label.color][2] => style.textFill\n* [label.textBorderColor][3] => style.textStroke\n* ...\n\n\n\n[0]: tutorial.html#Rich%20Text\n[1]: https://ecomfe.github.io/zrender-doc/public/api.html#zrenderdisplayable\n[2]: #series-scatter.label.color\n[3]: #series-scatter.label.textBorderColor"
    },
    "elements-line.style.fill": {
        "desc": " Color filled in this element. "
    },
    "elements-line.style.stroke": {
        "desc": " Color of stroke. "
    },
    "elements-line.style.lineWidth": {
        "desc": " Width of stroke. "
    },
    "elements-line.style.shadowBlur": {
        "desc": " Width of shadow. "
    },
    "elements-line.style.shadowOffsetX": {
        "desc": " X offset of shadow. "
    },
    "elements-line.style.shadowOffsetY": {
        "desc": " Y offset of shadow. "
    },
    "elements-line.style.shadowColor": {
        "desc": " color of shadow. "
    },
    "elements-line.focus": {
        "desc": ">  Since > v5.0.0 When it's highlighted, whether to fade out of other data to focus the highlighted. The following configurations are supported: \n\n* 'none' Do not fade out other data, it's by default.\n* 'self' Only focus (not fade out) the element of the currently highlighted data.\n* 'series' Focus on all elements of the series which the currently highlighted data belongs to.\n\n"
    },
    "elements-line.blurScope": {
        "desc": ">  Since > v5.0.0 The range of fade out when focus is enabled. Support the following configurations \n\n* 'coordinateSystem'\n* 'series'\n* 'global'\n\n"
    },
    "elements-bezierCurve": {
        "desc": " Quadratic bezier curve or cubic bezier curve. "
    },
    "elements-bezierCurve.type": {
        "desc": " Must be specified when define a graphic element at the first time. Optional values: [image][0], [text][1], [circle][2], [sector][3], [ring][4], [polygon][5], [polyline][6], [rect][7], [line][8], [bezierCurve][9], [arc][10], [group][11],\n\n[0]: #graphic.elements-image\n[1]: #graphic.elements-text\n[2]: #graphic.elements-circle\n[3]: #graphic.elements-sector\n[4]: #graphic.elements-ring\n[5]: #graphic.elements-polygon\n[6]: #graphic.elements-polyline\n[7]: #graphic.elements-rect\n[8]: #graphic.elements-line\n[9]: #graphic.elements-bezierCurve\n[10]: #graphic.elements-arc\n[11]: #graphic.elements-group"
    },
    "elements-bezierCurve.id": {
        "desc": " id is used to specifying element when willing to update it. id can be ignored if you do not need it. "
    },
    "elements-bezierCurve.$action": {
        "desc": " Specify the operation should be performed to the element when calling setOption. Default value is 'merge', other values can be 'replace' or 'remove'. Optional values: \n\n* 'merge': merge the given option to existing element (if any), otherwise create a new element.\n* 'replace': create a new element according to the given option and replace the existing element (if any).\n* 'remove': delete the existing element (if any).\n\n"
    },
    "elements-bezierCurve.x": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-bezierCurve.x\n[1]: #graphic.elements-bezierCurve.y\n[2]: #graphic.elements-bezierCurve.rotation\n[3]: #graphic.elements-bezierCurve.scaleX\n[4]: #graphic.elements-bezierCurve.scaleY\n[5]: #graphic.elements-bezierCurve.originX\n[6]: #graphic.elements-bezierCurve.originY\n[7]: #graphic.elements-group"
    },
    "elements-bezierCurve.y": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-bezierCurve.x\n[1]: #graphic.elements-bezierCurve.y\n[2]: #graphic.elements-bezierCurve.rotation\n[3]: #graphic.elements-bezierCurve.scaleX\n[4]: #graphic.elements-bezierCurve.scaleY\n[5]: #graphic.elements-bezierCurve.originX\n[6]: #graphic.elements-bezierCurve.originY\n[7]: #graphic.elements-group"
    },
    "elements-bezierCurve.rotation": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-bezierCurve.x\n[1]: #graphic.elements-bezierCurve.y\n[2]: #graphic.elements-bezierCurve.rotation\n[3]: #graphic.elements-bezierCurve.scaleX\n[4]: #graphic.elements-bezierCurve.scaleY\n[5]: #graphic.elements-bezierCurve.originX\n[6]: #graphic.elements-bezierCurve.originY\n[7]: #graphic.elements-group"
    },
    "elements-bezierCurve.scaleX": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-bezierCurve.x\n[1]: #graphic.elements-bezierCurve.y\n[2]: #graphic.elements-bezierCurve.rotation\n[3]: #graphic.elements-bezierCurve.scaleX\n[4]: #graphic.elements-bezierCurve.scaleY\n[5]: #graphic.elements-bezierCurve.originX\n[6]: #graphic.elements-bezierCurve.originY\n[7]: #graphic.elements-group"
    },
    "elements-bezierCurve.scaleY": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-bezierCurve.x\n[1]: #graphic.elements-bezierCurve.y\n[2]: #graphic.elements-bezierCurve.rotation\n[3]: #graphic.elements-bezierCurve.scaleX\n[4]: #graphic.elements-bezierCurve.scaleY\n[5]: #graphic.elements-bezierCurve.originX\n[6]: #graphic.elements-bezierCurve.originY\n[7]: #graphic.elements-group"
    },
    "elements-bezierCurve.originX": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-bezierCurve.x\n[1]: #graphic.elements-bezierCurve.y\n[2]: #graphic.elements-bezierCurve.rotation\n[3]: #graphic.elements-bezierCurve.scaleX\n[4]: #graphic.elements-bezierCurve.scaleY\n[5]: #graphic.elements-bezierCurve.originX\n[6]: #graphic.elements-bezierCurve.originY\n[7]: #graphic.elements-group"
    },
    "elements-bezierCurve.originY": {
        "desc": "2D transform can be applied to graphic elements, including: \n\n* Translate by [x][0] and [y][1]: 0 by default. Positive value means translate towards right or bottom.\n* Rotate by [rotation][2]: in radian, 0 by default. Positive when anticlockwise.\n* Scale by [scaleX][3] and [scaleY][4]: 1 by default. The value means the ratio of scale.\n\n[originX][5] and [originY][6] specifies the origin point of rotation and scaling, 0, 0 by default. Notice: \n\n* The coordinates specified in the transform attribute above are relative to the [0, 0] of the parent element (that is, [group][7] or the root canvas). Thus we are able to [group][7] multiple elements, and [groups][7] can be nested.\n* The order that the transform attributes are applied to a single graphic element is: firstly, rotate (by rotation); then, scale (by scaleX, scaleY); finally, translate (by x, y).\n\n\n\n[0]: #graphic.elements-bezierCurve.x\n[1]: #graphic.elements-bezierCurve.y\n[2]: #graphic.elements-bezierCurve.rotation\n[3]: #graphic.elements-bezierCurve.scaleX\n[4]: #graphic.elements-bezierCurve.scaleY\n[5]: #graphic.elements-bezierCurve.originX\n[6]: #graphic.elements-bezierCurve.originY\n[7]: #graphic.elements-group"
    },
    "elements-bezierCurve.left": {
        "desc": " Specify how to be positioned in its parent. When the element is at the top level, the parent is the container of the chart instance. Otherwise, the parent is a group element. Optional values: \n\n* Pixel value: For example, can be a number 30, means 30px.\n* Percent value: For example, can be a string '33%', means the final result should be calculated by this value and the height of its parent.\n* 'center': means position the element in the middle of according to its parent.\n\nOnly one between [left][0] and [right][1] can work. If [left][0] or [right][1] is specified, positioning attributes in [shape][2] (like x, cx) will not work.\n\n[0]: #graphic.elements-bezierCurve.left\n[1]: #graphic.elements-bezierCurve.right\n[2]: #graphic.elements-bezierCurve.shape"
    },
    "elements-bezierCurve.right": {
        "desc": " Specify how to be positioned in its parent. When the element is at the top level, the parent is the container of the chart instance. Otherwise, the parent is a group element. Optional values: \n\n* Pixel value: For example, can be a number 30, means 30px.\n* Percent value: For example, can be a string '33%', means the final result should be calculated by this value and the height of its parent.\n* 'center': means position the element in the middle of according to its parent.\n\nOnly one between [left][0] and [right][1] can work. If [left][0] or [right][1] is specified, positioning attributes in [shape][2] (like x, cx) will not work.\n\n[0]: #graphic.elements-bezierCurve.left\n[1]: #graphic.elements-bezierCurve.right\n[2]: #graphic.elements-bezierCurve.shape"
    },
    "elements-bezierCurve.top": {
        "desc": " Specify how to be positioned in its parent. When the element is at the top level, the parent is the container of the chart instance. Otherwise, the parent is a group element. Optional values: \n\n* Pixel value: For example, can be a number 30, means 30px.\n* Percent value: For example, can be a string '33%', means the final result should be calculated by this value and the width of its parent.\n* 'middle': means position the element in the middle of according to its parent.\n\nOnly one between [top][0] and [bottom][1] can work. If [top][0] or [bottom][1] is specified, positioning attributes in [shape][2] (like y, cy) will not work.\n\n[0]: #graphic.elements-bezierCurve.top\n[1]: #graphic.elements-bezierCurve.bottom\n[2]: #graphic.elements-bezierCurve.shape"
    },
    "elements-bezierCurve.bottom": {
        "desc": " Specify how to be positioned in its parent. When the element is at the top level, the parent is the container of the chart instance. Otherwise, the parent is a group element. Optional values: \n\n* Pixel value: For example, can be a number 30, means 30px.\n* Percent value: For example, can be a string '33%', means the final result should be calculated by this value and the width of its parent.\n* 'middle': means position the element in the middle of according to its parent.\n\nOnly one between [top][0] and [bottom][1] can work. If [top][0] or [bottom][1] is specified, positioning attributes in [shape][2] (like y, cy) will not work.\n\n[0]: #graphic.elements-bezierCurve.top\n[1]: #graphic.elements-bezierCurve.bottom\n[2]: #graphic.elements-bezierCurve.shape"
    },
    "elements-bezierCurve.bounding": {
        "desc": " Used to specify whether the entire transformed element (containing children if is group) is confined in its container. See sample: 暂时无法显示 Optional values: \n\n* 'all': (default) Use the transformed bounding box of itself and its descendants to perform position calculation, which confine the entire body in the boundary of its parent.\n* 'raw': Only use the untransformed bounding box of itself (without its descentant) to perform position calculation, which is suitable when the content in the element need to be overflow its parent.\n\n"
    },
    "elements-bezierCurve.z": {
        "desc": " z value of the elements, determine the overlap order. "
    },
    "elements-bezierCurve.zlevel": {
        "desc": " Determine which canvas layer this element should be in. Notice: Multiple canvas layer may affect performance. "
    },
    "elements-bezierCurve.info": {
        "desc": " User defined data, can be visited in event listeners. \n\n    chart.on('click', function (params) {\n        console.log(params.info);\n    });\n    \n\n"
    },
    "elements-bezierCurve.silent": {
        "desc": " Whether response to mouse events / touch events. "
    },
    "elements-bezierCurve.invisible": {
        "desc": " Whether the element is visible. "
    },
    "elements-bezierCurve.ignore": {
        "desc": " Whether the element is totally ignored (neither render nor listen events). "
    },
    "elements-bezierCurve.textContent": {
        "desc": " Text block attached to an element and layout based on the element by textConfig. The props the the same as [text][0].\n\n[0]: option.html#graphic.elements-text"
    },
    "elements-bezierCurve.textConfig": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "elements-bezierCurve.textConfig.position": {
        "desc": " Position of textContent. \n\n* 'left'\n* 'right'\n* 'top'\n* 'bottom'\n* 'inside'\n* 'insideLeft'\n* 'insideRight'\n* 'insideTop'\n* 'insideBottom'\n* 'insideTopLeft'\n* 'insideTopRight'\n* 'insideBottomLeft'\n* 'insideBottomRight'\n* or like [12, 33]\n* or like ['50%', '50%']\n\n"
    },
    "elements-bezierCurve.textConfig.rotation": {
        "desc": " Rotation of textContent. In radian. "
    },
    "elements-bezierCurve.textConfig.layoutRect": {
        "desc": " Rect that textContent will be positioned. Default to be the bounding box of host element. \n\n    {\n        x: number\n        y: number\n        width: number\n        height: number\n    }\n    \n\n"
    },
    "elements-bezierCurve.textConfig.offset": {
        "desc": " Offset of the textContent. The difference of offset and position is that offset will be applied in the rotation. "
    },
    "elements-bezierCurve.textConfig.origin": {
        "desc": "origin is relative to the bounding box of the host element. Can be percent value. Relative to the bounding box. If 'center' specified, it will be center of the bounding box. Only available when position and rotation are both set. \n\n* like [12, 33]\n* or like ['50%', '50%']\n* 'center'\n\n"
    },
    "elements-bezierCurve.textConfig.distance": {
        "desc": " Distance to the layoutRect。 "
    },
    "elements-bezierCurve.textConfig.local": {
        "desc": " If true, it will apply host's transform. "
    },
    "elements-bezierCurve.textConfig.insideFill": {
        "desc": "insideFill is a color string or left empty. If a textContent is \"inside\", its final fill will be picked by this priority: textContent.style.fill > textConfig.insideFill > \"auto-calculated-fill\" In most cases, \"auto-calculated-fill\" is white. "
    },
    "elements-bezierCurve.textConfig.insideStroke": {
        "desc": "insideStroke is a color string or left empty. If a textContent is \"inside\", its final stroke will be picked by this priority: textContent.style.stroke > textConfig.insideStroke > \"auto-calculated-stroke\" The rule of getting \"auto-calculated-stroke\": \n\n* If\n  * (A) the fill is specified in style (either in textContent.style or textContent.style.rich)\n  * or (B) needed to draw text background (either defined in textContent.style or textContent.style.rich)\n  * \"auto-calculated-stroke\" will be null.\n* Otherwise\n  * \"auto-calculated-stroke\" will be the same as fill of this element if possible, or null.\n\n"
    },
    "elements-bezierCurve.textConfig.outsideFill": {
        "desc": "outsideFill is a color string or left empty. If a textContent is \"inside\", its final fill will be picked by this priority: textContent.style.fill > textConfig.outsideFill > #000 "
    },
    "elements-bezierCurve.textConfig.outsideStroke": {
        "desc": "outsideStroke is a color string or left empty. If a textContent is not \"inside\", its final stroke will be picked by this priority: textContent.style.stroke > textConfig.outsideStroke > \"auto-calculated-stroke\" The rule of getting \"auto-calculated-stroke\": \n\n* If\n  * (A) the fill is specified in style (either in textContent.style or textContent.style.rich)\n  * or (B) needed to draw text background (either defined in textContent.style or textContent.style.rich)\n  * \"auto-calculated-stroke\" will be null.\n* Otherwise\n  * \"auto-calculated-stroke\" will be a near white color to distinguish \"front end\" label with messy background (like other text label, line or other graphic).\n\n"
    },
    "elements-bezierCurve.textConfig.inside": {
        "desc": " Tell echarts that I can make sure this text is inside or not. "
    },
    "elements-bezierCurve.cursor": {
        "desc": " The mouse style when mouse hovers on an element, the same as cursor property in CSS. ",
        "uiControl": {
            "type": "enum",
            "options": "'auto','pointer','move'"
        }
    },
    "elements-bezierCurve.draggable": {
        "desc": " Can be dragged or not. "
    },
    "elements-bezierCurve.progressive": {
        "desc": " Whether use progressive render to improve performance. Usually used when number of element is too large. "
    },
    "elements-bezierCurve.shape": {
        "desc": "",
        "uiControl": {
            "type": "Object"
        }
    },
    "elements-bezierCurve.shape.x1": {
        "desc": " x value of the start point. "
    },
    "elements-bezierCurve.shape.y1": {
        "desc": " y value of the start point. "
    },
    "elements-bezierCurve.shape.x2": {
        "desc": " x value of the end point. "
    },
    "elements-bezierCurve.shape.y2": {
        "desc": " y value of the end point. "
    },
    "elements-bezierCurve.shape.cpx1": {
        "desc": " x of control point. "
    },
    "elements-bezierCurve.shape.cpy1": {
        "desc": " y of control point. "
    },
    "elements-bezierCurve.shape.cpx2": {
        "desc": " x of the second control point. If specified, cubic bezier is used. If both cpx2 and cpy2 are not set, quatratic bezier is used. "
    },
    "elements-bezierCurve.shape.cpy2": {
        "desc": " y of the second control point. If specified, cubic bezier is used. If both cpx2 and cpy2 are not set, quatratic bezier is used. "
    },
    "elements-bezierCurve.shape.percent": {
        "desc": " Specify the percentage of drawing, useful in animation. Value range: [0, 1]. "
    },
    "elements-bezierCurve.style": {
        "desc": " More attributes in style (for example, [rich text][0]), see the style related attributes in [zrender/graphic/Displayable][1]. Notice, the attribute names of the style of graphic elements is derived from zrender, which may be different from the attribute names in echarts label, echarts itemStyle, etc., although they have the same meaning. For example: \n\n* [itemStyle.color][2] => style.fill\n* [itemStyle.borderColor][2] => style.stroke\n* [label.color][2] => style.textFill\n* [label.textBorderColor][3] => style.textStroke\n* ...\n\n\n\n[0]: tutorial.html#Rich%20Text\n[1]: https://ecomfe.github.io/zrender-doc/public/api.html#zrenderdisplayable\n[2]: #series-scatter.label.color\n[3]: #series-scatter.label.textBorderColor"
    },
    "elements-bezierCurve.style.fill": {
        "desc": " Color filled in this element. "
    },
    "elements-bezierCurve.style.stroke": {
        "desc": " Color of stroke. "
    },
    "elements-bezierCurve.style.lineWidth": {
        "desc": " Width of stroke. "
    },
    "elements-bezierCurve.style.shadowBlur": {
        "desc": " Width of shadow. "
    },
    "elements-bezierCurve.style.shadowOffsetX": {
        "desc": " X offset of shadow. "
    },
    "elements-bezierCurve.style.shadowOffsetY": {
        "desc": " Y offset of shadow. "
    },
    "elements-bezierCurve.style.shadowColor": {
        "desc": " color of shadow. "
    },
    "elements-bezierCurve.focus": {
        "desc": ">  Since > v5.0.0 When it's highlighted, whether to fade out of other data to focus the highlighted. The following configurations are supported: \n\n* 'none' Do not fade out other data, it's by default.\n* 'self' Only focus (not fade out) the element of the currently highlighted data.\n* 'series' Focus on all elements of the series which the currently highlighted data belongs to.\n\n"
    },
    "elements-bezierCurve.blurScope": {
        "desc": ">  Since > v5.0.0 The range of fade out when focus is enabled. Support the following configurations \n\n* 'coordinateSystem'\n* 'series'\n* 'global'\n\n"
    }
}