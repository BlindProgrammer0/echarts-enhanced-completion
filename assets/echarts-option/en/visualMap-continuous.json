{
    "type": {
        "desc": "Used to determine that it is a continuous visualMap component.",
        "uiControl": {
            "default": "continuous",
            "type": "string"
        }
    },
    "id": {
        "desc": "Component ID, not specified by default. If specified, it can be used to refer the component in option or API.",
        "uiControl": {
            "type": "string"
        }
    },
    "min": {
        "desc": "Specify the min dataValue for the visualMap component. `[visualMap.min, visualMax.max]` make up the domain of viusul mapping.\n\nNotice that `min` and `max` should be specified explicitly, and be `[0, 200]` by default, but not `dataMin` and `dataMax` in series.data.",
        "uiControl": {
            "type": "number"
        }
    },
    "max": {
        "desc": "Specify the max dataValue for the visualMap component. `[visualMap.min, visualMax.max]` make up the domain of viusul mapping.\n\nNotice that `min` and `max` should be specified explicitly, and be `[0, 200]` by default, but not `dataMin` and `dataMax` in series.data.",
        "uiControl": {
            "type": "number"
        }
    },
    "range": {
        "desc": "Specify selected range, that is, the dataValue corresponding to the two handles. For example:\n\n```javascript\nchart.setOption({\nvisualMap: {\nmin: 0,\nmax: 100,\n// dataValue corresponding to the two handles.\nrange: [4, 15],\n...\n}\n});\n```\n\n**auto-adaption when min or max is modified by setOption**\n\n+ If `range` is not set (or set to null or undefined)\n\n```javascript\nFor instance:\nchart.setOption({visualMap: {min: 10, max: 300}}); // range is not set, then range is [min, max] by default, that is, [10, 300].\n\nchart.setOption({visualMap: {min: 0, max: 400}}); // Modify min and max using setOption again.\n// Then range will be auto-modified to the new [min, max], that is, [0, 400].\n```\n\n+ If `range` is set explicitly, such as [10, 300]\n\n```javascript\nFor instance:\nchart.setOption({visualMap: {min: 10, max: 300, range: [20, 80]}}); // range is set to [20, 80].\n\nchart.setOption({visualMap: {min: 0, max: 400}}); // min and max are modifies using setOption.\n// Then range keep the original value ([20, 80]) but will not do auto-adaption.\n\nchart.setOption({visualMap: {range: null}}); // Set range to null then.\n// Then auto-adaption of range turns on and range is auto modified to [min, max], that is, [0, 400].\n\n```\n\n`range` gotten by `getOption` is always an `Array`, but not `null` or `undefined`.",
        "uiControl": {
            "type": "Array"
        }
    },
    "calculable": {
        "desc": "Whether show handles, which can be dragged to adjust \"selected range\".\n\nNotes: In order to be compatible with ECharts2, the rule, which seems to be a little odd, is retained: when [visualMap.type](~visualMap.type) is not set, and [visualMap.calculable](~visualMap-continuous.calculable) was set to be `true`, [visualMap.type](~visualMap.type) will be automatically set as `'continuous'`, regardless of some settings such as [visualMap-piecewise.splitNumber](~visualMap-piecewise.splitNumber). Therefore, it is recommended to set [visualMap.type](~visualMap.type) explicitly, which avoids ambiguity.",
        "uiControl": {
            "default": "false",
            "type": "boolean"
        }
    },
    "realtime": {
        "desc": "Whether to update view in real time when dragging a handle.\n\n+ If `ture`, the chart view will be updated in real time when dragging.\n\n+ If `false`, the chart view will be updated at the end of the handle dragging.",
        "uiControl": {
            "default": "true",
            "type": "boolean"
        }
    },
    "inverse": {
        "desc": "Whether to inverse the layout of visualMap component.\n\nAs `inverse` is `false`, the layout direction is the same as [cartesian coordinate](~grid). That is:\n\n+ As [visualMap.orient](~visualMap.orient) is `'vertical'`, large data are placed at the top while small at the bottom.\n+ As [visualMap.orient](~visualMap.orient) is `'horizontal'`,  large data are placed on the right while small on the left.\n\nAs `inverse` is `true`, the result is opposite.",
        "uiControl": {
            "default": "false",
            "type": "boolean"
        }
    },
    "precision": {
        "desc": "The decimal precision of label, defaults to be 0 (no decimals).",
        "uiControl": {
            "default": "0",
            "type": "number",
            "min": "0",
            "step": "1"
        }
    },
    "itemWidth": {
        "desc": "The width of the main bar of visualMap component.",
        "uiControl": {
            "default": "20",
            "type": "number",
            "min": "0"
        }
    },
    "itemHeight": {
        "desc": "The height of the main bar of visualMap component.",
        "uiControl": {
            "default": "140",
            "type": "number",
            "min": "0"
        }
    },
    "align": {
        "desc": "Specify the position of handles and labels, against the main bar. The possible values are:\n\n+ `'auto'` Decide automatically.\n+ `'left'` The handles and labels are on the right, which is valid when `orient` is set as `'horizontal'`.\n+ `'right'` The handles and labels are on the left, which is valid when `orient` is set as `'horizontal'`.\n+ `'top'` the handles and labels are at the bottom, which is valid when `orient` is set as  `'vertical'`.\n+ `'bottom'` the handles and labels are at the top, which is valid when `orient` is set as `'vertical'`.",
        "uiControl": {
            "default": "'auto'",
            "type": "enum",
            "options": "'auto','left','right','top','bottom'"
        }
    },
    "text": {
        "desc": "The label text on both ends, such as `['High', 'Low']`. [sample](doc-example/map-visualMap-continuous-text&edit=1&reset=1).\n\nYou can understand the order of items in `text` array just by a simple trial. See [visualMap.inverse](~visualMap.inverse).",
        "uiControl": {
            "default": "null",
            "type": "Array"
        }
    },
    "textGap": {
        "desc": "The distance between the ends of the main bar and the label, with unit px. See [visualMap-continuous.text](~visualMap-continuous.text)",
        "uiControl": {
            "default": "10",
            "type": "number",
            "step": "0.5"
        }
    },
    "show": {
        "desc": "Whether to show visualMap-continuous component. If set as `false`, visualMap-continuous component will not show, but it can still perform visual mapping from dataValue to visual channel in chart.",
        "uiControl": {
            "default": "true",
            "type": "boolean"
        }
    },
    "dimension": {
        "desc": "Specify which dimension should be used to fetch dataValue from [series.data](~series.data), and then map them to visual channel.\n\n[series.data](~series.data) can be regarded as a two-dimensional array, for instance:\n\n```javascript\n[\n[12, 23, 43],\n[12, 23, 43],\n[43, 545, 65],\n[92, 23, 33]\n]\n```\n\nEach column of the above array is regarded as a `dimension`. For example, when property `dimension` is set to 1, the second column (i.e., 23, 23, 545, 23) is chosen to perform visual mapping.\n\nUse the last dimension of `data` by default.",
        "uiControl": {
            "type": "string"
        }
    },
    "seriesIndex": {
        "desc": "Specify visual mapping should be performed on which series, from which\n[series.data](~series.data) is fetched.\n\nAll series are used by default.",
        "uiControl": {
            "type": [
                "number",
                "Array"
            ]
        }
    },
    "hoverLink": {
        "desc": "`hoverLink` enable highlight certain graphical elements of chart when mouse hovers on some place of `visualMap` component that is coresponding to those graphical elements by visual mapping.\n\nInversely, when mouse hovers a graphical element of chart, its value label will be displayed on its corresponding position in `visualMap`.",
        "uiControl": {
            "default": "true",
            "type": "boolean"
        }
    },
    "inRange": {
        "desc": "Define visual channels that will mapped from dataValues that are **in selected range**. User can interact with visualMap component and make a seleced range by mouse or touch.\n\n\n\n+ `symbol`: Type of symbol.\n+ `symbolSize`: Symbol size.\n+ `color`: Symbol color.\n+ `colorAlpha`: Symbol alpha channel.\n+ `opacity`: Opacity of symbol and others (like labels).\n+ `colorLightness`: Lightness in [HSL](https://en.wikipedia.org/wiki/HSL_and_HSV).\n+ `colorSaturation`: Saturation in [HSL](https://en.wikipedia.org/wiki/HSL_and_HSV).\n+ `colorHue`: Hue in [HSL](https://en.wikipedia.org/wiki/HSL_and_HSV).\n\n\n\n\n\n`inRange` could customize visual channels both in series (by [visualMap-continuous.seriesIndex](~visualMap-continuous.seriesIndex)) and in `visualMap-continuous` itself.\n\nFor instance, if a `visualMap-continuous` component is used on a scatter chart, the mapping approach from data to `color` (or `symbol`, `size`, ...) can be both customized in the scatter chart and `visualMap-continuous` component itself. See the code as following:\n\n```javascript\nvisualMap: [\n{\n...,\n// Define visual channels both in target series and visualMap-continuous component itself:\ninRange: {\ncolor: ['#121122', 'rgba(3,4,5,0.4)', 'red'],\nsymbolSize: [30, 100]\n}\n}\n]\n```\n\nIf you want to define visual channels for target series and visualMap-continuous component separately, you should do as follows:\n\n```javascript\nvisualMap: [\n{\n...,\n// Define visual channels only for target series.\ntarget: {\ninRange: {\ncolor: ['#121122', 'rgba(3,4,5,0.4)', 'red'],\nsymbolSize: [60, 200]\n}\n},\n// Define visual channels only for visualMap-continuous component.\ncontroller: {\ninRange: {\nsymbolSize: [30, 100]\n}\n}\n}\n]\n```\n\nOr define as follows:\n```javascript\nvisualMap: [\n{\n...,\n// Define visual channels for both target series and visualMap-continuous component.\ninRange: {\ncolor: ['#121122', 'rgba(3,4,5,0.4)', 'red'],\nsymbolSize: [60, 200]\n},\n// Define visual channels only for visualMap-continuous component, which\n// will overlap the properties with the same name in the above common\n// definition. (symbolSize is overlapped by [30, 100] while color\n// keeps the original value)\ncontroller: {\ninRange: {\nsymbolSize: [30, 100]\n}\n}\n}\n]\n```\n\n<br>\n\n---\n\n**✦ About visual channels ✦**\n\n+ Various visual channels (such as `color`、`symbolSize` and ect.) can be defined in inRange at the same time and all of them will be apopted.\n\n+ Basically visual channels `opacity` is recommended, rather than `colorAlpha`. The former controls the transparency of both graphical element and its attachments (like label), whereas the latter only controls the transparency of graphical element.\n\n+ There are two approaches of visual mapping supported: 'Linear Mapping' and 'Table Mapping'.\n\n<br>\n\n---\n\n**✦ Linear Mapping to visual channel ✦**\n\n`Linear Mapping` means that linear calculation will be performed on each dataValue (value of series.data), mapping them from the domain of `[visaulMap.min, visualMap.max]` to a given range of `[visual value 1, visual value 2]` and obtaining a final value (say visual value) for visual channel rendering.\n\nFor instance, `[visualMap.min, visualMap.max]` is set to be `[0, 100]`, and there is series.data: `[50, 10, 100]`. We intend to map them to an `opacity` range `[0.4, 1]`, by which the size of value can be demostrated by the transparency of graphical elements. visualMap component will then linear calculate them and get opacity values `[0.7, 0.44, 1]`, cooresponding to each dataValue.\n\nWe can also set the visual range inversely, such as `opacity: [1, 0.4]`, and the final mapping result for the given series.data above will be `[0.7, 0.96, 0.4]`.\n\nNotice: [visualMap.min, visualMap.max] should be set manually and is [0, 100] by default, but not `dataMin` and `dataMax` in series.data.\n\n\nHow to configure visualMap component to do Linear Mapping?\n\n+ When use [visualMap-continuous](~visualMap-continuous), or\n\n+ When use [visualMap-piecewise](~visualMap-piecewise) and [visualMap-piecewise.categories](~visualMap-piecewise.categories) is not used.\n\n\nAbout the value of visual channel (visual value):\n\n+ Basically `Array` is used to express the range of visual value, e.g., `color: ['#333', '#777']`.\n\n+ Single `number` or single `string` can also be used, which will be converted to an `Array` by visualMap component. e.g.:  `opacity: 0.4` will be converted to `opacity: [0.4, 0.4]`, `color: '#333'` will be converted to `color: ['#333', '#333']`.\n\n+ For visual channel `symbolSize`, `opacity`, `colorAlpha`, `colorLightness`, `colorSaturation`, `colorHue`, the range of visual value is always in the form of: `[visual value of visualMap.min, visual value of visualMap.max]`. For example, `colorLightness: [0.8, 0.2]` means that the dataValue in series.data that equals to `visualMap.min` (if any) will be mapped to lightness `0.8`, and the dataValue that equals to `visualMap.max` (if any) will be mapped to lightness `0.2`, and other dataValues will be mapped by the linear calculateion based on the domain of `[visualMap.min, visualMap.max]` and the range of `[0.8, 0.2]`.\n\n+ For visual channel `color`, array is used, like: `['#333', '#78ab23', 'blue']`, which means a color ribbon is formed based on the three color stops, and dataValues will be mapped to the ribbon. Specifically, the dataValue that equals to `visualMap.min` will be mapped onto `'#333'`, the dataValue that equals to `visualMap.max` will be mapped onto `'blue'`, and other dataValues will be piecewisely interpolated to get the final color.\n\n+ For visual channel `symbol`, array is used, like: `['circle', 'rect', 'diamond']`, where the dataValue that equals to `visualMap.min` will be mapped onto `'circle'`, the dataValue that equals to `visualMap.max` will be mapped onto `'diamond'`, and other dataValues will be caculated based on the numerical distance to `visualMax.min` and to `visualMap.max`, and mapped onto one of `'circle'`, `'rect'`, `'diamond'`.\n\n\nAbout the possible value range of visual value:\n\n+ `opacity`、`colorAlpha`、`colorLightness`、`colorSaturation`、`visual value`\n\npossible value range is `[0, 1]`.\n\n+ `colorHue`：\n\npossible value range is `[0, 360]`.\n\n+ `color`：\n\ncolor can use RGB expression, like `'rgb(128, 128, 128)'`, or RGBA expression, like `'rgba(128, 128, 128, 0.5)'`, or Hex expression, like '#ccc'.\n\n+ `symbol`：\n\n\n\nIcon types provided by ECharts includes\n\n\n\n`'circle'`, `'rect'`, `'roundRect'`, `'triangle'`, `'diamond'`, `'pin'`, `'arrow'`, `'none'`\n\n\n\n\n\n\n\nIt can be set to an image with `'image://url'` , in which URL is the link to an image, or `dataURI` of an image.\n\n\nAn image URL example:\n\n```\n'image://http://xxx.xxx.xxx/a/b.png'\n```\n\nA `dataURI` example:\n\n```\n'image://data:image/gif;base64,R0lGODlhEAAQAMQAAORHHOVSKudfOulrSOp3WOyDZu6QdvCchPGolfO0o/XBs/fNwfjZ0frl3/zy7////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAkAABAALAAAAAAQABAAAAVVICSOZGlCQAosJ6mu7fiyZeKqNKToQGDsM8hBADgUXoGAiqhSvp5QAnQKGIgUhwFUYLCVDFCrKUE1lBavAViFIDlTImbKC5Gm2hB0SlBCBMQiB0UjIQA7'\n```\n\n\n\nIcons can be set to arbitrary vector path via `'path://'` in ECharts. As compared with a raster image, vector paths prevent jagging and blurring when scaled, and have better control over changing colors. The size of the vector icon will be adapted automatically. Refer to [SVG PathData](http://www.w3.org/TR/SVG/paths.html#PathData) for more information about the format of the path. You may export vector paths from tools like Adobe\n\nFor example:\n\n```\n'path://M30.9,53.2C16.8,53.2,5.3,41.7,5.3,27.6S16.8,2,30.9,2C45,2,56.4,13.5,56.4,27.6S45,53.2,30.9,53.2z M30.9,3.5C17.6,3.5,6.8,14.4,6.8,27.6c0,13.3,10.8,24.1,24.101,24.1C44.2,51.7,55,40.9,55,27.6C54.9,14.4,44.1,3.5,30.9,3.5z M36.9,35.8c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H36c0.5,0,0.9,0.4,0.9,1V35.8z M27.8,35.8 c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H27c0.5,0,0.9,0.4,0.9,1L27.8,35.8L27.8,35.8z'\n```\n\n\n\n\n\n\n\n\n\n\n\n<br>\n\n---\n\n**✦ Table Mapping to visual channel ✦**\n\n`Table Mapping` could be used when dataValue (values in series.data, specified by [visualMap.dimension](~visualMap.dimension)) is enumerable and we intend to map them to visual value by looking up a given table.\n\nFor instance, in a [visualMap-piecewise](~visualMap-piecewise) component, [visualMap-piecewise.categories](~visualMap-piecewise.categories) is set to `['Demon Hunter', 'Blademaster', 'Death Knight', 'Warden', 'Paladin']`. And there is series.data: `['Demon Hunter', 'Death Knight', 'Warden', 'Paladin']`. Then we can establish the lookup rule for color: `color: {'Warden': 'red', 'Demon Hunter': 'black'}`, by which the `visualMap` component will map `dataValue` to `color`.\n\nHow to configure `visualMap` component to do `Table Mapping`?\n\nWhen use [visualMap-piecewise](~visualMap-piecewise) and [visualMap-piecewise.categories](~visualMap-piecewise.categories)is set.\n\nAbout the value of visual channel (visual value):\n\nGenerally `Object` or `Array` is used, for instance:\n\n```javascript\nvisualMap: {\ntype: 'piecewise',\n// categories defines the items that to be displayed in visualMap-piecewise component.\ncategories: [\n'Demon Hunter', 'Blademaster', 'Death Knight', 'Warden', 'Paladin'\n],\ninRange: {\n// visual value can be an Object：\ncolor: {\n'Warden': 'red',\n'Demon Hunter': 'black',\n'': 'green' // Blank string means that except 'Warden' and 'Demon Hunter',\n// all other dataValues should be mapped to 'green'.\n}\n// visual value can also be a single value,\n// means that all dataValues should be mapped to the value.\ncolor: 'green',\n// visual value can also be a array, with the same length\n// as the array of categories and one-one mapping onto it.\ncolor: ['red', 'black', 'green', 'yellow', 'white']\n}\n}\n```\n\n[Example](doc-example/scatter-visualMap-categories&edit=1&reset=1)\n\n\n\n\n\n\n\n**✦ How to modity configurations of vsiual encoding? ✦**\n\nIf you want to modify the configurations of visual encoding after chart been rendered (by invoke `setOption` to set the initial `option`), `setOption` can be used again to modify configurations of visual encoding. For instance:\n\n```javascript\nchart.setOption({\nvisualMap: {\ninRange: {color: ['red', 'blue']}\n}\n});\n```\n\nNotice:\n\n+ These visualMap properties (i.e. `inRange`, `outOfRange`, `target`, `controller`) do not support \"merge\", that is, anyone among them is modified when use `setOption` again, all of the original values of them will not be kept but erased. The \"merge\" brings complication in implemnentation and understanding, whereas \"erase all\" normalize the practise: once you want to modify some visual values, you should pass all of them to `setOption`, no matter they are to be changed.\n\n+ This way, `getOption() -> modify the gotten option -> setOption(modified option)`, is strongly **not recommended**, for instance:\n\n```javascript\n// Not recommended approach, regardless of its correctness:\n\nvar option = chart.getOption(); // Get the entire option.\noption.visualMap.inRange.color = ['red', 'blue']; // modify color, which is what you want.\n\n// You have to modify those two properties, otherwise you will not get what you want.\noption.visualMap.target.inRange.color = ['red', 'blue'];\noption.visualMap.controller.inRange.color = ['red', 'blue'];\n\nchart.setOption(option); // set the modified option back.\n// You should not use this approach, but use the\n// approach demostrated before this example.\n```\n\n\n\n\n\n**Notice:** There is default color `['#f6efa6', '#d88273', '#bf444c']` in `inRange` if you not set `inRange`. If you dont want it, set `inRange: {color: null}` to disable it.",
        "uiControl": {
            "type": "Object"
        }
    },
    "outOfRange": {
        "desc": "Define visual channels that will mapped from dataValues that are **out of selected range**. User can interact with visualMap component and make a seleced range by mouse or touch.\n\nSee available configurations in [visualMap-continuous.inRange](~visualMap-continuous.inRange)",
        "uiControl": {
            "type": "Object"
        }
    },
    "controller": {
        "desc": "Property `inRange` and `outOfRange` can be set within property `controller`, which means those `inRange` and `outOfRange` are only used on the controller (`visualMap` component itself), but are not used on chart (series). This property is useful in some scenarios when the view of controller needs to be customized in detail.",
        "uiControl": {
            "type": "Object"
        }
    },
    "controller.inRange": {
        "desc": "Define visual channels that will mapped from dataValues that are **in selected range**. User can interact with visualMap component and make a seleced range by mouse or touch.\n\nSee available configurations in [visualMap-continuous.inRange](~visualMap-continuous.inRange)",
        "uiControl": {
            "type": "Object"
        }
    },
    "controller.outOfRange": {
        "desc": "Define visual channels that will mapped from dataValues that are **out of selected range**. User can interact with visualMap component and make a seleced range by mouse or touch.\n\nSee available configurations in [visualMap-continuous.inRange](~visualMap-continuous.inRange)",
        "uiControl": {
            "type": "Object"
        }
    },
    "zlevel": {
        "desc": "`zlevel` value of all graphical elements in .\n\n`zlevel` is used to make layers with Canvas. Graphical elements with different `zlevel` values will be placed in different Canvases, which is a common optimization technique. We can put those frequently changed elements (like those with animations) to a separate `zlevel`. Notice that too many Canvases will increase memory cost, and should be used carefully on mobile phones to avoid crash.\n\nCanvases with bigger `zlevel` will be placed on Canvases with smaller `zlevel`.",
        "uiControl": {
            "default": "0",
            "type": "number"
        }
    },
    "z": {
        "desc": "`z` value of all graphical elements in , which controls order of drawing graphical components. Components with smaller `z` values may be overwritten by those with larger `z` values.\n\n`z` has a lower priority to `zlevel`, and will not create new Canvas.",
        "uiControl": {
            "default": "4",
            "type": "number"
        }
    },
    "left": {
        "desc": "Distance between visualMap  component and the left side of the container.\n\n`left` value can be instant pixel value like `20`; it can also be a percentage value relative to container width like `'20%'`; and it can also be `'left'`, `'center'`, or `'right'`.\n\nIf the `left` value is set to be `'left'`, `'center'`, or `'right'`, then the component will be aligned automatically based on position.",
        "uiControl": {
            "default": "0",
            "type": [
                "string",
                "number"
            ]
        }
    },
    "top": {
        "desc": "Distance between visualMap  component and the top side of the container.\n\n`top` value can be instant pixel value like `20`; it can also be a percentage value relative to container width like `'20%'`; and it can also be `'top'`, `'middle'`, or `'bottom'`.\n\nIf the `left` value is set to be `'top'`, `'middle'`, or `'bottom'`, then the component will be aligned automatically based on position.",
        "uiControl": {
            "default": "auto",
            "type": [
                "string",
                "number"
            ]
        }
    },
    "right": {
        "desc": "Distance between visualMap  component and the right side of the container.\n\n`right` value can be instant pixel value like `20`; it can also be a percentage value relative to container width like `'20%'`.",
        "uiControl": {
            "default": "auto",
            "type": [
                "string",
                "number"
            ]
        }
    },
    "bottom": {
        "desc": "Distance between visualMap  component and the bottom side of the container.\n\n`bottom` value can be instant pixel value like `20`; it can also be a percentage value relative to container width like `'20%'`.",
        "uiControl": {
            "default": "0",
            "type": [
                "string",
                "number"
            ]
        }
    },
    "orient": {
        "desc": "How to layout the visualMap component, `'horizontal'` or `'vertical'`.",
        "uiControl": {
            "default": "'vertical'",
            "type": "string"
        }
    },
    "padding": {
        "desc": "visualMap-continuous space around content. The unit is px. Default values for each position are 5. And they can be set to different values with left, right, top, and bottom.\n\nExamples:\n```js\n// Set padding to be 5\npadding: 5\n// Set the top and bottom paddings to be 5, and left and right paddings to be 10\npadding: [5, 10]\n// Set each of the four paddings seperately\npadding: [\n5,  // up\n10, // right\n5,  // down\n10, // left\n]\n```",
        "uiControl": {
            "default": "5",
            "type": "vector",
            "min": "0",
            "dims": "T,R,B,L"
        }
    },
    "backgroundColor": {
        "desc": "background color of visualMap component.",
        "uiControl": {
            "default": "'rgba(0,0,0,0)'",
            "type": "Color"
        }
    },
    "borderColor": {
        "desc": "border color of visualMap component.",
        "uiControl": {
            "default": "'#ccc'",
            "type": "Color"
        }
    },
    "borderWidth": {
        "desc": "border width of visualMap component, with unit: px.",
        "uiControl": {
            "default": "0",
            "type": "number"
        }
    },
    "color": {
        "desc": "This property remains only for compatibility with ECharts2, and is not recommended in ECharts3. It is recommended to configure color in [visualMap-continuous.inRange](~visualMap-continuous.inRange), or [visualMap-continuous.outOfRange](~visualMap-continuous.outOfRange) if needed.\n\nIf you persist in using it, the following issue should be noticed: the sequence of dataValues that are mapped to colorValues in property `color` is from `large` to `small`, whereas that in [visualMap-continuous.inRange](~visualMap-continuous.inRange) or [visualMap-continuous.outOfRange](~visualMap-continuous.outOfRange) is from `small` to `large`.",
        "uiControl": {
            "default": "['#bf444c', '#d88273', '#f6efa6']",
            "type": "Array"
        }
    },
    "textStyle": {
        "desc": "",
        "uiControl": {
            "type": "*"
        }
    },
    "textStyle.color": {
        "desc": "visualMap  text color.",
        "uiControl": {
            "default": "'#333'",
            "type": "color"
        }
    },
    "textStyle.fontStyle": {
        "desc": "visualMap  font style.\n\nOptions are:\n+ `'normal'`\n+ `'italic'`\n+ `'oblique'`",
        "uiControl": {
            "default": "'normal'",
            "type": "enum",
            "options": "'normal','italic','oblique'"
        }
    },
    "textStyle.fontWeight": {
        "desc": "visualMap  font thick weight.\n\nOptions are:\n+ `'normal'`\n+ `'bold'`\n+ `'bolder'`\n+ `'lighter'`\n+ 100 | 200 | 300 | 400...",
        "uiControl": {
            "default": "'normal'",
            "type": "enum",
            "options": "'normal','bold','bolder','lighter'"
        }
    },
    "textStyle.fontFamily": {
        "desc": "visualMap  font family.\n\nCan also be 'serif' , 'monospace', ...",
        "uiControl": {
            "default": "'sans-serif'",
            "type": "enum",
            "options": "'sans-serif','serif','monospace','Arial','Courier New'"
        }
    },
    "textStyle.fontSize": {
        "desc": "visualMap  font size.",
        "uiControl": {
            "default": "12",
            "type": "number",
            "min": "1",
            "step": "1"
        }
    },
    "textStyle.lineHeight": {
        "desc": "Line height of the text fragment.\n\n\n\nIf `lineHeight` is not set in `rich`, `lineHeight` in parent level will be used. For example:\n\n```js\n{\nlineHeight: 56,\nrich: {\na: {\n// `lineHeight` is not set, then it will be 56\n}\n}\n}\n```",
        "uiControl": {
            "default": "12",
            "type": "number",
            "min": "0",
            "step": "1"
        }
    },
    "textStyle.width": {
        "desc": "Width of text block.",
        "uiControl": {
            "default": "100",
            "type": "number",
            "min": "1",
            "max": "500",
            "step": "1"
        }
    },
    "textStyle.height": {
        "desc": "Height of text block.",
        "uiControl": {
            "default": "50",
            "type": "number",
            "min": "1",
            "max": "500",
            "step": "1"
        }
    },
    "textStyle.textBorderColor": {
        "desc": "Storke color of the text.",
        "uiControl": {
            "type": "color"
        }
    },
    "textStyle.textBorderWidth": {
        "desc": "Storke line width of the text.",
        "uiControl": {
            "type": "number",
            "min": "0",
            "step": "0.5"
        }
    },
    "textStyle.textBorderType": {
        "desc": "Stroke line type of the text.\n\n\nPossible values are:\n+ `'solid'`\n+ `'dashed'`\n+ `'dotted'`\n\nSince `v5.0.0`, it can also be a number or a number array to specify the [dash array](https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-dasharray) of the line. With\n`textBorderDashOffset`\n, we can make the line style more flexible.\n\nFor example：\n```js\n{\n\ntextBorderType: [5, 10],\n\ntextBorderDashOffset: 5\n}\n```",
        "uiControl": {
            "default": "'solid'",
            "type": "enum",
            "options": "'solid','dashed','dotted'"
        }
    },
    "textStyle.textBorderDashOffset": {
        "desc": "> Since `v5.0.0`\n\n\n\n\n\nTo set the line dash offset. With\n`textBorderType`\n, we can make the line style more flexible.\n\nRefer to MDN [lineDashOffset](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/lineDashOffset) for more details.",
        "uiControl": {
            "default": "0",
            "type": "number",
            "min": "0",
            "step": "1"
        }
    },
    "textStyle.textShadowColor": {
        "desc": "Shadow color of the text itself.",
        "uiControl": {
            "default": "'transparent'",
            "type": "color"
        }
    },
    "textStyle.textShadowBlur": {
        "desc": "Shadow blue of the text itself.",
        "uiControl": {
            "default": "0",
            "type": "number",
            "min": "0",
            "step": "0.5"
        }
    },
    "textStyle.textShadowOffsetX": {
        "desc": "Shadow X offset of the text itself.",
        "uiControl": {
            "default": "0",
            "type": "number",
            "step": "0.5"
        }
    },
    "textStyle.textShadowOffsetY": {
        "desc": "Shadow Y offset of the text itself.",
        "uiControl": {
            "default": "0",
            "type": "number",
            "step": "0.5"
        }
    },
    "textStyle.overflow": {
        "desc": "Determine how to display the text when it's overflow. Available when `width` is set.\n\n+ `'truncate'` Truncate the text and trailing with `ellipsis`.\n+ `'break'` Break by word\n+ `'breakAll'` Break by character.",
        "uiControl": {
            "default": "'none'",
            "type": "enum",
            "options": "'truncate','break','breakAll'"
        }
    },
    "textStyle.ellipsis": {
        "desc": "Ellipsis to be displayed when `overflow` is set to `truncate`.",
        "uiControl": {
            "default": "'...'",
            "type": "string"
        }
    },
    "textStyle.lineOverflow": {
        "desc": "Determine how to display the text when it's overflow on height.\n\n+ `'truncate'` Truncate the overflow lines.",
        "uiControl": {
            "default": "'none'",
            "type": "string"
        }
    },
    "formatter": {
        "desc": "the formatter tool for label.\n\n+ If it was set as a `string`, it refers to a template, for instance: `aaaa{value}bbbb`, where `{value}` represents the value of the edge of the seleted range.\n\n+ If it was set as a `Function`, it refers to a callback function, for instance:\n\n```javascript\nformatter: function (value) {\nreturn 'aaaa' + value + 'bbbb';\n}\n```",
        "uiControl": {
            "type": [
                "string",
                "Function"
            ]
        }
    },
    "handleIcon": {
        "desc": "> Since `v5.0.0`\n\n\n\n\n\nIcon of drag handle.\n```js\n'M-11.39,9.77h0a3.5,3.5,0,0,1-3.5,3.5h-22a3.5,3.5,0,0,1-3.5-3.5h0a3.5,3.5,0,0,1,3.5-3.5h22A3.5,3.5,0,0,1-11.39,9.77Z'\n```\n\n\n\nIt can be set to an image with `'image://url'` , in which URL is the link to an image, or `dataURI` of an image.\n\n\nAn image URL example:\n\n```\n'image://http://xxx.xxx.xxx/a/b.png'\n```\n\nA `dataURI` example:\n\n```\n'image://data:image/gif;base64,R0lGODlhEAAQAMQAAORHHOVSKudfOulrSOp3WOyDZu6QdvCchPGolfO0o/XBs/fNwfjZ0frl3/zy7////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAkAABAALAAAAAAQABAAAAVVICSOZGlCQAosJ6mu7fiyZeKqNKToQGDsM8hBADgUXoGAiqhSvp5QAnQKGIgUhwFUYLCVDFCrKUE1lBavAViFIDlTImbKC5Gm2hB0SlBCBMQiB0UjIQA7'\n```\n\n\n\nIcons can be set to arbitrary vector path via `'path://'` in ECharts. As compared with a raster image, vector paths prevent jagging and blurring when scaled, and have better control over changing colors. The size of the vector icon will be adapted automatically. Refer to [SVG PathData](http://www.w3.org/TR/SVG/paths.html#PathData) for more information about the format of the path. You may export vector paths from tools like Adobe\n\nFor example:\n\n```\n'path://M30.9,53.2C16.8,53.2,5.3,41.7,5.3,27.6S16.8,2,30.9,2C45,2,56.4,13.5,56.4,27.6S45,53.2,30.9,53.2z M30.9,3.5C17.6,3.5,6.8,14.4,6.8,27.6c0,13.3,10.8,24.1,24.101,24.1C44.2,51.7,55,40.9,55,27.6C54.9,14.4,44.1,3.5,30.9,3.5z M36.9,35.8c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H36c0.5,0,0.9,0.4,0.9,1V35.8z M27.8,35.8 c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H27c0.5,0,0.9,0.4,0.9,1L27.8,35.8L27.8,35.8z'\n```",
        "uiControl": {
            "type": "string"
        }
    },
    "handleSize": {
        "desc": "> Since `v5.0.0`\n\n\n\nSize of drag handle. It can be a percent string.",
        "uiControl": {
            "default": "'120%'",
            "type": [
                "number",
                "string"
            ]
        }
    },
    "handleStyle": {
        "desc": "> Since `v5.0.0`\n\n\n\nStyle of drag handle.",
        "uiControl": {
            "type": "Object"
        }
    },
    "handleStyle.color": {
        "desc": "color.\n\n\n\n> Supports setting as solid color using `rgb(255,255,255)`, `rgba(255,255,255,1)`, `#fff`, etc. Also supports setting as gradient color and pattern fill, see [option.color](~color) for details",
        "uiControl": {
            "default": "null",
            "type": "color"
        }
    },
    "handleStyle.borderColor": {
        "desc": "border color, whose format is similar to that of `color`.",
        "uiControl": {
            "default": "#fff",
            "type": "color"
        }
    },
    "handleStyle.borderWidth": {
        "desc": "border width. No border when it is set to be 0.\n\n(${name} ? ${name} : \"\") + \" border width. No border when it is set to be 0.\"",
        "uiControl": {
            "default": "1",
            "type": "number",
            "min": "0",
            "step": "0.5"
        }
    },
    "handleStyle.borderType": {
        "desc": "border type.\n\n\n\nPossible values are:\n+ `'solid'`\n+ `'dashed'`\n+ `'dotted'`\n\nSince `v5.0.0`, it can also be a number or a number array to specify the [dash array](https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-dasharray) of the line. With\n`borderDashOffset`\n, we can make the line style more flexible.\n\nFor example：\n```js\n{\n\nborderType: [5, 10],\n\nborderDashOffset: 5\n}\n```",
        "uiControl": {
            "default": "'solid'",
            "type": "enum",
            "options": "'solid','dashed','dotted'"
        }
    },
    "handleStyle.borderDashOffset": {
        "desc": "> Since `v5.0.0`\n\n\n\n\n\nTo set the line dash offset. With\n`borderType`\n, we can make the line style more flexible.\n\nRefer to MDN [lineDashOffset](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/lineDashOffset) for more details.",
        "uiControl": {
            "default": "0",
            "type": "number",
            "min": "0",
            "step": "1"
        }
    },
    "handleStyle.borderCap": {
        "desc": "> Since `v5.0.0`\n\n\n\n\n\nTo specify how to draw the end points of the line.\nPossible values are:\n+ `'butt'`: The ends of lines are squared off at the endpoints.\n+ `'round'`: The ends of lines are rounded.\n+ `'square'`: The ends of lines are squared off by adding a box with an equal width and half the height of the line's thickness.\n\nDefault value is `'butt'`. Refer to MDN [lineCap](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/lineCap) for more details.",
        "uiControl": {
            "default": "'butt'",
            "type": "enum",
            "options": "'butt','round','square'"
        }
    },
    "handleStyle.borderJoin": {
        "desc": "> Since `v5.0.0`\n\n\n\n\n\nTo determine the shape used to join two line segments where they meet.\n\nPossible values are:\n+ `'bevel'`: Fills an additional triangular area between the common endpoint of connected segments, and the separate outside rectangular corners of each segment.\n+ `'round'`: Rounds off the corners of a shape by filling an additional sector of disc centered at the common endpoint of connected segments. The radius for these rounded corners is equal to the line width.\n+ `'miter'`: Connected segments are joined by extending their outside edges to connect at a single point, with the effect of filling an additional lozenge-shaped area. This setting is affected by the\n`borderMiterLimit`\nproperty.\n\nDefault value is `'bevel'`. Refer to MDN [lineJoin](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/lineJoin) for more details.",
        "uiControl": {
            "default": "'bevel'",
            "type": "enum",
            "options": "'bevel','round','miter'"
        }
    },
    "handleStyle.borderMiterLimit": {
        "desc": "> Since `v5.0.0`\n\n\n\n\n\nTo set the miter limit ratio. Only works when\n`borderJoin`\nis set as `miter`.\n\nDefault value is `10`. Negative、`0`、`Infinity` and `NaN` values are ignored.\n\nRefer to MDN [miterLimit](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/miterLimit) for more details.",
        "uiControl": {
            "default": "10",
            "type": "number",
            "min": "0",
            "step": "1"
        }
    },
    "handleStyle.shadowBlur": {
        "desc": "Size of shadow blur. This attribute should be used along with `shadowColor`,`shadowOffsetX`, `shadowOffsetY` to set shadow to component.\n\nFor example:\n```js\n{\nshadowColor: 'rgba(0, 0, 0, 0.5)',\nshadowBlur: 10\n}\n```",
        "uiControl": {
            "default": "",
            "type": "number",
            "min": "0",
            "step": "0.5"
        }
    },
    "handleStyle.shadowColor": {
        "desc": "Shadow color. Support same format as `color`.",
        "uiControl": {
            "default": "",
            "type": "color"
        }
    },
    "handleStyle.shadowOffsetX": {
        "desc": "Offset distance on the horizontal direction of shadow.",
        "uiControl": {
            "default": "0",
            "type": "number",
            "step": "0.5"
        }
    },
    "handleStyle.shadowOffsetY": {
        "desc": "Offset distance on the vertical direction of shadow.",
        "uiControl": {
            "default": "0",
            "type": "number",
            "step": "0.5"
        }
    },
    "handleStyle.opacity": {
        "desc": "Opacity of the component. Supports value from 0 to 1, and the component will not be drawn when set to 0.",
        "uiControl": {
            "default": "1",
            "type": "number",
            "min": "0",
            "max": "1",
            "step": "0.01"
        }
    },
    "indicatorIcon": {
        "desc": "Icon of indicator.\n\n\n\n> Since `v5.0.0`",
        "uiControl": {
            "default": "'circle'",
            "type": "string"
        }
    },
    "indicatorSize": {
        "desc": "> Since `v5.0.0`\n\n\n\nSize of indicator. It can be a percent string.",
        "uiControl": {
            "default": "'50%'",
            "type": [
                "number",
                "string"
            ]
        }
    },
    "indicatorStyle": {
        "desc": "Style of indicator.",
        "uiControl": {
            "type": "Object"
        }
    },
    "indicatorStyle.color": {
        "desc": "color.\n\n\n\n> Supports setting as solid color using `rgb(255,255,255)`, `rgba(255,255,255,1)`, `#fff`, etc. Also supports setting as gradient color and pattern fill, see [option.color](~color) for details",
        "uiControl": {
            "default": "null",
            "type": "color"
        }
    },
    "indicatorStyle.borderColor": {
        "desc": "border color, whose format is similar to that of `color`.",
        "uiControl": {
            "default": "#fff",
            "type": "color"
        }
    },
    "indicatorStyle.borderWidth": {
        "desc": "border width. No border when it is set to be 0.\n\n(${name} ? ${name} : \"\") + \" border width. No border when it is set to be 0.\"",
        "uiControl": {
            "default": "2",
            "type": "number",
            "min": "0",
            "step": "0.5"
        }
    },
    "indicatorStyle.borderType": {
        "desc": "border type.\n\n\n\nPossible values are:\n+ `'solid'`\n+ `'dashed'`\n+ `'dotted'`\n\nSince `v5.0.0`, it can also be a number or a number array to specify the [dash array](https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-dasharray) of the line. With\n`borderDashOffset`\n, we can make the line style more flexible.\n\nFor example：\n```js\n{\n\nborderType: [5, 10],\n\nborderDashOffset: 5\n}\n```",
        "uiControl": {
            "default": "'solid'",
            "type": "enum",
            "options": "'solid','dashed','dotted'"
        }
    },
    "indicatorStyle.borderDashOffset": {
        "desc": "> Since `v5.0.0`\n\n\n\n\n\nTo set the line dash offset. With\n`borderType`\n, we can make the line style more flexible.\n\nRefer to MDN [lineDashOffset](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/lineDashOffset) for more details.",
        "uiControl": {
            "default": "0",
            "type": "number",
            "min": "0",
            "step": "1"
        }
    },
    "indicatorStyle.borderCap": {
        "desc": "> Since `v5.0.0`\n\n\n\n\n\nTo specify how to draw the end points of the line.\nPossible values are:\n+ `'butt'`: The ends of lines are squared off at the endpoints.\n+ `'round'`: The ends of lines are rounded.\n+ `'square'`: The ends of lines are squared off by adding a box with an equal width and half the height of the line's thickness.\n\nDefault value is `'butt'`. Refer to MDN [lineCap](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/lineCap) for more details.",
        "uiControl": {
            "default": "'butt'",
            "type": "enum",
            "options": "'butt','round','square'"
        }
    },
    "indicatorStyle.borderJoin": {
        "desc": "> Since `v5.0.0`\n\n\n\n\n\nTo determine the shape used to join two line segments where they meet.\n\nPossible values are:\n+ `'bevel'`: Fills an additional triangular area between the common endpoint of connected segments, and the separate outside rectangular corners of each segment.\n+ `'round'`: Rounds off the corners of a shape by filling an additional sector of disc centered at the common endpoint of connected segments. The radius for these rounded corners is equal to the line width.\n+ `'miter'`: Connected segments are joined by extending their outside edges to connect at a single point, with the effect of filling an additional lozenge-shaped area. This setting is affected by the\n`borderMiterLimit`\nproperty.\n\nDefault value is `'bevel'`. Refer to MDN [lineJoin](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/lineJoin) for more details.",
        "uiControl": {
            "default": "'bevel'",
            "type": "enum",
            "options": "'bevel','round','miter'"
        }
    },
    "indicatorStyle.borderMiterLimit": {
        "desc": "> Since `v5.0.0`\n\n\n\n\n\nTo set the miter limit ratio. Only works when\n`borderJoin`\nis set as `miter`.\n\nDefault value is `10`. Negative、`0`、`Infinity` and `NaN` values are ignored.\n\nRefer to MDN [miterLimit](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/miterLimit) for more details.",
        "uiControl": {
            "default": "10",
            "type": "number",
            "min": "0",
            "step": "1"
        }
    },
    "indicatorStyle.shadowBlur": {
        "desc": "Size of shadow blur. This attribute should be used along with `shadowColor`,`shadowOffsetX`, `shadowOffsetY` to set shadow to component.\n\nFor example:\n```js\n{\nshadowColor: 'rgba(0, 0, 0, 0.5)',\nshadowBlur: 10\n}\n```",
        "uiControl": {
            "default": "2",
            "type": "number",
            "min": "0",
            "step": "0.5"
        }
    },
    "indicatorStyle.shadowColor": {
        "desc": "Shadow color. Support same format as `color`.",
        "uiControl": {
            "default": "rgba(0,0,0,0.2)",
            "type": "color"
        }
    },
    "indicatorStyle.shadowOffsetX": {
        "desc": "Offset distance on the horizontal direction of shadow.",
        "uiControl": {
            "default": "1",
            "type": "number",
            "step": "0.5"
        }
    },
    "indicatorStyle.shadowOffsetY": {
        "desc": "Offset distance on the vertical direction of shadow.",
        "uiControl": {
            "default": "1",
            "type": "number",
            "step": "0.5"
        }
    },
    "indicatorStyle.opacity": {
        "desc": "Opacity of the component. Supports value from 0 to 1, and the component will not be drawn when set to 0.",
        "uiControl": {
            "default": "1",
            "type": "number",
            "min": "0",
            "max": "1",
            "step": "0.01"
        }
    }
}